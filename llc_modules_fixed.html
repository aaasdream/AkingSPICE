<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>LLC子模組修正版測試</title>
  <style>
    body {
      font-family: Arial;
      padding: 20px;
      background: #2c3e50;
      color: white;
    }

    .container {
      max-width: 1000px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 10px;
    }

    .test-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 20px 0;
    }

    .test-module {
      background: rgba(255, 255, 255, 0.05);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #555;
    }

    .test-module h3 {
      margin-top: 0;
      color: #3498db;
    }

    .status {
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 4px;
      margin: 5px 0;
    }

    .status.success {
      background: #27ae60;
    }

    .status.fail {
      background: #e74c3c;
    }

    .status.testing {
      background: #f39c12;
    }

    #log {
      height: 350px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.4);
      padding: 15px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      margin-top: 20px;
    }

    .success {
      color: #27ae60;
    }

    .error {
      color: #e74c3c;
    }

    .warning {
      color: #f39c12;
    }

    .info {
      color: #3498db;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>🔧 LLC子模組修正版測試</h1>
    <p>使用正確的參數設置測試LLC各個子電路</p>

    <div class="test-grid">
      <div class="test-module">
        <h3>1. 基本電阻電路</h3>
        <div id="status1" class="status testing">測試中...</div>
        <div id="result1">等待測試結果</div>
      </div>

      <div class="test-module">
        <h3>2. 簡化二極體</h3>
        <div id="status2" class="status testing">測試中...</div>
        <div id="result2">等待測試結果</div>
      </div>

      <div class="test-module">
        <h3>3. LC諧振電路</h3>
        <div id="status3" class="status testing">測試中...</div>
        <div id="result3">等待測試結果</div>
      </div>

      <div class="test-module">
        <h3>4. 基本電感電路</h3>
        <div id="status4" class="status testing">測試中...</div>
        <div id="result4">等待測試結果</div>
      </div>

      <div class="test-module">
        <h3>5. 基本電容電路</h3>
        <div id="status5" class="status testing">測試中...</div>
        <div id="result5">等待測試結果</div>
      </div>

      <div class="test-module">
        <h3>6. 簡化LLC</h3>
        <div id="status6" class="status testing">測試中...</div>
        <div id="result6">等待測試結果</div>
      </div>
    </div>

    <h3>📋 詳細測試日誌</h3>
    <div id="log">開始LLC子模組修正測試...<br></div>
  </div>

  <script src="./lib-dist/AkingSPICE.umd.js"></script>

  <script>
    function log(message, type = 'info') {
      const colors = {
        'success': '#27ae60',
        'error': '#e74c3c',
        'warning': '#f39c12',
        'info': '#3498db'
      };

      const time = new Date().toLocaleTimeString();
      const logElement = document.getElementById('log');
      logElement.innerHTML += `<span style="color: ${colors[type]};">[${time}] ${message}</span><br>`;
      logElement.scrollTop = logElement.scrollHeight;
    }

    function updateStatus(testNum, status, result) {
      const statusElement = document.getElementById(`status${testNum}`);
      const resultElement = document.getElementById(`result${testNum}`);

      statusElement.className = `status ${status}`;
      statusElement.textContent = status === 'success' ? '✅ 通過' : status === 'fail' ? '❌ 失敗' : '🔄 測試中';
      resultElement.textContent = result;
    }

    async function testModule(testNum, name, testFunction) {
      log(`🧪 測試 ${testNum}: ${name}`, 'info');
      updateStatus(testNum, 'testing', '執行中...');

      try {
        const result = await testFunction();
        log(`✅ 測試 ${testNum} 通過: ${result}`, 'success');
        updateStatus(testNum, 'success', result);
        return true;
      } catch (error) {
        log(`❌ 測試 ${testNum} 失敗: ${error.message}`, 'error');
        updateStatus(testNum, 'fail', error.message);
        return false;
      }
    }

    document.addEventListener('DOMContentLoaded', async function () {
      log('🚀 開始LLC子電路修正版測試', 'success');

      if (!window.AkingSPICE) {
        log('❌ AkingSPICE未載入', 'error');
        return;
      }

      const spice = window.AkingSPICE;
      const { VoltageSource, Resistor, Capacitor, Inductor, Diode, ExplicitStateSolver } = spice;

      // 使用已知工作的參數設置
      const workingParams = {
        dt: 1e-3,            // 1ms 時間步長
        maxIterations: 20,   // 20次迭代
        tolerance: 1e-2,     // 1% 容差
        debug: false
      };

      // 測試1: 基本電阻電路 (已知可以工作)
      await testModule(1, '基本電阻電路', async () => {
        const components = [
          new VoltageSource('V1', [1, 0], 5.0),
          new Resistor('R1', [1, 0], 10.0)
        ];

        const solver = new ExplicitStateSolver();
        solver.initialize(components, workingParams.dt, workingParams);

        const result = solver.step();
        const v1 = result.nodeVoltages[1] || 0;
        const current = v1 / 10.0;

        return `V=${v1.toFixed(2)}V, I=${current.toFixed(3)}A`;
      });

      // 測試2: 簡化二極體 (用電阻模擬)
      await testModule(2, '簡化二極體', async () => {
        const components = [
          new VoltageSource('V1', [1, 0], 5.0),
          new Resistor('R_diode', [1, 2], 0.1),    // 0.1Ω 模擬導通二極體
          new Resistor('R_load', [2, 0], 10.0)
        ];

        const solver = new ExplicitStateSolver();
        solver.initialize(components, workingParams.dt, workingParams);

        const result = solver.step();
        const v2 = result.nodeVoltages[2] || 0;
        const current = v2 / 10.0;

        return `整流輸出: ${v2.toFixed(2)}V, ${current.toFixed(3)}A`;
      });

      // 測試3: LC諧振電路 (降低頻率避免數值問題)
      await testModule(3, 'LC諧振電路', async () => {
        const components = [
          new VoltageSource('V1', [1, 0], 5.0),
          new Resistor('Rs', [1, 2], 1.0),         // 串聯電阻
          new Inductor('L1', [2, 3], 1e-3),        // 1mH (較大電感)
          new Capacitor('C1', [3, 0], 10e-6),      // 10μF (較大電容)
        ];

        const solver = new ExplicitStateSolver();
        solver.initialize(components, workingParams.dt, workingParams);

        // 執行幾步看看
        for (let i = 0; i < 3; i++) {
          solver.step();
        }

        // 計算理論諧振頻率
        const fr = 1 / (2 * Math.PI * Math.sqrt(1e-3 * 10e-6));
        return `LC諧振正常, fr≈${(fr).toFixed(0)}Hz`;
      });

      // 測試4: 基本電感電路
      await testModule(4, '基本電感電路', async () => {
        const components = [
          new VoltageSource('V1', [1, 0], 5.0),
          new Resistor('Rs', [1, 2], 5.0),
          new Inductor('L1', [2, 0], 10e-3)        // 10mH
        ];

        const solver = new ExplicitStateSolver();
        solver.initialize(components, workingParams.dt, workingParams);

        const result = solver.step();
        const v2 = result.nodeVoltages[2] || 0;

        return `電感電路: V2=${v2.toFixed(2)}V`;
      });

      // 測試5: 基本電容電路
      await testModule(5, '基本電容電路', async () => {
        const components = [
          new VoltageSource('V1', [1, 0], 5.0),
          new Resistor('Rs', [1, 2], 10.0),
          new Capacitor('C1', [2, 0], 100e-6)      // 100μF
        ];

        const solver = new ExplicitStateSolver();
        solver.initialize(components, workingParams.dt, workingParams);

        const result = solver.step();
        const v2 = result.nodeVoltages[2] || 0;

        return `電容電路: V2=${v2.toFixed(2)}V`;
      });

      // 測試6: 簡化LLC組合
      await testModule(6, '簡化LLC', async () => {
        const components = [
          // 輸入
          new VoltageSource('Vin', [1, 0], 12.0),

          // 諧振電路 (降低頻率)
          new Inductor('Lr', [1, 2], 10e-3),       // 10mH 諧振電感
          new Capacitor('Cr', [2, 3], 10e-6),      // 10μF 諧振電容

          // 負載 (簡化變壓器+整流)
          new Resistor('Rload', [3, 0], 20.0)      // 20Ω 等效負載
        ];

        const solver = new ExplicitStateSolver();
        solver.initialize(components, workingParams.dt, workingParams);

        // 執行多步模擬
        let maxV3 = 0;
        for (let i = 0; i < 10; i++) {
          const result = solver.step();
          const v3 = Math.abs(result.nodeVoltages[3] || 0);
          if (v3 > maxV3) maxV3 = v3;
        }

        // 計算理論諧振頻率
        const fr = 1 / (2 * Math.PI * Math.sqrt(10e-3 * 10e-6));
        const power = (maxV3 * maxV3) / 20.0;

        return `LLC: fr≈${fr.toFixed(1)}Hz, Vmax=${maxV3.toFixed(2)}V, P≈${power.toFixed(2)}W`;
      });

      log('🎉 所有LLC子模組測試完成！', 'success');
    });

  </script>
</body>

</html>