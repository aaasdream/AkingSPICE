<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>🔍 AkingSPICE 深度調試 - 電壓源問題診斷</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 20px; 
            background: #f0f0f0;
        }
        .container {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .header {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        button {
            background: #dc2626;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9em;
        }
        button:hover:not(:disabled) { background: #b91c1c; }
        button:disabled { background: #aaa; cursor: not-allowed; }
        .log {
            background: #1e1e1e;
            color: #00ff00;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            white-space: pre-wrap;
        }
        .debug-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .chart-container {
            height: 350px;
            background: #fafafa;
            border-radius: 8px;
            padding: 10px;
        }
        .status {
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: bold;
            margin: 5px 0;
        }
        .status.error { background: #fee; color: #c00; }
        .status.success { background: #efe; color: #060; }
        .status.warning { background: #ffe; color: #960; }
    </style>
</head>
<body>

<div class="container">
    <div class="header">
        <h1>🔍 AkingSPICE 深度調試 - 電壓源問題診斷</h1>
        <p>詳細分析為什麼所有節點電壓都是 0V</p>
    </div>

    <div class="controls">
        <button id="debugBtn">🔍 深度調試</button>
        <button id="testVSourceBtn">⚡ 測試電壓源</button>
        <button id="matrixBtn">📊 查看系統矩陣</button>
        <button id="clearBtn">清除</button>
        <span style="color: #666;">| 目標: 找出電壓源失效原因</span>
    </div>

    <div class="log" id="debugLog">準備進行深度調試...</div>
</div>

<div class="debug-section">
    <div class="container">
        <h3>🧮 系統狀態分析</h3>
        <div id="systemStatus">等待分析...</div>
        <div class="chart-container">
            <canvas id="voltageChart"></canvas>
        </div>
    </div>
    
    <div class="container">
        <h3>⚡ 電路元件診斷</h3>
        <div id="componentStatus">等待診斷...</div>
        <div class="chart-container">
            <canvas id="currentChart"></canvas>
        </div>
    </div>
</div>

<script src="./lib-dist/AkingSPICE.umd.js"></script>

<script>
document.addEventListener('DOMContentLoaded', () => {
    let voltageChart = null;
    let currentChart = null;
    
    // 初始化圖表
    function initCharts() {
        const voltageCtx = document.getElementById('voltageChart').getContext('2d');
        voltageChart = new Chart(voltageCtx, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { title: { display: true, text: '節點電壓分析' } },
                scales: {
                    x: { title: { display: true, text: '時間 (ms)' } },
                    y: { title: { display: true, text: '電壓 (V)' } }
                }
            }
        });
        
        const currentCtx = document.getElementById('currentChart').getContext('2d');
        currentChart = new Chart(currentCtx, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { title: { display: true, text: '元件電流分析' } },
                scales: {
                    x: { title: { display: true, text: '時間 (ms)' } },
                    y: { title: { display: true, text: '電流 (A)' } }
                }
            }
        });
    }

    function log(message, type = 'info') {
        const debugLog = document.getElementById('debugLog');
        const timestamp = new Date().toLocaleTimeString();
        const colors = {
            error: '#ff4444',
            success: '#44ff44', 
            warning: '#ffff44',
            info: '#44ffff',
            debug: '#ff44ff'
        };
        const color = colors[type] || '#00ff00';
        debugLog.innerHTML += `<span style="color: ${color}">[${timestamp}] ${message}</span>\n`;
        debugLog.scrollTop = debugLog.scrollHeight;
    }

    function updateStatus(containerId, content, type = 'info') {
        const container = document.getElementById(containerId);
        container.innerHTML = `<div class="status ${type}">${content}</div>`;
    }

    async function deepDebugAnalysis() {
        try {
            log('🔍 開始深度調試分析...', 'info');
            
            // 檢查庫
            if (typeof AkingSPICE === 'undefined') {
                throw new Error('AkingSPICE 庫未載入');
            }
            log('✅ AkingSPICE 庫載入成功', 'success');
            
            // 列出所有可用的類
            log('📋 可用類型:', 'debug');
            for (const key in AkingSPICE) {
                log(`   ${key}: ${typeof AkingSPICE[key]}`, 'debug');
            }
            
            // 創建求解器
            const solver = new AkingSPICE.ExplicitStateSolver();
            log('✅ ExplicitStateSolver 創建成功', 'success');
            
            // 檢查求解器方法
            log('📋 求解器方法:', 'debug');
            for (const method of ['initialize', 'step', 'reset', 'getState']) {
                log(`   ${method}: ${typeof solver[method]}`, 'debug');
            }
            
            // 創建測試電路
            const { VoltageSource, Resistor, Capacitor } = AkingSPICE;
            
            log('🔧 創建測試組件...', 'info');
            
            // 測試不同的電壓源創建方式
            let vsource = null;
            try {
                vsource = new VoltageSource('V1', ['1', '0'], 12);
                log(`✅ 電壓源創建成功: ${vsource.constructor.name}`, 'success');
                log(`   節點: ${vsource.nodes ? vsource.nodes.join(', ') : '未知'}`, 'debug');
                log(`   電壓值: ${vsource.voltage || vsource.value || '未知'}V`, 'debug');
            } catch (e) {
                log(`❌ 電壓源創建失敗: ${e.message}`, 'error');
                return;
            }
            
            let resistor = null;
            try {
                resistor = new Resistor('R1', ['1', '2'], 1000);
                log(`✅ 電阻創建成功: ${resistor.constructor.name}`, 'success');
                log(`   阻值: ${resistor.resistance || resistor.value || '未知'}Ω`, 'debug');
            } catch (e) {
                log(`❌ 電阻創建失敗: ${e.message}`, 'error');
                return;
            }
            
            let capacitor = null;
            try {
                capacitor = new Capacitor('C1', ['2', '0'], 1e-6, { ic: 0 });
                log(`✅ 電容創建成功: ${capacitor.constructor.name}`, 'success');
                log(`   容值: ${capacitor.capacitance || capacitor.value || '未知'}F`, 'debug');
            } catch (e) {
                log(`❌ 電容創建失敗: ${e.message}`, 'error');
                return;
            }
            
            const components = [vsource, resistor, capacitor];
            log('📦 所有組件創建完成', 'success');
            
            // 檢查組件內部結構
            log('🔍 組件內部結構分析:', 'debug');
            components.forEach((comp, i) => {
                log(`   組件 ${i}: ${comp.constructor.name}`, 'debug');
                for (const key in comp) {
                    if (typeof comp[key] !== 'function') {
                        log(`     ${key}: ${comp[key]}`, 'debug');
                    }
                }
            });
            
            // 嘗試初始化
            const timeStep = 10e-6;
            log(`🚀 嘗試初始化求解器 (timeStep=${timeStep*1e6}µs)...`, 'info');
            
            try {
                await solver.initialize(components, timeStep, {
                    debug: true,  // 開啟調試模式
                    integrationMethod: 'forward_euler'
                });
                log('✅ 求解器初始化成功', 'success');
            } catch (initError) {
                log(`❌ 初始化失敗: ${initError.message}`, 'error');
                log(`   堆疊: ${initError.stack}`, 'debug');
                return;
            }
            
            // 檢查初始狀態
            try {
                if (typeof solver.getState === 'function') {
                    const state = solver.getState();
                    log('🔍 初始狀態檢查:', 'info');
                    if (state && state.nodeVoltages) {
                        for (const [node, voltage] of Object.entries(state.nodeVoltages)) {
                            log(`   節點 ${node}: ${voltage}V`, 'debug');
                        }
                    } else {
                        log('   ⚠️  無法獲取初始節點電壓', 'warning');
                    }
                } else {
                    log('   ⚠️  求解器沒有 getState 方法', 'warning');
                }
            } catch (stateError) {
                log(`   ⚠️  狀態檢查失敗: ${stateError.message}`, 'warning');
            }
            
            // 嘗試單步執行
            log('⚡ 執行第一步...', 'info');
            try {
                const result = solver.step({});
                log('✅ 第一步執行成功', 'success');
                
                if (result && result.nodeVoltages) {
                    log('📊 第一步結果:', 'info');
                    for (const [node, voltage] of Object.entries(result.nodeVoltages)) {
                        log(`   節點 ${node}: ${voltage}V`, 'debug');
                    }
                    
                    if (Math.max(...Object.values(result.nodeVoltages)) === 0) {
                        log('❌ 關鍵問題: 所有節點電壓都是 0V!', 'error');
                        log('   可能原因:', 'warning');
                        log('   1. 電壓源未正確添加到系統矩陣', 'warning');
                        log('   2. 節點編號映射錯誤', 'warning');  
                        log('   3. 初始條件設置問題', 'warning');
                        log('   4. 求解器內部算法錯誤', 'warning');
                    }
                } else {
                    log('❌ 第一步沒有返回有效結果', 'error');
                }
            } catch (stepError) {
                log(`❌ 第一步執行失敗: ${stepError.message}`, 'error');
                log(`   堆疊: ${stepError.stack}`, 'debug');
            }
            
            updateStatus('systemStatus', '深度分析完成，發現電壓源可能未正確工作', 'error');
            updateStatus('componentStatus', '所有組件創建成功，但系統矩陣可能有問題', 'warning');
            
        } catch (error) {
            log(`❌ 深度調試失敗: ${error.message}`, 'error');
            log(`   堆疊: ${error.stack}`, 'debug');
        }
    }

    async function testVoltageSource() {
        try {
            log('⚡ 測試電壓源獨立功能...', 'info');
            
            const { VoltageSource } = AkingSPICE;
            
            // 嘗試不同的參數組合
            const testCases = [
                { nodes: ['1', '0'], voltage: 12 },
                { nodes: [1, 0], voltage: 12 },
                { nodes: ['pos', 'gnd'], voltage: 12 },
                { nodes: ['a', 'b'], voltage: 5 }
            ];
            
            for (let i = 0; i < testCases.length; i++) {
                const testCase = testCases[i];
                try {
                    const vs = new VoltageSource(`V${i+1}`, testCase.nodes, testCase.voltage);
                    log(`✅ 測試 ${i+1}: 節點=${JSON.stringify(testCase.nodes)}, 電壓=${testCase.voltage}V`, 'success');
                    
                    // 檢查內部屬性
                    for (const key in vs) {
                        if (typeof vs[key] !== 'function' && key !== 'constructor') {
                            log(`     ${key}: ${vs[key]}`, 'debug');
                        }
                    }
                } catch (e) {
                    log(`❌ 測試 ${i+1} 失敗: ${e.message}`, 'error');
                }
            }
            
        } catch (error) {
            log(`❌ 電壓源測試失敗: ${error.message}`, 'error');
        }
    }

    function clearLog() {
        document.getElementById('debugLog').innerHTML = '準備進行深度調試...';
        updateStatus('systemStatus', '等待分析...', 'info');
        updateStatus('componentStatus', '等待診斷...', 'info');
    }

    // 初始化
    initCharts();
    
    // 事件監聽器
    document.getElementById('debugBtn').addEventListener('click', deepDebugAnalysis);
    document.getElementById('testVSourceBtn').addEventListener('click', testVoltageSource);
    document.getElementById('clearBtn').addEventListener('click', clearLog);
});
</script>

</body>
</html>