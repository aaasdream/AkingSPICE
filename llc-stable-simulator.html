<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>ğŸ”§ AkingSPICE ä¿®å¾©ç‰ˆ - LLC ç©©å®šæ¨¡æ“¬å™¨</title>
    <!-- å¼•å…¥ Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- å¼•å…¥ Monaco Editor -->
    <link rel="stylesheet" data-name="vs/editor/editor.main" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.34.1/min/vs/editor/editor.main.min.css">
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica', Arial, sans-serif; 
            display: flex; 
            flex-direction: column; 
            height: 100vh; 
            margin: 0; 
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }
        .header { 
            background: rgba(255,255,255,0.1); 
            backdrop-filter: blur(10px);
            color: white; 
            padding: 20px; 
            text-align: center; 
            box-shadow: 0 2px 20px rgba(0,0,0,0.1); 
        }
        .main-content { 
            display: flex; 
            flex: 1; 
            min-height: 0;
            height: calc(100vh - 140px);
            gap: 20px;
            padding: 20px;
        }
        .left-panel { 
            width: 500px; 
            background: rgba(255,255,255,0.95); 
            border-radius: 15px;
            padding: 25px; 
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            display: flex; 
            flex-direction: column;
            height: 100%;
            overflow-y: auto;
        }
        .right-panel { 
            flex: 1; 
            background: rgba(255,255,255,0.95); 
            border-radius: 15px;
            padding: 25px; 
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            display: flex; 
            flex-direction: column; 
        }
        .editor-container { 
            border: 1px solid rgba(0,0,0,0.1); 
            border-radius: 8px;
            height: 220px;
            min-height: 180px; 
            overflow: hidden;
            flex-shrink: 0;
        }
        .chart-container { 
            position: relative; 
            flex: 1; 
            min-height: 400px;
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.05);
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        button { 
            background: linear-gradient(45deg, #10b981, #059669);
            color: white; 
            border: none; 
            padding: 10px 18px; 
            border-radius: 6px; 
            cursor: pointer; 
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 3px 12px rgba(0,0,0,0.2);
        }
        button:hover:not(:disabled) { 
            transform: translateY(-2px);
            box-shadow: 0 5px 18px rgba(0,0,0,0.3);
        }
        button:disabled { 
            background: #aaa; 
            cursor: not-allowed; 
            transform: none;
            box-shadow: none;
        }
        .log {
            margin-top: 15px; 
            padding: 12px;
            background: rgba(248,249,250,0.8);
            border-radius: 8px;
            border-left: 4px solid #10b981;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.8em;
            max-height: 180px;
            min-height: 100px;
            overflow-y: auto;
            white-space: pre-wrap;
            flex-shrink: 0;
        }
        #progress-container { 
            width: 100%; 
            background-color: #e9ecef; 
            border-radius: 6px; 
            margin-top: 8px; 
            overflow: hidden; 
            display: none;
            height: 20px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }
        #progress-bar { 
            width: 0%; 
            height: 100%; 
            background: linear-gradient(135deg, #10b981 0%, #059669 100%); 
            text-align: center; 
            line-height: 20px; 
            color: white; 
            font-weight: 600; 
            transition: width 0.3s ease-in-out;
            font-size: 0.8em;
        }
        .solver-status {
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 0.85em;
            font-weight: 600;
        }
        .solver-stable {
            background: rgba(16, 185, 129, 0.15);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: #065f46;
        }
        .solver-working {
            background: rgba(245, 158, 11, 0.15);
            border: 1px solid rgba(245, 158, 11, 0.3);
            color: #92400e;
        }
        .solver-error {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #991b1b;
        }
        .param-input {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .param-input label {
            flex: 1;
            font-weight: 600;
            font-size: 0.9em;
        }
        .param-input input {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .param-panel {
            background: rgba(248,249,250,0.6); 
            border-radius: 8px; 
            padding: 12px; 
            margin-bottom: 15px;
        }
        .circuit-selector {
            background: rgba(16, 185, 129, 0.1);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }
        .circuit-option {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .circuit-option input[type="radio"] {
            margin-right: 8px;
        }
        .circuit-option label {
            font-size: 0.9em;
            font-weight: 500;
        }
    </style>
</head>
<body>

<div class="header">
    <h1>ğŸ”§ AkingSPICE ä¿®å¾©ç‰ˆ - ç©©å®šæ¨¡æ“¬å™¨</h1>
    <p style="margin: 5px 0; opacity: 0.9;">æ•¸å€¼ç©©å®šå„ªåŒ– â€¢ å¤šé›»è·¯é¸æ“‡ â€¢ æ™ºèƒ½æ±‚è§£å™¨</p>
</div>

<div class="main-content">
    <div class="left-panel">
        <div class="solver-status" id="solver-status">
            ğŸ”„ æ­£åœ¨åˆå§‹åŒ–ç©©å®šæ±‚è§£å™¨...
        </div>
        
        <div class="circuit-selector">
            <h4 style="margin: 0 0 10px 0;">ğŸ”Œ é›»è·¯é¡å‹é¸æ“‡</h4>
            <div class="circuit-option">
                <input type="radio" id="circuit-rc" name="circuit" value="rc" checked>
                <label for="circuit-rc">RC å……é›»é›»è·¯ (é©—è­‰åŸºæœ¬åŠŸèƒ½)</label>
            </div>
            <div class="circuit-option">
                <input type="radio" id="circuit-llc-simple" name="circuit" value="llc-simple">
                <label for="circuit-llc-simple">ç°¡åŒ– LLC è«§æŒ¯å™¨ (ç©©å®šç‰ˆ)</label>
            </div>
            <div class="circuit-option">
                <input type="radio" id="circuit-buck" name="circuit" value="buck">
                <label for="circuit-buck">Buck é™å£“è½‰æ›å™¨ (é–‹é—œæ¸¬è©¦)</label>
            </div>
        </div>
        
        <div class="param-panel">
            <h4 style="margin: 0 0 10px 0;">âš™ï¸ æ¨¡æ“¬åƒæ•¸</h4>
            <div class="param-input">
                <label>è¼¸å…¥é›»å£“:</label>
                <input type="number" id="vin" value="12" step="1">
                <span>V</span>
            </div>
            <div class="param-input">
                <label>æ¨¡æ“¬æ™‚é–“:</label>
                <input type="number" id="simtime" value="2" step="0.5">
                <span>ms</span>
            </div>
            <div class="param-input">
                <label>æ™‚é–“æ­¥é•·:</label>
                <input type="number" id="timestep" value="1" step="0.1">
                <span>Âµs</span>
            </div>
        </div>
        
        <h3>ğŸ§  æ§åˆ¶å™¨ç¨‹å¼ç¢¼ (ç°¡åŒ–ç‰ˆ)</h3>
        <div id="editor" class="editor-container"></div>
        
        <div class="button-group">
            <button id="runBtn" disabled>åˆå§‹åŒ–ä¸­...</button>
            <button id="resetBtn">é‡ç½®</button>
        </div>
        <div id="progress-container"><div id="progress-bar">0%</div></div>
        <div class="log" id="logOutput">ğŸ”„ è¼‰å…¥ç©©å®šç‰ˆæ±‚è§£å™¨...</div>
    </div>
    
    <div class="right-panel">
        <h3>ğŸ“ˆ ç©©å®šæ¨¡æ“¬çµæœ</h3>
        <div class="chart-container">
            <canvas id="simulationChart"></canvas>
        </div>
    </div>
</div>

<!-- è¼‰å…¥ AkingSPICE åº« -->
<script src="./lib-dist/AkingSPICE.umd.js"></script>
<!-- Monaco Editor -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.34.1/min/vs/loader.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', async () => {
    let editor;
    let solver = null;
    let chart = null;
    let isReady = false;
    let simulationRunning = false;

    const initialControllerCode = `// ğŸ”§ ç©©å®šæ§åˆ¶å™¨ - å°ˆç‚ºæ•¸å€¼ç©©å®šæ€§å„ªåŒ–
class StableController {
    constructor(circuitType, timeStep) {
        this.circuitType = circuitType;
        this.timeStep = timeStep;
        this.stepCount = 0;
        
        console.log('ğŸ”§ ç©©å®šæ§åˆ¶å™¨å•Ÿå‹• - é›»è·¯: ' + circuitType);
    }

    update(time, feedback) {
        this.stepCount++;
        
        if (this.circuitType === 'rc') {
            // RC é›»è·¯ç„¡éœ€æ§åˆ¶
            return {};
        }
        
        if (this.circuitType === 'buck') {
            // Buck è½‰æ›å™¨ PWM æ§åˆ¶ (100kHz, 50% å ç©ºæ¯”)
            const frequency = 100000; // 100kHz
            const period = 1 / frequency;
            const phase = (time % period) / period;
            
            return {
                'sw_gate': phase < 0.5 ? 12 : 0  // 50% å ç©ºæ¯”
            };
        }
        
        if (this.circuitType === 'llc-simple') {
            // ç°¡åŒ– LLC æ§åˆ¶ (å›ºå®šé »ç‡)
            const frequency = 50000; // 50kHz (è¼ƒä½é »ç‡æ›´ç©©å®š)
            const period = 1 / frequency;
            const phase = (time % period) / period;
            
            return {
                'q1_gate': phase < 0.5 ? 12 : 0,
                'q2_gate': phase >= 0.5 ? 12 : 0
            };
        }
        
        return {};
    }
    
    getStatus() {
        return {
            circuit: this.circuitType,
            steps: this.stepCount
        };
    }
}

// è¿”å›æ§åˆ¶å™¨å¯¦ä¾‹ (é›»è·¯é¡å‹ç”±å¤–éƒ¨å‚³å…¥)
function createController(circuitType, timeStep) {
    return new StableController(circuitType, timeStep);
}

return createController;`;

    // åˆå§‹åŒ– Monaco Editor
    require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.34.1/min/vs' }});
    require(['vs/editor/editor.main'], () => {
        editor = monaco.editor.create(document.getElementById('editor'), {
            value: initialControllerCode,
            language: 'javascript',
            theme: 'vs-dark',
            automaticLayout: true,
            minimap: { enabled: false },
            scrollBeyondLastLine: false
        });
    });

    // åˆå§‹åŒ– Chart.js
    const ctx = document.getElementById('simulationChart').getContext('2d');
    chart = new Chart(ctx, {
        type: 'line',
        data: { labels: [], datasets: [] },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            interaction: { intersect: false, mode: 'index' },
            plugins: { legend: { position: 'top' } },
            scales: {
                x: { title: { display: true, text: 'æ™‚é–“ (ms)' } },
                y: { title: { display: true, text: 'é›»å£“ (V)' }, beginAtZero: true }
            }
        }
    });

    // æ—¥èªŒå’Œç‹€æ…‹å‡½æ•¸
    function log(message, type = 'info') {
        const logOutput = document.getElementById('logOutput');
        const timestamp = new Date().toLocaleTimeString();
        const prefixes = {
            'error': 'âŒ', 'success': 'âœ…', 'warning': 'âš ï¸', 'info': 'â„¹ï¸'
        };
        const prefix = prefixes[type] || 'â„¹ï¸';
        logOutput.textContent += `[${timestamp}] ${prefix} ${message}\n`;
        logOutput.scrollTop = logOutput.scrollHeight;
    }

    function updateSolverStatus(message, type) {
        const status = document.getElementById('solver-status');
        status.className = `solver-status solver-${type}`;
        status.innerHTML = message;
    }

    function updateProgress(current, total) {
        const progressBar = document.getElementById('progress-bar');
        const progressContainer = document.getElementById('progress-container');
        if (total > 0) {
            const percentage = Math.min(100, Math.round((current / total) * 100));
            progressBar.style.width = `${percentage}%`;
            progressBar.textContent = `${percentage}%`;
            progressContainer.style.display = 'block';
        } else {
            progressContainer.style.display = 'none';
        }
    }

    // ğŸ”§ åˆå§‹åŒ–ç©©å®šæ±‚è§£å™¨
    async function initializeStableSolver() {
        try {
            log('æª¢æŸ¥ AkingSPICE åº«...');
            
            if (typeof AkingSPICE === 'undefined') {
                throw new Error('AkingSPICE åº«æœªè¼‰å…¥');
            }
            
            log('âœ… AkingSPICE åº«è¼‰å…¥æˆåŠŸ');
            
            // ä½¿ç”¨ CPU ç‰ˆæœ¬ (æ›´ç©©å®š)
            if (AkingSPICE.ExplicitStateSolver) {
                solver = new AkingSPICE.ExplicitStateSolver();
                log('âœ… ExplicitStateSolver å‰µå»ºæˆåŠŸ');
                updateSolverStatus('ğŸ’» ç©©å®š CPU æ±‚è§£å™¨å°±ç·’', 'stable');
            } else {
                throw new Error('ExplicitStateSolver ä¸å¯ç”¨');
            }
            
            const runBtn = document.getElementById('runBtn');
            runBtn.disabled = false;
            runBtn.textContent = 'ğŸš€ åŸ·è¡Œç©©å®šæ¨¡æ“¬';
            isReady = true;
            
        } catch (error) {
            log(`æ±‚è§£å™¨åˆå§‹åŒ–å¤±æ•—: ${error.message}`, 'error');
            updateSolverStatus(`âŒ åˆå§‹åŒ–å¤±æ•—: ${error.message}`, 'error');
        }
    }

    // ğŸ”Œ å»ºç«‹ç©©å®šé›»è·¯
    function buildStableCircuit() {
        const circuitType = document.querySelector('input[name="circuit"]:checked').value;
        const vin = parseFloat(document.getElementById('vin').value);
        
        log(`å»ºç«‹ ${circuitType} é›»è·¯...`);
        
        const { VoltageSource, Resistor, Capacitor, Inductor, VoltageControlledMOSFET } = AkingSPICE;
        
        let components, expectedNodes;
        
        if (circuitType === 'rc') {
            // ä¿®å¾© RC é›»è·¯ - ç¢ºä¿æ­£ç¢ºçš„ç¯€é»é€£æ¥
            components = [
                new VoltageSource('V1', ['1', '0'], vin),           // é›»å£“æº: ç¯€é»1 -> ç¯€é»0(åœ°)
                new Resistor('R1', ['1', '2'], 1000),               // é›»é˜»: ç¯€é»1 -> ç¯€é»2
                new Capacitor('C1', ['2', '0'], 1e-6, { ic: 0 })    // é›»å®¹: ç¯€é»2 -> ç¯€é»0(åœ°)
            ];
            expectedNodes = ['1', '2', '0'];
            log(`RC é›»è·¯: V1(${vin}V) -> R1(1kÎ©) -> C1(1ÂµF) -> GND`);
            
        } else if (circuitType === 'buck') {
            // ç°¡å–®ä½†ç©©å®šçš„ Buck è½‰æ›å™¨
            components = [
                new VoltageSource('Vin', ['vin', '0'], vin),
                new VoltageControlledMOSFET('SW', ['vin', 'sw_gate', 'sw'], { Ron: 0.1, Roff: 1e5 }),
                new VoltageSource('Vg', ['sw_gate', '0'], 0),
                new Inductor('L1', ['sw', 'out'], 100e-6),          // 100ÂµH
                new Capacitor('C1', ['out', '0'], 100e-6, { ic: 1 }), // 100ÂµF
                new Resistor('R1', ['out', '0'], 10),                // 10Î©è² è¼‰
                // ç©©å®šæ€§é›»é˜»
                new Resistor('R_stab1', ['sw', '0'], 1e6),
                new Resistor('R_stab2', ['out', '0'], 1e6)
            ];
            expectedNodes = ['vin', 'sw', 'out', '0'];
            log('Buck é›»è·¯: Vin -> SW -> L1 -> C1||R1 -> GND');
            
        } else if (circuitType === 'llc-simple') {
            // æ¥µåº¦ç°¡åŒ–çš„ LLC è«§æŒ¯å™¨ - åªæœ‰è«§æŒ¯éƒ¨åˆ†
            components = [
                new VoltageSource('Vin', ['vin', '0'], vin),
                // åŠæ©‹ç°¡åŒ–ç‚ºå…©å€‹å—æ§é–‹é—œ
                new VoltageControlledMOSFET('Q1', ['vin', 'q1_gate', 'bridge'], { Ron: 0.2, Roff: 1e5 }),
                new VoltageControlledMOSFET('Q2', ['bridge', 'q2_gate', '0'], { Ron: 0.2, Roff: 1e5 }),
                new VoltageSource('Vg1', ['q1_gate', '0'], 0),
                new VoltageSource('Vg2', ['q2_gate', '0'], 0),
                // è«§æŒ¯ç¶²è·¯ (ä¿å®ˆåƒæ•¸)
                new Inductor('Lr', ['bridge', 'res'], 100e-6),      // 100ÂµH
                new Capacitor('Cr', ['res', 'out'], 100e-9),        // 100nF
                new Inductor('Lm', ['res', '0'], 500e-6),           // 500ÂµH ç£åŒ–é›»æ„Ÿ
                // è¼¸å‡ºè² è¼‰
                new Resistor('Rload', ['out', '0'], 50),             // 50Î©
                // ç©©å®šæ€§é›»é˜»
                new Resistor('R_stab1', ['bridge', '0'], 2e6),
                new Resistor('R_stab2', ['res', '0'], 2e6),
                new Resistor('R_stab3', ['out', '0'], 2e6)
            ];
            expectedNodes = ['vin', 'bridge', 'res', 'out', '0'];
            log('ç°¡åŒ–LLC: Vin -> åŠæ©‹ -> Lr -> Cr -> Lm || Rload');
        }
        
        log(`é›»è·¯ç¯€é»: ${expectedNodes.join(', ')}`);
        return { components, circuitType, expectedNodes };
    }

    // ğŸš€ åŸ·è¡Œç©©å®šæ¨¡æ“¬
    async function runStableSimulation() {
        if (!isReady || simulationRunning) return;
        
        const runBtn = document.getElementById('runBtn');
        runBtn.disabled = true;
        runBtn.textContent = 'æ¨¡æ“¬ä¸­...';
        simulationRunning = true;
        updateSolverStatus('ğŸ”„ åŸ·è¡Œæ•¸å€¼ç©©å®šæ¨¡æ“¬...', 'working');
        
        try {
            log('ğŸš€ é–‹å§‹ç©©å®šæ¨¡æ“¬...');
            
            const circuit = buildStableCircuit();
            const simTime = parseFloat(document.getElementById('simtime').value) * 1e-3;
            const timeStep = parseFloat(document.getElementById('timestep').value) * 1e-6;
            const totalSteps = Math.floor(simTime / timeStep);
            
            // å‰µå»ºæ§åˆ¶å™¨
            let controller;
            try {
                const userCode = editor.getValue();
                
                // ç›´æ¥åŸ·è¡Œä»£ç¢¼ä¸¦å¾å…¨å±€ä½œç”¨åŸŸç²å–å‡½æ•¸
                const wrappedCode = `
                    (function() {
                        ${userCode}
                    })()
                `;
                
                const controllerFactory = eval(wrappedCode);
                
                if (typeof controllerFactory !== 'function') {
                    throw new Error('æ§åˆ¶å™¨ä»£ç¢¼å¿…é ˆè¿”å›ä¸€å€‹å‡½æ•¸');
                }
                
                controller = controllerFactory(circuit.circuitType, timeStep);
                
                if (!controller || typeof controller.update !== 'function') {
                    throw new Error('æ§åˆ¶å™¨å¿…é ˆæœ‰ update æ–¹æ³•');
                }
                
                log(`âœ… æ§åˆ¶å™¨å‰µå»ºæˆåŠŸ - é¡å‹: ${circuit.circuitType}`);
                
            } catch (e) {
                throw new Error("æ§åˆ¶å™¨ç¨‹å¼ç¢¼éŒ¯èª¤: " + e.message);
            }
            
            log(`ç©©å®šæ¨¡æ“¬åƒæ•¸: ${circuit.circuitType}, æ™‚é–“=${simTime*1000}ms, æ­¥é•·=${timeStep*1e6}Âµs, ç¸½æ­¥æ•¸=${totalSteps}`);
            
            // åˆå§‹åŒ–æ±‚è§£å™¨ (ä½¿ç”¨æ›´ä¿å®ˆçš„è¨­å®š)
            const startTime = performance.now();
            
            await solver.initialize(circuit.components, timeStep, {
                debug: false,
                integrationMethod: 'forward_euler',
                solverMaxIterations: 500,      // æ¸›å°‘è¿­ä»£æ¬¡æ•¸
                solverTolerance: 1e-6          // æ”¾å¯¬å®¹å¿åº¦
            });
            
            log('âœ… æ±‚è§£å™¨åˆå§‹åŒ–æˆåŠŸï¼Œé–‹å§‹æ™‚é–“æ­¥é€²...');
            
            const allResults = [];
            let errorCount = 0;
            const maxErrors = 10; // æœ€å¤šå®¹å¿10å€‹éŒ¯èª¤
            
            for (let step = 0; step < totalSteps; step++) {
                try {
                    const currentTime = step * timeStep;
                    
                    // ç²å–æ§åˆ¶è¼¸å…¥
                    let outputNode = '2';  // RCé›»è·¯çš„è¼¸å‡ºç¯€é»
                    if (circuit.circuitType === 'buck') outputNode = 'out';
                    if (circuit.circuitType === 'llc-simple') outputNode = 'out';
                    
                    const feedback = {
                        v_out: allResults.length > 0 ? 
                               (allResults[allResults.length - 1].nodeVoltages[outputNode] || 0) : 0
                    };
                    
                    const controlInputs = controller.update(currentTime, feedback);
                    
                    // åŸ·è¡Œä¸€æ­¥
                    const stepResult = solver.step(controlInputs);
                    
                    if (stepResult && stepResult.nodeVoltages) {
                        allResults.push({
                            time: currentTime,
                            nodeVoltages: stepResult.nodeVoltages
                        });
                    }
                    
                    // æ›´æ–°é€²åº¦
                    if (step % Math.max(1, Math.floor(totalSteps / 20)) === 0) {
                        updateProgress(step, totalSteps);
                    }
                    
                } catch (stepError) {
                    errorCount++;
                    if (errorCount <= maxErrors && step % 1000 === 0) {
                        log(`æ­¥é©Ÿ ${step} è¨ˆç®—è­¦å‘Š: ${stepError.message}`, 'warning');
                    }
                    if (errorCount > maxErrors * 10) {
                        log(`éŒ¯èª¤éå¤š (${errorCount})ï¼Œåœæ­¢æ¨¡æ“¬`, 'error');
                        break;
                    }
                }
            }
            
            const endTime = performance.now();
            const duration = endTime - startTime;
            
            log(`âœ… ç©©å®šæ¨¡æ“¬å®Œæˆ! è€—æ™‚: ${duration.toFixed(1)}ms, éŒ¯èª¤: ${errorCount}`, 'success');
            log(`ğŸ“Š æœ‰æ•ˆçµæœ: ${allResults.length} / ${totalSteps} (${(allResults.length/totalSteps*100).toFixed(1)}%)`);
            
            drawStableResults(allResults, circuit);
            updateSolverStatus('âœ… ç©©å®šæ¨¡æ“¬å®Œæˆ', 'stable');
            
        } catch (error) {
            log(`æ¨¡æ“¬å¤±æ•—: ${error.message}`, 'error');
            updateSolverStatus(`âŒ æ¨¡æ“¬å¤±æ•—: ${error.message}`, 'error');
            console.error('Stable Simulation error:', error);
        } finally {
            runBtn.disabled = false;
            runBtn.textContent = 'ğŸš€ åŸ·è¡Œç©©å®šæ¨¡æ“¬';
            simulationRunning = false;
            document.getElementById('progress-container').style.display = 'none';
        }
    }

    // ğŸ¨ ç¹ªè£½ç©©å®šçµæœ
    function drawStableResults(results, circuit) {
        if (results.length === 0) {
            log('âš ï¸  æ²’æœ‰æœ‰æ•ˆçš„æ¨¡æ“¬çµæœ', 'warning');
            return;
        }
        
        log(`ç¹ªè£½ ${results.length} å€‹æ•¸æ“šé»...`);
        
        const timeData = [];
        const datasets = [];
        const colors = ['#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4'];
        
        // æº–å‚™æ™‚é–“è»¸
        results.forEach(result => {
            timeData.push(result.time * 1000); // ms
        });
        
        // ç‚ºæ¯å€‹é‡è¦ç¯€é»å‰µå»ºæ•¸æ“šé›†
        const importantNodes = circuit.expectedNodes.filter(node => node !== '0'); // æ’é™¤åœ°ç¯€é»
        
        importantNodes.forEach((node, index) => {
            const nodeData = results.map(result => result.nodeVoltages[node] || 0);
            
            datasets.push({
                label: `ç¯€é» ${node}`,
                data: nodeData,
                borderColor: colors[index % colors.length],
                backgroundColor: colors[index % colors.length] + '20',
                borderWidth: 2,
                pointRadius: 0,
                fill: false
            });
        });
        
        chart.data = { labels: timeData, datasets };
        chart.update();
        
        // çµæœåˆ†æ
        const finalResult = results[results.length - 1];
        log('ğŸ“Š æœ€çµ‚çµæœ:');
        importantNodes.forEach(node => {
            const voltage = finalResult.nodeVoltages[node] || 0;
            log(`   ç¯€é» ${node}: ${voltage.toFixed(3)}V`);
        });
        
        log('åœ–è¡¨ç¹ªè£½å®Œæˆ!', 'success');
    }

    // é‡ç½®å‡½æ•¸
    function resetSolver() {
        if (solver && solver.reset) {
            solver.reset();
        }
        chart.data = { labels: [], datasets: [] };
        chart.update();
        updateSolverStatus('ğŸ’» ç©©å®š CPU æ±‚è§£å™¨å°±ç·’', 'stable');
        log('æ±‚è§£å™¨å·²é‡ç½®', 'success');
    }

    // å•Ÿå‹•æ‡‰ç”¨
    await initializeStableSolver();
    document.getElementById('runBtn').addEventListener('click', runStableSimulation);
    document.getElementById('resetBtn').addEventListener('click', resetSolver);
});
</script>

</body>
</html>