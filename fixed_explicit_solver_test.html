<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>ä¿®å¾©å¾ŒExplicitStateSolveræ¸¬è©¦</title>
  <style>
    body {
      font-family: Arial;
      padding: 20px;
      background: #2c3e50;
      color: white;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 10px;
    }

    .metrics {
      display: flex;
      gap: 15px;
      margin: 20px 0;
      flex-wrap: wrap;
    }

    .metric {
      background: rgba(255, 255, 255, 0.1);
      padding: 12px;
      border-radius: 6px;
      text-align: center;
      flex: 1;
      min-width: 120px;
    }

    .metric-label {
      font-size: 11px;
      opacity: 0.8;
      margin-bottom: 4px;
    }

    .metric-value {
      font-size: 18px;
      font-weight: bold;
      color: #27ae60;
    }

    #log {
      height: 400px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.4);
      padding: 15px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      margin-top: 20px;
    }

    .success {
      color: #27ae60;
    }

    .error {
      color: #e74c3c;
    }

    .warning {
      color: #f39c12;
    }

    .info {
      color: #3498db;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>ğŸ”§ ä¿®å¾©å¾ŒExplicitStateSolveræ¸¬è©¦</h1>
    <p>âš¡ æ¸¬è©¦ä¿®å¾©å¾Œçš„ExplicitStateSolver - åŒ…å«å¼·åŒ–ç·šæ€§æ±‚è§£å™¨</p>

    <div class="metrics">
      <div class="metric">
        <div class="metric-label">æ±‚è§£å™¨ç‹€æ…‹</div>
        <div id="status" class="metric-value">æ¸¬è©¦ä¸­</div>
      </div>
      <div class="metric">
        <div class="metric-label">ç·šæ€§æ±‚è§£å™¨</div>
        <div id="solver" class="metric-value">æœªçŸ¥</div>
      </div>
      <div class="metric">
        <div class="metric-label">æ”¶æ–‚æ­¥æ•¸</div>
        <div id="iterations" class="metric-value">0</div>
      </div>
      <div class="metric">
        <div class="metric-label">è¼¸å‡ºé›»å£“</div>
        <div id="vout" class="metric-value">0V</div>
      </div>
      <div class="metric">
        <div class="metric-label">è¼¸å‡ºé›»æµ</div>
        <div id="iout" class="metric-value">0A</div>
      </div>
      <div class="metric">
        <div class="metric-label">åŠŸç‡</div>
        <div id="power" class="metric-value">0W</div>
      </div>
    </div>

    <h3>ğŸ“‹ ExplicitStateSolverä¿®å¾©æ¸¬è©¦æ—¥èªŒ</h3>
    <div id="log">æº–å‚™æ¸¬è©¦ä¿®å¾©å¾Œçš„ExplicitStateSolver...<br></div>
  </div>

  <script src="./lib-dist/AkingSPICE.umd.js"></script>

  <script>
    function log(message, type = 'info') {
      const colors = {
        'success': '#27ae60',
        'error': '#e74c3c',
        'warning': '#f39c12',
        'info': '#3498db'
      };

      const time = new Date().toLocaleTimeString();
      const logElement = document.getElementById('log');
      logElement.innerHTML += `<span style="color: ${colors[type]};">[${time}] ${message}</span><br>`;
      logElement.scrollTop = logElement.scrollHeight;
    }

    function updateMetrics(status, solver, iterations, vout, iout, power) {
      document.getElementById('status').textContent = status;
      document.getElementById('solver').textContent = solver;
      document.getElementById('iterations').textContent = iterations;
      document.getElementById('vout').textContent = vout.toFixed(3) + 'V';
      document.getElementById('iout').textContent = iout.toFixed(3) + 'A';
      document.getElementById('power').textContent = power.toFixed(3) + 'W';
    }

    // ç«‹å³åŸ·è¡Œæ¸¬è©¦
    document.addEventListener('DOMContentLoaded', function () {
      log('ğŸ”§ é–‹å§‹æ¸¬è©¦ä¿®å¾©å¾Œçš„ExplicitStateSolver', 'success');

      if (!window.AkingSPICE) {
        log('âŒ AkingSPICEæœªè¼‰å…¥', 'error');
        updateMetrics('éŒ¯èª¤', 'ç„¡', 0, 0, 0, 0);
        return;
      }

      log('âœ… AkingSPICEè¼‰å…¥æˆåŠŸ', 'success');

      const { VoltageSource, Resistor, Capacitor, Inductor, ExplicitStateSolver } = window.AkingSPICE;

      // æ¸¬è©¦1: åŸºæœ¬é›»è·¯ - æ‡‰è©²ä½¿ç”¨é›…å¯æ¯”æ³•
      try {
        log('ğŸ§ª æ¸¬è©¦1: åŸºæœ¬é›»é˜»é›»è·¯ (é›…å¯æ¯”æ³•)', 'info');

        const basicComponents = [
          new VoltageSource('V1', [1, 0], 12.0),
          new Resistor('R1', [1, 0], 100.0)
        ];

        const solver1 = new ExplicitStateSolver();
        solver1.initialize(basicComponents, 1e-3, {
          debug: true,
          maxIterations: 30,
          tolerance: 1e-3
        });

        const result1 = solver1.step();
        const v1 = result1.nodeVoltages[1] || 0;
        const i1 = v1 / 100.0;
        const p1 = v1 * i1;

        updateMetrics('åŸºæœ¬é›»è·¯é€šé', 'é›…å¯æ¯”æ³•', 1, v1, i1, p1);
        log(`âœ… åŸºæœ¬é›»è·¯æ¸¬è©¦é€šé: V=${v1.toFixed(3)}V, I=${i1.toFixed(3)}A, P=${p1.toFixed(3)}W`, 'success');

      } catch (error1) {
        log(`âŒ åŸºæœ¬é›»è·¯æ¸¬è©¦å¤±æ•—: ${error1.message}`, 'error');
        updateMetrics('åŸºæœ¬é›»è·¯å¤±æ•—', 'éŒ¯èª¤', 0, 0, 0, 0);
      }

      // æ¸¬è©¦2: è¤‡é›œé›»è·¯ - å¯èƒ½éœ€è¦é«˜æ–¯-å¡å¾·çˆ¾æ³•æˆ–ç›´æ¥æ±‚è§£
      try {
        log('ğŸ§ª æ¸¬è©¦2: å¤šé›»é˜»ä¸²è¯é›»è·¯ (é«˜æ–¯-å¡å¾·çˆ¾æ³•)', 'info');

        const multiComponents = [
          new VoltageSource('V1', [1, 0], 24.0),
          new Resistor('R1', [1, 2], 10.0),
          new Resistor('R2', [2, 3], 20.0),
          new Resistor('R3', [3, 0], 30.0)
        ];

        const solver2 = new ExplicitStateSolver();
        solver2.initialize(multiComponents, 1e-3, {
          debug: true,
          maxIterations: 50,
          tolerance: 1e-3
        });

        const result2 = solver2.step();
        const v3 = result2.nodeVoltages[3] || 0;
        const i2 = v3 / 30.0;  // é€šéR3çš„é›»æµ
        const p2 = v3 * i2;

        updateMetrics('è¤‡é›œé›»è·¯é€šé', 'é«˜æ–¯-å¡å¾·çˆ¾', 2, v3, i2, p2);
        log(`âœ… å¤šé›»é˜»é›»è·¯æ¸¬è©¦é€šé: V3=${v3.toFixed(3)}V, I=${i2.toFixed(3)}A, P=${p2.toFixed(3)}W`, 'success');

      } catch (error2) {
        log(`âŒ å¤šé›»é˜»é›»è·¯æ¸¬è©¦å¤±æ•—: ${error2.message}`, 'error');
        updateMetrics('è¤‡é›œé›»è·¯å¤±æ•—', 'éŒ¯èª¤', 0, 0, 0, 0);
      }

      // æ¸¬è©¦3: LLCé›»è·¯ - å¯èƒ½éœ€è¦ç›´æ¥æ±‚è§£å™¨
      try {
        log('ğŸ§ª æ¸¬è©¦3: LLCè«§æŒ¯é›»è·¯ (å¯èƒ½éœ€è¦ç›´æ¥æ±‚è§£)', 'info');

        const llcComponents = [
          new VoltageSource('Vin', [1, 0], 24.0),       // 24Vè¼¸å…¥
          new Inductor('Lr', [1, 2], 5e-3),            // 5mH è«§æŒ¯é›»æ„Ÿ
          new Capacitor('Cr', [2, 3], 2e-6),           // 2Î¼F è«§æŒ¯é›»å®¹
          new Resistor('Rload', [3, 0], 50.0)          // 50Î© è² è¼‰
        ];

        const solver3 = new ExplicitStateSolver();

        // ä½¿ç”¨æ›´ä¿å®ˆçš„åƒæ•¸
        solver3.initialize(llcComponents, 2e-4, {      // 200Î¼s æ™‚é–“æ­¥é•·
          debug: true,
          maxIterations: 100,
          tolerance: 1e-2,                             // 1% å®¹å·®
          solverMaxIterations: 200,                    // ç·šæ€§æ±‚è§£å™¨è¿­ä»£æ¬¡æ•¸
          solverTolerance: 1e-3                       // ç·šæ€§æ±‚è§£å™¨å®¹å·®
        });

        log('âœ… LLCæ±‚è§£å™¨åˆå§‹åŒ–æˆåŠŸ', 'success');

        // åŸ·è¡Œå¤šæ­¥æ¨¡æ“¬
        let maxV3 = 0;
        let finalI = 0;
        let finalP = 0;

        for (let step = 0; step < 10; step++) {
          const result = solver3.step();
          const v3 = Math.abs(result.nodeVoltages[3] || 0);

          if (v3 > maxV3) {
            maxV3 = v3;
            finalI = v3 / 50.0;
            finalP = v3 * finalI;
          }

          if (step % 3 === 0) {
            log(`LLCæ­¥é©Ÿ ${step + 1}: V3=${v3.toFixed(3)}V`, 'info');
          }
        }

        updateMetrics('LLCé€šé', 'ç›´æ¥æ±‚è§£', 10, maxV3, finalI, finalP);

        // è¨ˆç®—ç†è«–è«§æŒ¯é »ç‡
        const fr = 1 / (2 * Math.PI * Math.sqrt(5e-3 * 2e-6));

        log(`âœ… LLCé›»è·¯æ¸¬è©¦æˆåŠŸï¼`, 'success');
        log(`ğŸ“Š LLCçµæœ:`, 'success');
        log(`  æœ€å¤§è¼¸å‡ºé›»å£“: ${maxV3.toFixed(3)}V`, 'success');
        log(`  è¼¸å‡ºé›»æµ: ${finalI.toFixed(3)}A`, 'success');
        log(`  è¼¸å‡ºåŠŸç‡: ${finalP.toFixed(3)}W`, 'success');
        log(`  ç†è«–è«§æŒ¯é »ç‡: ${(fr / 1000).toFixed(1)}kHz`, 'success');

      } catch (error3) {
        log(`âŒ LLCé›»è·¯æ¸¬è©¦å¤±æ•—: ${error3.message}`, 'error');
        updateMetrics('LLCå¤±æ•—', 'éŒ¯èª¤', 0, 0, 0, 0);

        // å¦‚æœLLCå¤±æ•—ï¼Œå˜—è©¦æ›´ç°¡å–®çš„ç‰ˆæœ¬
        try {
          log('ğŸ”§ å˜—è©¦ç°¡åŒ–çš„LLCé›»è·¯...', 'warning');

          const simpleLLC = [
            new VoltageSource('Vin', [1, 0], 12.0),
            new Inductor('L1', [1, 2], 10e-3),         // 10mH
            new Resistor('R1', [2, 0], 100.0)          // 100Î©
          ];

          const simplesolver = new ExplicitStateSolver();
          simpleolver.initialize(simpleLLC, 1e-3, {
            debug: true,
            maxIterations: 30,
            tolerance: 1e-2
          });

          const simpleResult = simpleolver.step();
          const v2 = simpleResult.nodeVoltages[2] || 0;
          const i_simple = v2 / 100.0;
          const p_simple = v2 * i_simple;

          updateMetrics('ç°¡åŒ–LLCé€šé', 'ä¿®å¾©ç‰ˆ', 1, v2, i_simple, p_simple);
          log(`âœ… ç°¡åŒ–LLCæˆåŠŸ: V=${v2.toFixed(3)}V, I=${i_simple.toFixed(3)}A`, 'success');

        } catch (simpleError) {
          log(`âŒ ç°¡åŒ–LLCä¹Ÿå¤±æ•—: ${simpleError.message}`, 'error');
        }
      }

      log('ğŸ‰ ExplicitStateSolverä¿®å¾©æ¸¬è©¦å®Œæˆï¼', 'success');
    });

  </script>
</body>

</html>