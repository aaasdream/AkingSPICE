<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>修復後ExplicitStateSolver測試</title>
  <style>
    body {
      font-family: Arial;
      padding: 20px;
      background: #2c3e50;
      color: white;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 10px;
    }

    .metrics {
      display: flex;
      gap: 15px;
      margin: 20px 0;
      flex-wrap: wrap;
    }

    .metric {
      background: rgba(255, 255, 255, 0.1);
      padding: 12px;
      border-radius: 6px;
      text-align: center;
      flex: 1;
      min-width: 120px;
    }

    .metric-label {
      font-size: 11px;
      opacity: 0.8;
      margin-bottom: 4px;
    }

    .metric-value {
      font-size: 18px;
      font-weight: bold;
      color: #27ae60;
    }

    #log {
      height: 400px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.4);
      padding: 15px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      margin-top: 20px;
    }

    .success {
      color: #27ae60;
    }

    .error {
      color: #e74c3c;
    }

    .warning {
      color: #f39c12;
    }

    .info {
      color: #3498db;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>🔧 修復後ExplicitStateSolver測試</h1>
    <p>⚡ 測試修復後的ExplicitStateSolver - 包含強化線性求解器</p>

    <div class="metrics">
      <div class="metric">
        <div class="metric-label">求解器狀態</div>
        <div id="status" class="metric-value">測試中</div>
      </div>
      <div class="metric">
        <div class="metric-label">線性求解器</div>
        <div id="solver" class="metric-value">未知</div>
      </div>
      <div class="metric">
        <div class="metric-label">收斂步數</div>
        <div id="iterations" class="metric-value">0</div>
      </div>
      <div class="metric">
        <div class="metric-label">輸出電壓</div>
        <div id="vout" class="metric-value">0V</div>
      </div>
      <div class="metric">
        <div class="metric-label">輸出電流</div>
        <div id="iout" class="metric-value">0A</div>
      </div>
      <div class="metric">
        <div class="metric-label">功率</div>
        <div id="power" class="metric-value">0W</div>
      </div>
    </div>

    <h3>📋 ExplicitStateSolver修復測試日誌</h3>
    <div id="log">準備測試修復後的ExplicitStateSolver...<br></div>
  </div>

  <script src="./lib-dist/AkingSPICE.umd.js"></script>

  <script>
    function log(message, type = 'info') {
      const colors = {
        'success': '#27ae60',
        'error': '#e74c3c',
        'warning': '#f39c12',
        'info': '#3498db'
      };

      const time = new Date().toLocaleTimeString();
      const logElement = document.getElementById('log');
      logElement.innerHTML += `<span style="color: ${colors[type]};">[${time}] ${message}</span><br>`;
      logElement.scrollTop = logElement.scrollHeight;
    }

    function updateMetrics(status, solver, iterations, vout, iout, power) {
      document.getElementById('status').textContent = status;
      document.getElementById('solver').textContent = solver;
      document.getElementById('iterations').textContent = iterations;
      document.getElementById('vout').textContent = vout.toFixed(3) + 'V';
      document.getElementById('iout').textContent = iout.toFixed(3) + 'A';
      document.getElementById('power').textContent = power.toFixed(3) + 'W';
    }

    // 立即執行測試
    document.addEventListener('DOMContentLoaded', function () {
      log('🔧 開始測試修復後的ExplicitStateSolver', 'success');

      if (!window.AkingSPICE) {
        log('❌ AkingSPICE未載入', 'error');
        updateMetrics('錯誤', '無', 0, 0, 0, 0);
        return;
      }

      log('✅ AkingSPICE載入成功', 'success');

      const { VoltageSource, Resistor, Capacitor, Inductor, ExplicitStateSolver } = window.AkingSPICE;

      // 測試1: 基本電路 - 應該使用雅可比法
      try {
        log('🧪 測試1: 基本電阻電路 (雅可比法)', 'info');

        const basicComponents = [
          new VoltageSource('V1', [1, 0], 12.0),
          new Resistor('R1', [1, 0], 100.0)
        ];

        const solver1 = new ExplicitStateSolver();
        solver1.initialize(basicComponents, 1e-3, {
          debug: true,
          maxIterations: 30,
          tolerance: 1e-3
        });

        const result1 = solver1.step();
        const v1 = result1.nodeVoltages[1] || 0;
        const i1 = v1 / 100.0;
        const p1 = v1 * i1;

        updateMetrics('基本電路通過', '雅可比法', 1, v1, i1, p1);
        log(`✅ 基本電路測試通過: V=${v1.toFixed(3)}V, I=${i1.toFixed(3)}A, P=${p1.toFixed(3)}W`, 'success');

      } catch (error1) {
        log(`❌ 基本電路測試失敗: ${error1.message}`, 'error');
        updateMetrics('基本電路失敗', '錯誤', 0, 0, 0, 0);
      }

      // 測試2: 複雜電路 - 可能需要高斯-塞德爾法或直接求解
      try {
        log('🧪 測試2: 多電阻串聯電路 (高斯-塞德爾法)', 'info');

        const multiComponents = [
          new VoltageSource('V1', [1, 0], 24.0),
          new Resistor('R1', [1, 2], 10.0),
          new Resistor('R2', [2, 3], 20.0),
          new Resistor('R3', [3, 0], 30.0)
        ];

        const solver2 = new ExplicitStateSolver();
        solver2.initialize(multiComponents, 1e-3, {
          debug: true,
          maxIterations: 50,
          tolerance: 1e-3
        });

        const result2 = solver2.step();
        const v3 = result2.nodeVoltages[3] || 0;
        const i2 = v3 / 30.0;  // 通過R3的電流
        const p2 = v3 * i2;

        updateMetrics('複雜電路通過', '高斯-塞德爾', 2, v3, i2, p2);
        log(`✅ 多電阻電路測試通過: V3=${v3.toFixed(3)}V, I=${i2.toFixed(3)}A, P=${p2.toFixed(3)}W`, 'success');

      } catch (error2) {
        log(`❌ 多電阻電路測試失敗: ${error2.message}`, 'error');
        updateMetrics('複雜電路失敗', '錯誤', 0, 0, 0, 0);
      }

      // 測試3: LLC電路 - 可能需要直接求解器
      try {
        log('🧪 測試3: LLC諧振電路 (可能需要直接求解)', 'info');

        const llcComponents = [
          new VoltageSource('Vin', [1, 0], 24.0),       // 24V輸入
          new Inductor('Lr', [1, 2], 5e-3),            // 5mH 諧振電感
          new Capacitor('Cr', [2, 3], 2e-6),           // 2μF 諧振電容
          new Resistor('Rload', [3, 0], 50.0)          // 50Ω 負載
        ];

        const solver3 = new ExplicitStateSolver();

        // 使用更保守的參數
        solver3.initialize(llcComponents, 2e-4, {      // 200μs 時間步長
          debug: true,
          maxIterations: 100,
          tolerance: 1e-2,                             // 1% 容差
          solverMaxIterations: 200,                    // 線性求解器迭代次數
          solverTolerance: 1e-3                       // 線性求解器容差
        });

        log('✅ LLC求解器初始化成功', 'success');

        // 執行多步模擬
        let maxV3 = 0;
        let finalI = 0;
        let finalP = 0;

        for (let step = 0; step < 10; step++) {
          const result = solver3.step();
          const v3 = Math.abs(result.nodeVoltages[3] || 0);

          if (v3 > maxV3) {
            maxV3 = v3;
            finalI = v3 / 50.0;
            finalP = v3 * finalI;
          }

          if (step % 3 === 0) {
            log(`LLC步驟 ${step + 1}: V3=${v3.toFixed(3)}V`, 'info');
          }
        }

        updateMetrics('LLC通過', '直接求解', 10, maxV3, finalI, finalP);

        // 計算理論諧振頻率
        const fr = 1 / (2 * Math.PI * Math.sqrt(5e-3 * 2e-6));

        log(`✅ LLC電路測試成功！`, 'success');
        log(`📊 LLC結果:`, 'success');
        log(`  最大輸出電壓: ${maxV3.toFixed(3)}V`, 'success');
        log(`  輸出電流: ${finalI.toFixed(3)}A`, 'success');
        log(`  輸出功率: ${finalP.toFixed(3)}W`, 'success');
        log(`  理論諧振頻率: ${(fr / 1000).toFixed(1)}kHz`, 'success');

      } catch (error3) {
        log(`❌ LLC電路測試失敗: ${error3.message}`, 'error');
        updateMetrics('LLC失敗', '錯誤', 0, 0, 0, 0);

        // 如果LLC失敗，嘗試更簡單的版本
        try {
          log('🔧 嘗試簡化的LLC電路...', 'warning');

          const simpleLLC = [
            new VoltageSource('Vin', [1, 0], 12.0),
            new Inductor('L1', [1, 2], 10e-3),         // 10mH
            new Resistor('R1', [2, 0], 100.0)          // 100Ω
          ];

          const simplesolver = new ExplicitStateSolver();
          simpleolver.initialize(simpleLLC, 1e-3, {
            debug: true,
            maxIterations: 30,
            tolerance: 1e-2
          });

          const simpleResult = simpleolver.step();
          const v2 = simpleResult.nodeVoltages[2] || 0;
          const i_simple = v2 / 100.0;
          const p_simple = v2 * i_simple;

          updateMetrics('簡化LLC通過', '修復版', 1, v2, i_simple, p_simple);
          log(`✅ 簡化LLC成功: V=${v2.toFixed(3)}V, I=${i_simple.toFixed(3)}A`, 'success');

        } catch (simpleError) {
          log(`❌ 簡化LLC也失敗: ${simpleError.message}`, 'error');
        }
      }

      log('🎉 ExplicitStateSolver修復測試完成！', 'success');
    });

  </script>
</body>

</html>