<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU vs CPU 簡單運算對比測試</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            line-height: 1.4;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #444;
        }
        
        .output {
            background: #000;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            max-height: 600px;
            overflow-y: auto;
            font-size: 12px;
            white-space: pre-line;
        }
        
        button {
            background: #444;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
        }
        
        button:hover {
            background: #00ff00;
            color: #000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🧮 GPU vs CPU 簡單運算對比測試</h1>
        <p>測試基本的矩陣運算，找出 GPU 求解器的問題所在</p>
        
        <div>
            <button onclick="testBasicOperations()">🔢 測試基本運算</button>
            <button onclick="testMatrixOperations()">📊 測試矩陣運算</button>
            <button onclick="testSimpleLinearSystem()">⚡ 測試簡單線性系統</button>
            <button onclick="clearOutput()">🗑️ 清除輸出</button>
        </div>
        
        <div class="output" id="output"></div>
    </div>

    <script type="module">
        import { 
            ExplicitStateSolver,
            GPUExplicitStateSolver,
            VoltageSource, 
            Resistor, 
            Capacitor, 
            Inductor 
        } from './lib-dist/AkingSPICE.es.js';
        
        window.ExplicitStateSolver = ExplicitStateSolver;
        window.GPUExplicitStateSolver = GPUExplicitStateSolver;
        window.VoltageSource = VoltageSource;
        window.Resistor = Resistor;
        window.Capacitor = Capacitor;
        window.Inductor = Inductor;
        
        console.log('✅ AkingSPICE 庫載入完成');
    </script>

    <script>
        function log(message) {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            output.textContent += `[${timestamp}] ${message}\n`;
            output.scrollTop = output.scrollHeight;
        }
        
        function clearOutput() {
            document.getElementById('output').textContent = '';
        }
        
        // 測試基本運算
        async function testBasicOperations() {
            log('🔢 開始基本運算測試');
            log('='.repeat(50));
            
            // 測試數據
            const testArray = [1.0, 2.0, 3.0, 4.0];
            
            // CPU 計算
            log('📱 CPU 計算:');
            const cpuResult = testArray.map(x => x * 2.5 + 1.0);
            log(`輸入: [${testArray.join(', ')}]`);
            log(`CPU 結果: [${cpuResult.join(', ')}]`);
            
            // GPU 計算 (如果有 WebGPU)
            if (navigator.gpu) {
                log('🖥️ GPU 計算:');
                try {
                    const gpuResult = await testGPUBasicOperation(testArray);
                    log(`GPU 結果: [${gpuResult.join(', ')}]`);
                    
                    // 對比
                    const maxError = Math.max(...cpuResult.map((cpu, i) => Math.abs(cpu - gpuResult[i])));
                    log(`最大誤差: ${maxError.toFixed(8)}`);
                    
                    if (maxError < 1e-6) {
                        log('✅ GPU 和 CPU 計算結果一致');
                    } else {
                        log('❌ GPU 和 CPU 計算結果不一致');
                    }
                } catch (error) {
                    log(`❌ GPU 計算失敗: ${error.message}`);
                }
            } else {
                log('⚠️ WebGPU 不可用');
            }
        }
        
        // GPU 基本運算測試
        async function testGPUBasicOperation(inputArray) {
            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            
            // 創建輸入緩衝區
            const inputBuffer = device.createBuffer({
                size: inputArray.length * 4,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            
            // 創建輸出緩衝區
            const outputBuffer = device.createBuffer({
                size: inputArray.length * 4,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
            });
            
            // 上傳數據
            device.queue.writeBuffer(inputBuffer, 0, new Float32Array(inputArray));
            
            // 簡單的計算著色器
            const shaderCode = `
                @group(0) @binding(0) var<storage, read> input: array<f32>;
                @group(0) @binding(1) var<storage, read_write> output: array<f32>;
                
                @compute @workgroup_size(1)
                fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                    let index = global_id.x;
                    if (index >= arrayLength(&input)) {
                        return;
                    }
                    output[index] = input[index] * 2.5 + 1.0;
                }
            `;
            
            const shaderModule = device.createShaderModule({ code: shaderCode });
            const computePipeline = device.createComputePipeline({
                layout: 'auto',
                compute: { module: shaderModule, entryPoint: 'main' }
            });
            
            // 創建綁定組
            const bindGroup = device.createBindGroup({
                layout: computePipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: inputBuffer } },
                    { binding: 1, resource: { buffer: outputBuffer } }
                ]
            });
            
            // 執行計算
            const commandEncoder = device.createCommandEncoder();
            const computePass = commandEncoder.beginComputePass();
            computePass.setPipeline(computePipeline);
            computePass.setBindGroup(0, bindGroup);
            computePass.dispatchWorkgroups(inputArray.length);
            computePass.end();
            
            // 讀取結果
            const readBuffer = device.createBuffer({
                size: inputArray.length * 4,
                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
            });
            
            commandEncoder.copyBufferToBuffer(outputBuffer, 0, readBuffer, 0, inputArray.length * 4);
            device.queue.submit([commandEncoder.finish()]);
            
            await readBuffer.mapAsync(GPUMapMode.READ);
            const result = new Float32Array(readBuffer.getMappedRange());
            const resultArray = Array.from(result);
            readBuffer.unmap();
            
            return resultArray;
        }
        
        // 測試矩陣運算
        async function testMatrixOperations() {
            log('📊 開始矩陣運算測試');
            log('='.repeat(50));
            
            // 簡單 2x2 矩陣
            const matrix = [
                [2.0, 1.0],
                [1.0, 3.0]
            ];
            const vector = [5.0, 7.0];
            
            log('測試矩陣乘法: A * v');
            log(`矩陣 A:`);
            log(`  [${matrix[0].join(', ')}]`);
            log(`  [${matrix[1].join(', ')}]`);
            log(`向量 v: [${vector.join(', ')}]`);
            
            // CPU 計算
            const cpuResult = [
                matrix[0][0] * vector[0] + matrix[0][1] * vector[1],
                matrix[1][0] * vector[0] + matrix[1][1] * vector[1]
            ];
            log(`CPU 結果: [${cpuResult.join(', ')}]`);
            
            // TODO: 添加 GPU 矩陣乘法測試
        }
        
        // 測試簡單線性系統
        async function testSimpleLinearSystem() {
            log('⚡ 開始簡單線性系統測試');
            log('='.repeat(50));
            
            // 簡單的 2x2 系統: [2 1; 1 3] * [x; y] = [5; 7]
            // 解應該是 x=1, y=3
            
            log('測試線性系統 A*x = b:');
            log('A = [2 1; 1 3]');
            log('b = [5; 7]');
            log('預期解: x = [1, 3]');
            
            try {
                // 創建簡單的測試電路來對比
                const components = [
                    new VoltageSource('V1', ['n1', 'gnd'], 5.0),
                    new Resistor('R1', ['n1', 'n2'], 2.0),
                    new Resistor('R2', ['n2', 'gnd'], 3.0)
                ];
                
                // CPU 求解器
                log('🖥️ CPU 求解器測試...');
                const cpuSolver = new ExplicitStateSolver();
                await cpuSolver.initialize(components, 1e-6);
                
                log('CPU 電路數據:');
                log(`  節點數: ${cpuSolver.circuitData.nodeCount}`);
                log(`  節點名稱: ${cpuSolver.circuitData.nodeNames}`);
                log(`  狀態數: ${cpuSolver.circuitData.stateCount}`);
                
                const cpuStep = cpuSolver.step();
                log(`CPU 節點電壓: ${JSON.stringify(cpuStep.nodeVoltages)}`);
                
                // GPU 求解器
                log('🎮 GPU 求解器測試...');
                const gpuSolver = new GPUExplicitStateSolver({ debug: true });
                await gpuSolver.initialize(components, 1e-6);
                
                log('GPU 電路數據:');
                log(`  節點數: ${gpuSolver.circuitData.nodeCount}`);
                log(`  節點名稱: ${gpuSolver.circuitData.nodeNames}`);
                log(`  狀態數: ${gpuSolver.circuitData.stateCount}`);
                
                const gpuStep = await gpuSolver.step();
                log(`GPU 節點電壓: ${JSON.stringify(gpuStep.nodeVoltages)}`);
                
                // 檢查 GPU RHS 向量
                if (gpuSolver.webgpuSolver && gpuSolver.webgpuSolver.debug) {
                    log('GPU WebGPU 內部狀態已啟用調試模式');
                }
                
                // 對比結果
                log('🔍 結果對比:');
                for (const [node, cpuVoltage] of Object.entries(cpuStep.nodeVoltages)) {
                    const gpuVoltage = gpuStep.nodeVoltages[node];
                    if (gpuVoltage !== undefined) {
                        const error = Math.abs(cpuVoltage - gpuVoltage);
                        log(`節點 ${node}: CPU=${cpuVoltage.toFixed(6)}V, GPU=${gpuVoltage.toFixed(6)}V, 誤差=${error.toFixed(8)}V`);
                        
                        if (error < 1e-5) {
                            log(`  ✅ 節點 ${node} 結果一致`);
                        } else {
                            log(`  ❌ 節點 ${node} 結果不一致`);
                        }
                    } else {
                        log(`❌ 節點 ${node}: CPU=${cpuVoltage.toFixed(6)}V, GPU=未定義`);
                    }
                }
                
                // 檢查GPU是否有額外節點
                for (const [node, gpuVoltage] of Object.entries(gpuStep.nodeVoltages)) {
                    if (cpuStep.nodeVoltages[node] === undefined) {
                        log(`⚠️ GPU額外節點 ${node}: ${gpuVoltage.toFixed(6)}V`);
                    }
                }
                
            } catch (error) {
                log(`❌ 線性系統測試失敗: ${error.message}`);
                console.error(error);
            }
        }
    </script>
</body>
</html>