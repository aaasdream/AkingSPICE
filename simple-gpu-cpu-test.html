<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU vs CPU ç°¡å–®é‹ç®—å°æ¯”æ¸¬è©¦</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            line-height: 1.4;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #444;
        }
        
        .output {
            background: #000;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            max-height: 600px;
            overflow-y: auto;
            font-size: 12px;
            white-space: pre-line;
        }
        
        button {
            background: #444;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
        }
        
        button:hover {
            background: #00ff00;
            color: #000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ§® GPU vs CPU ç°¡å–®é‹ç®—å°æ¯”æ¸¬è©¦</h1>
        <p>æ¸¬è©¦åŸºæœ¬çš„çŸ©é™£é‹ç®—ï¼Œæ‰¾å‡º GPU æ±‚è§£å™¨çš„å•é¡Œæ‰€åœ¨</p>
        
        <div>
            <button onclick="testBasicOperations()">ğŸ”¢ æ¸¬è©¦åŸºæœ¬é‹ç®—</button>
            <button onclick="testMatrixOperations()">ğŸ“Š æ¸¬è©¦çŸ©é™£é‹ç®—</button>
            <button onclick="testSimpleLinearSystem()">âš¡ æ¸¬è©¦ç°¡å–®ç·šæ€§ç³»çµ±</button>
            <button onclick="clearOutput()">ğŸ—‘ï¸ æ¸…é™¤è¼¸å‡º</button>
        </div>
        
        <div class="output" id="output"></div>
    </div>

    <script type="module">
        import { 
            ExplicitStateSolver,
            GPUExplicitStateSolver,
            VoltageSource, 
            Resistor, 
            Capacitor, 
            Inductor 
        } from './lib-dist/AkingSPICE.es.js';
        
        window.ExplicitStateSolver = ExplicitStateSolver;
        window.GPUExplicitStateSolver = GPUExplicitStateSolver;
        window.VoltageSource = VoltageSource;
        window.Resistor = Resistor;
        window.Capacitor = Capacitor;
        window.Inductor = Inductor;
        
        console.log('âœ… AkingSPICE åº«è¼‰å…¥å®Œæˆ');
    </script>

    <script>
        function log(message) {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            output.textContent += `[${timestamp}] ${message}\n`;
            output.scrollTop = output.scrollHeight;
        }
        
        function clearOutput() {
            document.getElementById('output').textContent = '';
        }
        
        // æ¸¬è©¦åŸºæœ¬é‹ç®—
        async function testBasicOperations() {
            log('ğŸ”¢ é–‹å§‹åŸºæœ¬é‹ç®—æ¸¬è©¦');
            log('='.repeat(50));
            
            // æ¸¬è©¦æ•¸æ“š
            const testArray = [1.0, 2.0, 3.0, 4.0];
            
            // CPU è¨ˆç®—
            log('ğŸ“± CPU è¨ˆç®—:');
            const cpuResult = testArray.map(x => x * 2.5 + 1.0);
            log(`è¼¸å…¥: [${testArray.join(', ')}]`);
            log(`CPU çµæœ: [${cpuResult.join(', ')}]`);
            
            // GPU è¨ˆç®— (å¦‚æœæœ‰ WebGPU)
            if (navigator.gpu) {
                log('ğŸ–¥ï¸ GPU è¨ˆç®—:');
                try {
                    const gpuResult = await testGPUBasicOperation(testArray);
                    log(`GPU çµæœ: [${gpuResult.join(', ')}]`);
                    
                    // å°æ¯”
                    const maxError = Math.max(...cpuResult.map((cpu, i) => Math.abs(cpu - gpuResult[i])));
                    log(`æœ€å¤§èª¤å·®: ${maxError.toFixed(8)}`);
                    
                    if (maxError < 1e-6) {
                        log('âœ… GPU å’Œ CPU è¨ˆç®—çµæœä¸€è‡´');
                    } else {
                        log('âŒ GPU å’Œ CPU è¨ˆç®—çµæœä¸ä¸€è‡´');
                    }
                } catch (error) {
                    log(`âŒ GPU è¨ˆç®—å¤±æ•—: ${error.message}`);
                }
            } else {
                log('âš ï¸ WebGPU ä¸å¯ç”¨');
            }
        }
        
        // GPU åŸºæœ¬é‹ç®—æ¸¬è©¦
        async function testGPUBasicOperation(inputArray) {
            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();
            
            // å‰µå»ºè¼¸å…¥ç·©è¡å€
            const inputBuffer = device.createBuffer({
                size: inputArray.length * 4,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            
            // å‰µå»ºè¼¸å‡ºç·©è¡å€
            const outputBuffer = device.createBuffer({
                size: inputArray.length * 4,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
            });
            
            // ä¸Šå‚³æ•¸æ“š
            device.queue.writeBuffer(inputBuffer, 0, new Float32Array(inputArray));
            
            // ç°¡å–®çš„è¨ˆç®—è‘—è‰²å™¨
            const shaderCode = `
                @group(0) @binding(0) var<storage, read> input: array<f32>;
                @group(0) @binding(1) var<storage, read_write> output: array<f32>;
                
                @compute @workgroup_size(1)
                fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                    let index = global_id.x;
                    if (index >= arrayLength(&input)) {
                        return;
                    }
                    output[index] = input[index] * 2.5 + 1.0;
                }
            `;
            
            const shaderModule = device.createShaderModule({ code: shaderCode });
            const computePipeline = device.createComputePipeline({
                layout: 'auto',
                compute: { module: shaderModule, entryPoint: 'main' }
            });
            
            // å‰µå»ºç¶å®šçµ„
            const bindGroup = device.createBindGroup({
                layout: computePipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: inputBuffer } },
                    { binding: 1, resource: { buffer: outputBuffer } }
                ]
            });
            
            // åŸ·è¡Œè¨ˆç®—
            const commandEncoder = device.createCommandEncoder();
            const computePass = commandEncoder.beginComputePass();
            computePass.setPipeline(computePipeline);
            computePass.setBindGroup(0, bindGroup);
            computePass.dispatchWorkgroups(inputArray.length);
            computePass.end();
            
            // è®€å–çµæœ
            const readBuffer = device.createBuffer({
                size: inputArray.length * 4,
                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
            });
            
            commandEncoder.copyBufferToBuffer(outputBuffer, 0, readBuffer, 0, inputArray.length * 4);
            device.queue.submit([commandEncoder.finish()]);
            
            await readBuffer.mapAsync(GPUMapMode.READ);
            const result = new Float32Array(readBuffer.getMappedRange());
            const resultArray = Array.from(result);
            readBuffer.unmap();
            
            return resultArray;
        }
        
        // æ¸¬è©¦çŸ©é™£é‹ç®—
        async function testMatrixOperations() {
            log('ğŸ“Š é–‹å§‹çŸ©é™£é‹ç®—æ¸¬è©¦');
            log('='.repeat(50));
            
            // ç°¡å–® 2x2 çŸ©é™£
            const matrix = [
                [2.0, 1.0],
                [1.0, 3.0]
            ];
            const vector = [5.0, 7.0];
            
            log('æ¸¬è©¦çŸ©é™£ä¹˜æ³•: A * v');
            log(`çŸ©é™£ A:`);
            log(`  [${matrix[0].join(', ')}]`);
            log(`  [${matrix[1].join(', ')}]`);
            log(`å‘é‡ v: [${vector.join(', ')}]`);
            
            // CPU è¨ˆç®—
            const cpuResult = [
                matrix[0][0] * vector[0] + matrix[0][1] * vector[1],
                matrix[1][0] * vector[0] + matrix[1][1] * vector[1]
            ];
            log(`CPU çµæœ: [${cpuResult.join(', ')}]`);
            
            // TODO: æ·»åŠ  GPU çŸ©é™£ä¹˜æ³•æ¸¬è©¦
        }
        
        // æ¸¬è©¦ç°¡å–®ç·šæ€§ç³»çµ±
        async function testSimpleLinearSystem() {
            log('âš¡ é–‹å§‹ç°¡å–®ç·šæ€§ç³»çµ±æ¸¬è©¦');
            log('='.repeat(50));
            
            // ç°¡å–®çš„ 2x2 ç³»çµ±: [2 1; 1 3] * [x; y] = [5; 7]
            // è§£æ‡‰è©²æ˜¯ x=1, y=3
            
            log('æ¸¬è©¦ç·šæ€§ç³»çµ± A*x = b:');
            log('A = [2 1; 1 3]');
            log('b = [5; 7]');
            log('é æœŸè§£: x = [1, 3]');
            
            try {
                // å‰µå»ºç°¡å–®çš„æ¸¬è©¦é›»è·¯ä¾†å°æ¯”
                const components = [
                    new VoltageSource('V1', ['n1', 'gnd'], 5.0),
                    new Resistor('R1', ['n1', 'n2'], 2.0),
                    new Resistor('R2', ['n2', 'gnd'], 3.0)
                ];
                
                // CPU æ±‚è§£å™¨
                log('ğŸ–¥ï¸ CPU æ±‚è§£å™¨æ¸¬è©¦...');
                const cpuSolver = new ExplicitStateSolver();
                await cpuSolver.initialize(components, 1e-6);
                
                log('CPU é›»è·¯æ•¸æ“š:');
                log(`  ç¯€é»æ•¸: ${cpuSolver.circuitData.nodeCount}`);
                log(`  ç¯€é»åç¨±: ${cpuSolver.circuitData.nodeNames}`);
                log(`  ç‹€æ…‹æ•¸: ${cpuSolver.circuitData.stateCount}`);
                
                const cpuStep = cpuSolver.step();
                log(`CPU ç¯€é»é›»å£“: ${JSON.stringify(cpuStep.nodeVoltages)}`);
                
                // GPU æ±‚è§£å™¨
                log('ğŸ® GPU æ±‚è§£å™¨æ¸¬è©¦...');
                const gpuSolver = new GPUExplicitStateSolver({ debug: true });
                await gpuSolver.initialize(components, 1e-6);
                
                log('GPU é›»è·¯æ•¸æ“š:');
                log(`  ç¯€é»æ•¸: ${gpuSolver.circuitData.nodeCount}`);
                log(`  ç¯€é»åç¨±: ${gpuSolver.circuitData.nodeNames}`);
                log(`  ç‹€æ…‹æ•¸: ${gpuSolver.circuitData.stateCount}`);
                
                const gpuStep = await gpuSolver.step();
                log(`GPU ç¯€é»é›»å£“: ${JSON.stringify(gpuStep.nodeVoltages)}`);
                
                // æª¢æŸ¥ GPU RHS å‘é‡
                if (gpuSolver.webgpuSolver && gpuSolver.webgpuSolver.debug) {
                    log('GPU WebGPU å…§éƒ¨ç‹€æ…‹å·²å•Ÿç”¨èª¿è©¦æ¨¡å¼');
                }
                
                // å°æ¯”çµæœ
                log('ğŸ” çµæœå°æ¯”:');
                for (const [node, cpuVoltage] of Object.entries(cpuStep.nodeVoltages)) {
                    const gpuVoltage = gpuStep.nodeVoltages[node];
                    if (gpuVoltage !== undefined) {
                        const error = Math.abs(cpuVoltage - gpuVoltage);
                        log(`ç¯€é» ${node}: CPU=${cpuVoltage.toFixed(6)}V, GPU=${gpuVoltage.toFixed(6)}V, èª¤å·®=${error.toFixed(8)}V`);
                        
                        if (error < 1e-5) {
                            log(`  âœ… ç¯€é» ${node} çµæœä¸€è‡´`);
                        } else {
                            log(`  âŒ ç¯€é» ${node} çµæœä¸ä¸€è‡´`);
                        }
                    } else {
                        log(`âŒ ç¯€é» ${node}: CPU=${cpuVoltage.toFixed(6)}V, GPU=æœªå®šç¾©`);
                    }
                }
                
                // æª¢æŸ¥GPUæ˜¯å¦æœ‰é¡å¤–ç¯€é»
                for (const [node, gpuVoltage] of Object.entries(gpuStep.nodeVoltages)) {
                    if (cpuStep.nodeVoltages[node] === undefined) {
                        log(`âš ï¸ GPUé¡å¤–ç¯€é» ${node}: ${gpuVoltage.toFixed(6)}V`);
                    }
                }
                
            } catch (error) {
                log(`âŒ ç·šæ€§ç³»çµ±æ¸¬è©¦å¤±æ•—: ${error.message}`);
                console.error(error);
            }
        }
    </script>
</body>
</html>