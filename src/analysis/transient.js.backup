/**
 * æš«æ…‹åˆ†æ (Transient Analysis) å¯¦ç¾
 * 
 * åŸºæ–¼å¾Œå‘æ­æ‹‰æ³•çš„å›ºå®šæ­¥é•·æ™‚åŸŸåˆ†æç®—æ³•
 * é€™æ˜¯AkingSPICE v0.1çš„æ ¸å¿ƒåˆ†æå¼•æ“
 */

import { Matrix, Vector, LUSolver } from '../core/linalg.js';
import { MNABuilder } from '../core/mna.js';

/**
 * æš«æ…‹åˆ†æçµæœé¡
 * å­˜å„²å’Œç®¡ç†æ™‚åŸŸåˆ†æçš„çµæœæ•¸æ“š
 */
export class TransientResult {
    constructor() {
        this.timeVector = [];
        this.nodeVoltages = new Map(); // nodeName -> voltage array
        this.branchCurrents = new Map(); // branchName -> current array
        this.compone        // è™•ç†æ‰€æœ‰å…ƒä»¶
        for (const component of components) {
            if (component.stampJacobian && component.stampResidual) {
                // éç·šæ€§å…ƒä»¶ï¼šä½¿ç”¨Jacobianå’Œæ®˜å·®stamping
                component.stampJacobian(jacobian, solution, this.mnaBuilder.nodeMap, time);
                component.stampResidual(residual, solution, this.mnaBuilder.nodeMap, time);
            } else {
                // ç·šæ€§å…ƒä»¶ï¼šä½¿ç”¨MNABuilderçš„å°ˆé–€æ–¹æ³•è™•ç†
                if (component.type === 'V') {
                    // é›»å£“æº
                    this.mnaBuilder.stampVoltageSource(component, time, jacobian, residual);
                } else if (component.type === 'I') {
                    // é›»æµæº
                    this.mnaBuilder.stampCurrentSource(component, time, jacobian, residual);
                } else if (component.stamp) {
                    // å…¶ä»–æœ‰stampæ–¹æ³•çš„ç·šæ€§å…ƒä»¶
                    const tempRhs = Vector.zeros(matrixSize);
                    component.stamp(jacobian, tempRhs, this.mnaBuilder.nodeMap, 
                                  this.mnaBuilder.voltageSourceMap, time);
                }
            }
        }; // componentName -> data array
        this.analysisInfo = {};
    }

    /**
     * æ·»åŠ ä¸€å€‹æ™‚é–“é»çš„çµæœ
     * @param {number} time æ™‚é–“é»
     * @param {Map<string, number>} voltages ç¯€é»é›»å£“
     * @param {Map<string, number>} currents æ”¯è·¯é›»æµ
     */
    addTimePoint(time, voltages, currents) {
        this.timeVector.push(time);
        
        // æ·»åŠ ç¯€é»é›»å£“
        for (const [nodeName, voltage] of voltages) {
            if (!this.nodeVoltages.has(nodeName)) {
                this.nodeVoltages.set(nodeName, []);
            }
            this.nodeVoltages.get(nodeName).push(voltage);
        }
        
        // æ·»åŠ æ”¯è·¯é›»æµ
        for (const [branchName, current] of currents) {
            if (!this.branchCurrents.has(branchName)) {
                this.branchCurrents.set(branchName, []);
            }
            this.branchCurrents.get(branchName).push(current);
        }
    }

    /**
     * ç²å–æ™‚é–“å‘é‡
     * @returns {number[]} æ™‚é–“é»é™£åˆ—
     */
    getTimeVector() {
        return [...this.timeVector];
    }

    /**
     * ç²å–ç¯€é»é›»å£“å‘é‡
     * @param {string} nodeName ç¯€é»åç¨± (å¦‚ 'V(1)', '1')
     * @returns {number[]} é›»å£“å€¼é™£åˆ—
     */
    getVoltageVector(nodeName) {
        // è™•ç†SPICEæ ¼å¼çš„ç¯€é»åç¨± V(nodeName)
        let actualNodeName = nodeName;
        const voltageMatch = nodeName.match(/^V\((.+)\)$/);
        if (voltageMatch) {
            actualNodeName = voltageMatch[1];
        }
        
        return this.nodeVoltages.get(actualNodeName) || [];
    }

    /**
     * ç²å–æ”¯è·¯é›»æµå‘é‡
     * @param {string} branchName æ”¯è·¯åç¨± (å¦‚ 'I(V1)', 'V1')
     * @returns {number[]} é›»æµå€¼é™£åˆ—
     */
    getCurrentVector(branchName) {
        // è™•ç†SPICEæ ¼å¼çš„é›»æµåç¨± I(componentName)
        let actualBranchName = branchName;
        const currentMatch = branchName.match(/^I\((.+)\)$/);
        if (currentMatch) {
            actualBranchName = currentMatch[1];
        }
        
        return this.branchCurrents.get(actualBranchName) || [];
    }

    /**
     * ç²å–é€šç”¨å‘é‡ (æ™‚é–“ã€é›»å£“æˆ–é›»æµ)
     * @param {string} vectorName å‘é‡åç¨±
     * @returns {number[]} æ•¸å€¼é™£åˆ—
     */
    getVector(vectorName) {
        if (vectorName.toLowerCase() === 'time') {
            return this.getTimeVector();
        }
        
        // å˜—è©¦ä½œç‚ºé›»å£“ç²å–
        const voltageVector = this.getVoltageVector(vectorName);
        if (voltageVector.length > 0) {
            return voltageVector;
        }
        
        // å˜—è©¦ä½œç‚ºé›»æµç²å–
        const currentVector = this.getCurrentVector(vectorName);
        if (currentVector.length > 0) {
            return currentVector;
        }
        
        console.warn(`Vector ${vectorName} not found`);
        return [];
    }

    /**
     * ç²å–æ‰€æœ‰å¯ç”¨çš„å‘é‡åç¨±
     * @returns {string[]} å‘é‡åç¨±åˆ—è¡¨
     */
    getAvailableVectors() {
        const vectors = ['time'];
        
        // æ·»åŠ é›»å£“å‘é‡
        for (const nodeName of this.nodeVoltages.keys()) {
            vectors.push(`V(${nodeName})`);
        }
        
        // æ·»åŠ é›»æµå‘é‡
        for (const branchName of this.branchCurrents.keys()) {
            vectors.push(`I(${branchName})`);
        }
        
        return vectors;
    }

    /**
     * ç²å–åˆ†æçµ±è¨ˆä¿¡æ¯
     * @returns {Object} çµ±è¨ˆä¿¡æ¯
     */
    getAnalysisInfo() {
        const info = {
            ...this.analysisInfo,
            totalTimePoints: this.timeVector.length,
            startTime: this.timeVector[0] || 0,
            stopTime: this.timeVector[this.timeVector.length - 1] || 0,
            availableVectors: this.getAvailableVectors()
        };
        
        if (this.timeVector.length > 1) {
            const timeSteps = [];
            for (let i = 1; i < this.timeVector.length; i++) {
                timeSteps.push(this.timeVector[i] - this.timeVector[i-1]);
            }
            info.averageTimeStep = timeSteps.reduce((sum, step) => sum + step, 0) / timeSteps.length;
            info.minTimeStep = Math.min(...timeSteps);
            info.maxTimeStep = Math.max(...timeSteps);
        }
        
        return info;
    }
}

/**
 * æš«æ…‹åˆ†æå¼•æ“
 */
export class TransientAnalysis {
    constructor(options = {}) {
        this.mnaBuilder = new MNABuilder({ debug: options.debug });
        this.components = [];
        this.result = null;
        
        // åˆ†æåƒæ•¸
        this.timeStep = options.timeStep || 1e-6;     // é è¨­æ™‚é–“æ­¥é•·: 1Âµs
        this.startTime = options.startTime || 0;      // é–‹å§‹æ™‚é–“
        this.stopTime = options.stopTime || 1e-3;     // çµæŸæ™‚é–“: 1ms
        this.maxTimeStep = options.maxTimeStep || 1e-6;  // æœ€å¤§æ™‚é–“æ­¥é•·
        this.minTimeStep = options.minTimeStep || 1e-12; // æœ€å°æ™‚é–“æ­¥é•·
        
        // Newton-Raphsonåƒæ•¸
        this.maxNewtonIterations = options.maxNewtonIterations || 50;
        this.newtonTolerance = options.newtonTolerance || 1e-9;
        this.dampingFactor = options.dampingFactor || 1.0;
        
        // æ•¸å€¼åƒæ•¸ (å‘å¾Œå…¼å®¹)
        this.maxIterations = this.maxNewtonIterations;  
        this.convergenceTol = this.newtonTolerance; 
        
        // èª¿è©¦å’Œç›£æ§
        this.debug = options.debug || false;
        this.saveHistory = options.saveHistory !== false;
        this.progressCallback = options.progressCallback || null;
        
        if (this.debug) {
            console.log('ğŸ”§ TransientAnalysisåˆå§‹åŒ– - æ”¯æŒNewton-Raphsonéç·šæ€§æ±‚è§£');
            console.log(`  æ™‚é–“æ­¥é•·: ${(this.timeStep * 1e6).toFixed(2)}Âµs`);
            console.log(`  Newtonåƒæ•¸: max_iter=${this.maxNewtonIterations}, tol=${this.newtonTolerance}`);
        }
    }

    /**
     * è¨­ç½®åˆ†æåƒæ•¸
     * @param {Object} params åƒæ•¸å°è±¡
     */
    setParameters(params) {
        if (params.timeStep !== undefined) this.timeStep = params.timeStep;
        if (params.startTime !== undefined) this.startTime = params.startTime;
        if (params.stopTime !== undefined) this.stopTime = params.stopTime;
        if (params.maxTimeStep !== undefined) this.maxTimeStep = params.maxTimeStep;
        if (params.minTimeStep !== undefined) this.minTimeStep = params.minTimeStep;
        if (params.maxIterations !== undefined) this.maxIterations = params.maxIterations;
        if (params.convergenceTol !== undefined) this.convergenceTol = params.convergenceTol;
        if (params.debug !== undefined) this.debug = params.debug;
        if (params.progressCallback !== undefined) this.progressCallback = params.progressCallback;
    }

    /**
     * åŸ·è¡Œæš«æ…‹åˆ†æ
     * @param {BaseComponent[]} components é›»è·¯å…ƒä»¶åˆ—è¡¨
     * @param {Object} params åˆ†æåƒæ•¸
     * @returns {TransientResult} åˆ†æçµæœ
     */
    async run(components, params = {}) {
        this.setParameters(params);
        this.components = [...components];
        this.result = new TransientResult();
        
        console.log(`Starting transient analysis: ${this.startTime}s to ${this.stopTime}s, step=${this.timeStep}s`);
        
        try {
            // åˆå§‹åŒ–
            await this.initialize();
            
            // ä¸»æ™‚åŸŸè¿´åœˆ
            await this.timeLoop();
            
            // å®Œæˆåˆ†æ
            this.finalize();
            
            console.log(`Transient analysis completed: ${this.result.timeVector.length} time points`);
            return this.result;
            
        } catch (error) {
            console.error('Transient analysis failed:', error);
            throw error;
        }
    }

    /**
     * åˆå§‹åŒ–åˆ†æ
     */
    /**
     * åˆå§‹åŒ–æš«æ…‹åˆ†æ
     * @param {BaseComponent[]} components å…ƒä»¶åˆ—è¡¨
     * @param {number} timeStep æ™‚é–“æ­¥é•·
     * @param {string} integrationMethod ç©åˆ†æ–¹æ³•: 'backward_euler' æˆ– 'trapezoidal'
     */
    async initialize(components = null, timeStep = null, integrationMethod = 'backward_euler') {
        // å¦‚æœæä¾›äº†å…ƒä»¶åˆ—è¡¨ï¼Œä½¿ç”¨å®ƒ
        if (components) {
            this.components = [...components];
        }
        
        // å¦‚æœæä¾›äº†æ™‚é–“æ­¥é•·ï¼Œä½¿ç”¨å®ƒ
        if (timeStep !== null) {
            this.timeStep = timeStep;
        }
        
        // è¨­ç½®ç©åˆ†æ–¹æ³•
        this.integrationMethod = integrationMethod;
        
        // åˆ†æé›»è·¯æ‹“æ’²
        this.mnaBuilder.analyzeCircuit(this.components);
        
        // åˆå§‹åŒ–æ‰€æœ‰å…ƒä»¶çš„æš«æ…‹ç‹€æ…‹
        for (const component of this.components) {
            component.initTransient(this.timeStep, integrationMethod);
        }
        
        // è¨­ç½®åˆå§‹æ¢ä»¶ (DCå·¥ä½œé»)
        await this.setInitialConditions();
        
        // å„²å­˜åˆ†æä¿¡æ¯
        const methodName = integrationMethod === 'trapezoidal' ? 'Trapezoidal Rule' : 'Backward Euler';
        this.result.analysisInfo = {
            timeStep: this.timeStep,
            startTime: this.startTime,
            stopTime: this.stopTime,
            method: methodName,
            integrationMethod: integrationMethod,
            matrixSize: this.mnaBuilder.matrixSize,
            nodeCount: this.mnaBuilder.nodeCount,
            voltageSourceCount: this.mnaBuilder.voltageSourceCount
        };
    }

    /**
     * è¨­ç½®åˆå§‹æ¢ä»¶ (åŸ·è¡ŒDCåˆ†æ)
     */
    async setInitialConditions() {
        if (this.debug) {
            console.log('Setting initial conditions...');
        }
        
        // å»ºç«‹t=0æ™‚çš„MNAçŸ©é™£
        const { matrix, rhs } = this.mnaBuilder.buildMNAMatrix(this.components, 0);
        
        if (this.debug) {
            this.mnaBuilder.printMNAMatrix();
        }
        
        // æ±‚è§£åˆå§‹å·¥ä½œé»
        const solution = LUSolver.solve(matrix, rhs);
        
        // æå–åˆå§‹ç‹€æ…‹
        const nodeVoltages = this.mnaBuilder.extractNodeVoltages(solution);
        const branchCurrents = this.mnaBuilder.extractVoltageSourceCurrents(solution);
        
        // æ›´æ–°å…ƒä»¶æ­·å²ç‹€æ…‹
        for (const component of this.components) {
            component.updateHistory(nodeVoltages, branchCurrents);
        }
        
        // ä¿å­˜åˆå§‹é»
        this.result.addTimePoint(this.startTime, nodeVoltages, branchCurrents);
        
        if (this.debug) {
            console.log('Initial conditions set');
            this.printSolutionSummary(nodeVoltages, branchCurrents);
        }
    }

    /**
     * ä¸»æ™‚åŸŸè¿´åœˆ
     */
    async timeLoop() {
        let currentTime = this.startTime + this.timeStep;
        let stepCount = 0;
        const totalSteps = Math.ceil((this.stopTime - this.startTime) / this.timeStep);
        
        while (currentTime <= this.stopTime) {
            stepCount++;
            
            try {
                // åŸ·è¡Œä¸€å€‹æ™‚é–“æ­¥
                await this.singleTimeStep(currentTime);
                
                // é€²åº¦å›èª¿
                if (this.progressCallback) {
                    const progress = stepCount / totalSteps;
                    this.progressCallback(progress, currentTime, stepCount);
                }
                
                // èª¿è©¦è¼¸å‡º
                if (this.debug && stepCount % 100 === 0) {
                    console.log(`Step ${stepCount}/${totalSteps}, time=${(currentTime * 1e6).toFixed(2)}Âµs`);
                }
                
                currentTime += this.timeStep;
                
            } catch (error) {
                console.error(`Time step failed at t=${currentTime}s:`, error);
                throw error;
            }
        }
    }

    /**
     * åŸ·è¡Œå–®å€‹æ™‚é–“æ­¥
     * @param {number} time ç•¶å‰æ™‚é–“
     */
    async singleTimeStep(time) {
        // æª¢æŸ¥æ˜¯å¦æœ‰éç·šæ€§å…ƒä»¶
        const hasNonlinearComponents = this.components.some(c => c.isNonlinear || c.stampResidual);

        if (hasNonlinearComponents) {
            // ä½¿ç”¨Newton-Raphsonæ±‚è§£éç·šæ€§ç³»çµ±
            await this.singleNonlinearTimeStep(time);
        } else {
            // ä½¿ç”¨ç›´æ¥ç·šæ€§æ±‚è§£
            await this.singleLinearTimeStep(time);
        }
    }

    /**
     * åŸ·è¡Œç·šæ€§æ™‚é–“æ­¥
     * @param {number} time ç•¶å‰æ™‚é–“
     */
    async singleLinearTimeStep(time) {
        // æ›´æ–°æ‰€æœ‰å…ƒä»¶çš„ä¼´éš¨æ¨¡å‹
        for (const component of this.components) {
            if (typeof component.updateCompanionModel === 'function') {
                component.updateCompanionModel();
            }
        }
        
        // å»ºç«‹ç•¶å‰æ™‚é–“é»çš„MNAçŸ©é™£
        const { matrix, rhs } = this.mnaBuilder.buildMNAMatrix(this.components, time);
        
        // æ±‚è§£ç·šæ€§æ–¹ç¨‹çµ„
        const solution = LUSolver.solve(matrix, rhs);
        
        // æå–ç¯€é»é›»å£“å’Œæ”¯è·¯é›»æµ
        const nodeVoltages = this.mnaBuilder.extractNodeVoltages(solution);
        const branchCurrents = this.mnaBuilder.extractVoltageSourceCurrents(solution);
        
        // æ›´æ–°æ‰€æœ‰å…ƒä»¶çš„æ­·å²ç‹€æ…‹
        for (const component of this.components) {
            component.updateHistory(nodeVoltages, branchCurrents);
        }
        
        // ä¿å­˜çµæœ
        this.result.addTimePoint(time, nodeVoltages, branchCurrents);
    }

    /**
     * åŸ·è¡Œéç·šæ€§æ™‚é–“æ­¥ (Newton-Raphson)
     * @param {number} time ç•¶å‰æ™‚é–“
     */
    async singleNonlinearTimeStep(time) {
        const maxIterations = this.maxNewtonIterations || 50;
        const tolerance = this.newtonTolerance || 1e-9;
        const dampingFactor = this.dampingFactor || 1.0;

        // ç²å–åˆå§‹çŒœæ¸¬å€¼
        let solution = this.getInitialGuess();
        
        let iteration = 0;
        let converged = false;
        let residualNorm = Infinity;

        // Newton-Raphsonè¿­ä»£
        while (iteration < maxIterations && !converged) {
            iteration++;

            // æ›´æ–°ä¼´éš¨æ¨¡å‹
            for (const component of this.components) {
                if (typeof component.updateCompanionModel === 'function') {
                    component.updateCompanionModel();
                }
            }

            // å»ºç«‹JacobiançŸ©é™£å’Œæ®˜å·®å‘é‡
            const { jacobian, residual } = this.buildNonlinearSystem(solution, time);

            // è¨ˆç®—æ®˜å·®ç¯„æ•¸
            residualNorm = residual.norm();

            // æª¢æŸ¥æ”¶æ–‚
            if (residualNorm < tolerance) {
                converged = true;
                break;
            }

            // æ±‚è§£Newtonæ­¥é•·: J * delta = -F
            const delta = LUSolver.solve(jacobian, residual.scale(-1));

            // æ‡‰ç”¨é˜»å°¼æ›´æ–°
            solution = solution.add(delta.scale(dampingFactor));

            if (this.debug && iteration % 5 === 0) {
                console.log(`  Newton iteration ${iteration}: residual = ${residualNorm.toExponential(3)}`);
            }
        }

        if (!converged) {
            throw new Error(`Newton-Raphson failed to converge at t=${time}s after ${iteration} iterations (residual: ${residualNorm.toExponential(3)})`);
        }

        // æå–çµæœ
        const nodeVoltages = this.mnaBuilder.extractNodeVoltages(solution);
        const branchCurrents = this.mnaBuilder.extractVoltageSourceCurrents(solution);

        // æ›´æ–°å…ƒä»¶æ­·å²
        for (const component of this.components) {
            component.updateHistory(nodeVoltages, branchCurrents);
        }

        // ä¿å­˜çµæœ
        this.result.addTimePoint(time, nodeVoltages, branchCurrents);

        if (this.debug && iteration > 10) {
            console.log(`âš¡ Newton converged in ${iteration} iterations at t=${(time * 1e6).toFixed(2)}Âµs`);
        }
    }

    /**
     * å»ºç«‹éç·šæ€§ç³»çµ± (JacobiançŸ©é™£å’Œæ®˜å·®å‘é‡)
     * @param {Vector} solution ç•¶å‰è§£å‘é‡
     * @param {number} time ç•¶å‰æ™‚é–“
     * @returns {Object} {jacobian, residual}
     */
    buildNonlinearSystem(solution, time) {
        // ä½¿ç”¨MNABuilderå»ºç«‹åŸºæœ¬ç·šæ€§ç³»çµ±
        const { matrix, rhs } = this.mnaBuilder.buildMNAMatrix(this.components, time);
        const matrixSize = this.mnaBuilder.matrixSize;
        
        // è¤‡è£½ç·šæ€§ç³»çµ±ä½œç‚ºåˆå§‹Jacobian
        const jacobian = matrix.copy();
        const residual = Vector.zeros(matrixSize);

        // è™•ç†éç·šæ€§å…ƒä»¶ï¼šä¿®æ”¹Jacobianä¸¦æ·»åŠ æ®˜å·®
        for (const component of this.components) {
            if (component.stampJacobian && component.stampResidual) {
                // éç·šæ€§å…ƒä»¶ï¼šæ›¿æ›Jacobianä¸­çš„ç·šæ€§é …ä¸¦æ·»åŠ æ®˜å·®
                component.stampJacobian(jacobian, solution, this.mnaBuilder.nodeMap, time);
                component.stampResidual(residual, solution, this.mnaBuilder.nodeMap, time);
            }
        }

        // è¨ˆç®—ç·šæ€§éƒ¨åˆ†æ®˜å·®ï¼šF(x) = A*x - b
        for (let i = 0; i < matrixSize; i++) {
            let sum = 0;
            for (let j = 0; j < matrixSize; j++) {
                sum += matrix.get(i, j) * solution.get(j);
            }
            residual.data[i] += sum - rhs.get(i);
        }

        return { jacobian, residual };
    }

    /**
     * ç²å–Newton-Raphsonåˆå§‹çŒœæ¸¬
     * @returns {Vector} åˆå§‹çŒœæ¸¬å‘é‡
     */
    getInitialGuess() {
        const matrixSize = this.mnaBuilder.matrixSize;
        
        // å¦‚æœæœ‰ä¸Šä¸€æ™‚é–“æ­¥çš„çµæœï¼Œä½¿ç”¨ä½œç‚ºåˆå§‹çŒœæ¸¬
        if (this.result && this.result.timePoints && this.result.timePoints.length > 0) {
            const lastPoint = this.result.timePoints[this.result.timePoints.length - 1];
            const guess = Vector.zeros(matrixSize);
            
            // å¡«å……ç¯€é»é›»å£“
            if (lastPoint.nodeVoltages) {
                for (const [nodeId, voltage] of lastPoint.nodeVoltages) {
                    const nodeIndex = this.mnaBuilder.nodeMap.get(nodeId);
                    if (nodeIndex !== undefined) {
                        guess.data[nodeIndex] = voltage;
                    }
                }
            }
            
            // å¡«å……é›»å£“æºé›»æµ
            if (lastPoint.branchCurrents) {
                let vsIndex = this.mnaBuilder.numNodes;
                for (const [sourceId, current] of lastPoint.branchCurrents) {
                    if (vsIndex < matrixSize) {
                        guess.data[vsIndex] = current;
                        vsIndex++;
                    }
                }
            }
            
            return guess;
        }
        
        // æ²’æœ‰æ­·å²æ•¸æ“šï¼Œä½¿ç”¨é›¶åˆå§‹çŒœæ¸¬
        return Vector.zeros(matrixSize);
    }

    /**
     * è¨­ç½®Newton-Raphsonåƒæ•¸
     * @param {Object} params Newton-Raphsonåƒæ•¸
     */
    setNewtonParameters(params = {}) {
        this.maxNewtonIterations = params.maxIterations || 50;
        this.newtonTolerance = params.tolerance || 1e-9;
        this.dampingFactor = params.dampingFactor || 1.0;
        
        if (this.debug) {
            console.log(`ğŸ”§ Newton-Raphsonåƒæ•¸è¨­ç½®:`);
            console.log(`  æœ€å¤§è¿­ä»£æ¬¡æ•¸: ${this.maxNewtonIterations}`);
            console.log(`  æ”¶æ–‚å®¹å·®: ${this.newtonTolerance}`);
            console.log(`  é˜»å°¼å› å­: ${this.dampingFactor}`);
        }
    }

    /**
     * å®Œæˆåˆ†æ
     */
    finalize() {
        // è¨ˆç®—æœ€çµ‚çµ±è¨ˆä¿¡æ¯
        const info = this.result.getAnalysisInfo();
        console.log(`Analysis summary: ${info.totalTimePoints} points, avg step=${(info.averageTimeStep * 1e6).toFixed(2)}Âµs`);
        
        // æ¸…ç†è³‡æº
        this.mnaBuilder.reset();
    }

    /**
     * æ‰“å°è§£çš„æ‘˜è¦ (èª¿è©¦ç”¨)
     * @param {Map<string, number>} nodeVoltages ç¯€é»é›»å£“
     * @param {Map<string, number>} branchCurrents æ”¯è·¯é›»æµ
     */
    printSolutionSummary(nodeVoltages, branchCurrents) {
        console.log('\\nSolution Summary:');
        console.log('Node Voltages:');
        for (const [node, voltage] of nodeVoltages) {
            console.log(`  V(${node}) = ${voltage.toFixed(6)}V`);
        }
        
        console.log('Branch Currents:');
        for (const [branch, current] of branchCurrents) {
            console.log(`  I(${branch}) = ${(current * 1000).toFixed(3)}mA`);
        }
        console.log('');
    }

    /**
     * è¨­ç½®èª¿è©¦æ¨¡å¼
     * @param {boolean} enabled æ˜¯å¦å•Ÿç”¨èª¿è©¦
     */
    setDebug(enabled) {
        this.debug = enabled;
        // é‡æ–°å‰µå»ºMNABuilderä»¥å‚³édebugé¸é …
        this.mnaBuilder = new MNABuilder({ debug: enabled });
    }

    /**
     * ç²å–ç•¶å‰åˆ†æç‹€æ…‹
     * @returns {Object} ç‹€æ…‹ä¿¡æ¯
     */
    getStatus() {
        return {
            isRunning: this.result !== null,
            currentTime: this.result ? this.result.timeVector[this.result.timeVector.length - 1] : 0,
            progress: this.result ? this.result.timeVector.length / Math.ceil((this.stopTime - this.startTime) / this.timeStep) : 0,
            timePoints: this.result ? this.result.timeVector.length : 0
        };
    }

    /**
     * åŸ·è¡Œå–®ä¸€æ™‚é–“æ­¥æ±‚è§£ (ç”¨æ–¼æ­¥é€²å¼æ§åˆ¶)
     * @param {number} currentTime ç•¶å‰æ™‚é–“
     * @param {number} maxIterations æœ€å¤§è¿­ä»£æ¬¡æ•¸
     * @returns {Object} æ±‚è§£çµæœ
     */
    solveTimeStep(currentTime, maxIterations = this.maxIterations) {
        try {
            // å»ºç«‹ç•¶å‰æ™‚é–“æ­¥çš„ MNA çŸ©é™£ (è€ƒæ…®æ­·å²é …)
            const { matrix, rhs } = this.mnaBuilder.buildMNAMatrix(this.components, currentTime);
            
            // æ±‚è§£ç·šæ€§ç³»çµ±
            const solution = LUSolver.solve(matrix, rhs);
            
            // æå–çµæœ
            const nodeVoltages = this.mnaBuilder.extractNodeVoltages(solution);
            const branchCurrents = this.mnaBuilder.extractVoltageSourceCurrents(solution);
            
            // æª¢æŸ¥æ”¶æ–‚æ€§ (ç°¡åŒ–æª¢æŸ¥)
            const converged = true; // åœ¨ç·šæ€§åˆ†æä¸­ç¸½æ˜¯æ”¶æ–‚
            
            // æ›´æ–°å…ƒä»¶æ­·å²ç‹€æ…‹
            for (const component of this.components) {
                component.updateHistory(nodeVoltages, branchCurrents);
            }
            
            return {
                converged: converged,
                nodeVoltages: nodeVoltages,
                branchCurrents: branchCurrents,
                time: currentTime
            };
            
        } catch (error) {
            throw new Error(`Time step solution failed at t=${currentTime}s: ${error.message}`);
        }
    }
}

/**
 * æš«æ…‹åˆ†æå·¥å…·å‡½æ•¸
 */
export class TransientUtils {
    /**
     * è§£æSPICEé¢¨æ ¼çš„æš«æ…‹åˆ†ææŒ‡ä»¤
     * @param {string} command æŒ‡ä»¤å­—ç¬¦ä¸² (å¦‚ '.tran 1us 1ms')
     * @returns {Object} è§£æå¾Œçš„åƒæ•¸
     */
    static parseTranCommand(command) {
        const cmd = command.trim().toLowerCase();
        
        // åŒ¹é… .tran [step] [stop] [start] [max_step]
        // ä½¿ç”¨æ­£è¦è¡¨ç¤ºå¼å­—é¢é‡ï¼Œä¸¦ç”¨å–®åæ–œç·šé€²è¡Œè½‰ç¾©
        const match = cmd.match(/^\.tran\s+([0-9.]+[a-z]*)\s+([0-9.]+[a-z]*)(?:\s+([0-9.]+[a-z]*))?(?:\s+([0-9.]+[a-z]*))?/);
        
        if (!match) {
            throw new Error(`Invalid .tran command: ${command}`);
        }
        
        const params = {
            timeStep: TransientUtils.parseTimeValue(match[1]),
            stopTime: TransientUtils.parseTimeValue(match[2]),
            startTime: match[3] ? TransientUtils.parseTimeValue(match[3]) : 0,
            maxTimeStep: match[4] ? TransientUtils.parseTimeValue(match[4]) : undefined
        };
        
        return params;
    }

    /**
     * è§£ææ™‚é–“å€¼ (æ”¯æ´å·¥ç¨‹è¨˜è™Ÿ)
     * @param {string} timeStr æ™‚é–“å­—ç¬¦ä¸² (å¦‚ '1us', '2.5ms')
     * @returns {number} æ™‚é–“å€¼ (ç§’)
     */
    static parseTimeValue(timeStr) {
        const str = timeStr.trim().toLowerCase();
        
        // æŒ‰ç…§é•·åº¦é™åºæ’åˆ—ï¼Œç¢ºä¿æœ€é•·çš„å¾Œç¶´å…ˆè¢«åŒ¹é…
        const suffixes = [
            ['fs', 1e-15],
            ['ps', 1e-12], 
            ['ns', 1e-9],
            ['us', 1e-6],
            ['Âµs', 1e-6],
            ['ms', 1e-3],
            ['u', 1e-6],   // SPICE é¢¨æ ¼ï¼šu = å¾®ç§’
            ['m', 1e-3],   // SPICE é¢¨æ ¼ï¼šm = æ¯«ç§’  
            ['s', 1]
        ];
        
        for (const [suffix, multiplier] of suffixes) {
            if (str.endsWith(suffix)) {
                const numPart = parseFloat(str.slice(0, -suffix.length));
                if (!isNaN(numPart)) {
                    return numPart * multiplier;
                }
            }
        }
        
        // å¦‚æœæ²’æœ‰å¾Œç¶´ï¼Œå‡è¨­æ˜¯ç§’
        const numValue = parseFloat(str);
        if (!isNaN(numValue)) {
            return numValue;
        }
        
        throw new Error(`Cannot parse time value: ${timeStr}`);
    }

    /**
     * æ ¼å¼åŒ–æ™‚é–“å€¼ç‚ºå¯è®€å­—ç¬¦ä¸²
     * @param {number} time æ™‚é–“å€¼ (ç§’)
     * @returns {string} æ ¼å¼åŒ–çš„å­—ç¬¦ä¸²
     */
    static formatTime(time) {
        const abs = Math.abs(time);
        
        if (abs >= 1) {
            return `${time.toFixed(3)}s`;
        } else if (abs >= 1e-3) {
            return `${(time * 1e3).toFixed(3)}ms`;
        } else if (abs >= 1e-6) {
            return `${(time * 1e6).toFixed(3)}Âµs`;
        } else if (abs >= 1e-9) {
            return `${(time * 1e9).toFixed(3)}ns`;
        } else {
            return `${(time * 1e12).toFixed(3)}ps`;
        }
    }
}