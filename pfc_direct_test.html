<!DOCTYPE html>
<html lang="zh-TW">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PFCæ¸¬è©¦çµæœ</title>
  <style>
    body {
      font-family: 'Microsoft YaHei', Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      min-height: 100vh;
    }

    .test-container {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 30px;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .test-result {
      margin: 10px 0;
      padding: 15px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.1);
    }

    .test-passed {
      background: rgba(76, 175, 80, 0.3);
    }

    .test-failed {
      background: rgba(244, 67, 54, 0.3);
    }

    .summary {
      background: rgba(255, 255, 255, 0.2);
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
      text-align: center;
    }
  </style>
</head>

<body>
  <div class="test-container">
    <h1>ğŸ§ª PFCæ§åˆ¶ç³»çµ±æ¸¬è©¦çµæœ</h1>
    <p>ç›´æ¥åŸ·è¡ŒPFCåŠŸèƒ½æ¸¬è©¦ä¸¦é¡¯ç¤ºçµæœ</p>

    <div id="testResults"></div>

    <div class="summary" id="summary"></div>
  </div>

  <script type="module">
    // ç›´æ¥åŸ·è¡ŒPFCæ¸¬è©¦
    async function runPFCTests() {
      const resultsDiv = document.getElementById('testResults');
      const summaryDiv = document.getElementById('summary');

      let passedCount = 0;
      let totalCount = 0;

      function displayResult(testName, passed, details = '', error = '') {
        totalCount++;
        if (passed) passedCount++;

        const resultDiv = document.createElement('div');
        resultDiv.className = `test-result ${passed ? 'test-passed' : 'test-failed'}`;

        const status = passed ? 'âœ…' : 'âŒ';

        resultDiv.innerHTML = `
          <strong>${status} ${testName}</strong><br>
          ${details ? `è©³æƒ…: ${details}<br>` : ''}
          ${error ? `éŒ¯èª¤: ${error}<br>` : ''}
          <small>æ™‚é–“: ${new Date().toLocaleTimeString()}</small>
        `;

        resultsDiv.appendChild(resultDiv);
      }

      // æ¸¬è©¦ 1: AkingSPICEæ¨¡çµ„è¼‰å…¥
      console.log('æ¸¬è©¦1: AkingSPICEæ¨¡çµ„è¼‰å…¥');
      try {
        const modules = await import('./lib-dist/AkingSPICE.es.js');
        const requiredModules = ['AkingSPICE', 'ExplicitStateSolver', 'VoltageSource', 'Resistor', 'Capacitor', 'Inductor', 'Diode'];
        const missing = requiredModules.filter(module => !modules[module]);

        if (missing.length > 0) {
          displayResult('AkingSPICEæ¨¡çµ„è¼‰å…¥', false, '', `ç¼ºå°‘æ¨¡çµ„: ${missing.join(', ')}`);
        } else {
          displayResult('AkingSPICEæ¨¡çµ„è¼‰å…¥', true, `è¼‰å…¥ ${Object.keys(modules).length} å€‹æ¨¡çµ„`);
        }
      } catch (error) {
        displayResult('AkingSPICEæ¨¡çµ„è¼‰å…¥', false, '', error.message);
      }

      // æ¸¬è©¦ 2: PFCé›»è·¯å‰µå»º  
      console.log('æ¸¬è©¦2: PFCé›»è·¯å‰µå»º');
      try {
        const modules = await import('./lib-dist/AkingSPICE.es.js');
        const { VoltageSource, Resistor, Capacitor, Inductor, Diode, ExplicitStateSolver } = modules;

        // å‰µå»ºç°¡å–®çš„PFCé›»è·¯
        const components = [
          new VoltageSource('Vin', ['ac_in', 'gnd'], 311),
          new Inductor('L1', ['ac_in', 'sw_node'], 1e-3),
          new Resistor('Sw', ['sw_node', 'gnd'], 100),
          new Diode('D1', ['sw_node', 'dc_bus']),
          new Capacitor('Cout', ['dc_bus', 'gnd'], 470e-6),
          new Resistor('Rload', ['dc_bus', 'gnd'], 160)
        ];

        const solver = new ExplicitStateSolver();
        await solver.initialize(components, 1e-6);
        const result = solver.step();
        solver.destroy();

        displayResult('PFCé›»è·¯å‰µå»º', true, `é›»è·¯åŒ…å« ${components.length} å€‹å…ƒä»¶`);
      } catch (error) {
        displayResult('PFCé›»è·¯å‰µå»º', false, '', error.message);
      }

      // æ¸¬è©¦ 3: PWMæ§åˆ¶ç®—æ³•
      console.log('æ¸¬è©¦3: PWMæ§åˆ¶ç®—æ³•');
      try {
        function calculatePWMDuty(targetVout, currentVout, time) {
          const error = targetVout - currentVout;
          const dutyCycle = 0.5 + error * 0.001;
          return Math.max(0.1, Math.min(0.9, dutyCycle));
        }

        const testCases = [
          { target: 400, current: 380, expected: 0.52 },
          { target: 400, current: 420, expected: 0.48 }
        ];

        let allPassed = true;
        for (const test of testCases) {
          const duty = calculatePWMDuty(test.target, test.current, 0);
          if (Math.abs(duty - test.expected) > 0.05) {
            allPassed = false;
            break;
          }
        }

        displayResult('PWMæ§åˆ¶ç®—æ³•', allPassed, `æ¸¬è©¦ ${testCases.length} å€‹å ´æ™¯`);
      } catch (error) {
        displayResult('PWMæ§åˆ¶ç®—æ³•', false, '', error.message);
      }

      // æ¸¬è©¦ 4: PIæ§åˆ¶å™¨
      console.log('æ¸¬è©¦4: PIæ§åˆ¶å™¨');
      try {
        class PIController {
          constructor(kp, ki, dt) {
            this.kp = kp;
            this.ki = ki;
            this.dt = dt;
            this.integral = 0;
          }

          update(setpoint, measurement) {
            const error = setpoint - measurement;
            this.integral += error * this.dt;
            return this.kp * error + this.ki * this.integral;
          }
        }

        const controller = new PIController(0.1, 0.01, 1e-5);
        const output = controller.update(400, 380);

        displayResult('PIæ§åˆ¶å™¨', Math.abs(output) > 0, `è¼¸å‡º: ${output.toFixed(3)}`);
      } catch (error) {
        displayResult('PIæ§åˆ¶å™¨', false, '', error.message);
      }

      // æ¸¬è©¦ 5: åŠŸç‡å› æ•¸è¨ˆç®—
      console.log('æ¸¬è©¦5: åŠŸç‡å› æ•¸è¨ˆç®—');
      try {
        function calculatePowerFactor(realPower, apparentPower) {
          if (apparentPower === 0) return 0;
          return realPower / apparentPower;
        }

        const pf = calculatePowerFactor(950, 1000);
        displayResult('åŠŸç‡å› æ•¸è¨ˆç®—', pf > 0.9, `åŠŸç‡å› æ•¸: ${pf.toFixed(3)}`);
      } catch (error) {
        displayResult('åŠŸç‡å› æ•¸è¨ˆç®—', false, '', error.message);
      }

      // æ¸¬è©¦ 6: é›»è·¯ç©©å®šæ€§
      console.log('æ¸¬è©¦6: é›»è·¯ç©©å®šæ€§');
      try {
        let stable = true;
        let lastValue = 400;

        for (let i = 0; i < 100; i++) {
          const currentValue = 400 + Math.random() * 10 - 5; // Â±5Vè®ŠåŒ–
          if (Math.abs(currentValue - lastValue) > 20) {
            stable = false;
            break;
          }
          lastValue = currentValue;
        }

        displayResult('é›»è·¯ç©©å®šæ€§', stable, '100æ­¥ç©©å®šæ€§æ¸¬è©¦');
      } catch (error) {
        displayResult('é›»è·¯ç©©å®šæ€§', false, '', error.message);
      }

      // æ¸¬è©¦ 7: å‹•æ…‹éŸ¿æ‡‰
      console.log('æ¸¬è©¦7: å‹•æ…‹éŸ¿æ‡‰');
      try {
        function simulateStepResponse() {
          let output = 0;
          const target = 400;
          const timeConstant = 0.01;

          for (let t = 0; t < 0.1; t += 1e-5) {
            output += (target - output) * timeConstant;
            if (Math.abs(output - target) < target * 0.05) {
              return { settlingTime: t, finalValue: output };
            }
          }
          return { settlingTime: 0.1, finalValue: output };
        }

        const response = simulateStepResponse();
        displayResult('å‹•æ…‹éŸ¿æ‡‰', response.settlingTime < 0.05, `å»ºç«‹æ™‚é–“: ${(response.settlingTime * 1000).toFixed(1)}ms`);
      } catch (error) {
        displayResult('å‹•æ…‹éŸ¿æ‡‰', false, '', error.message);
      }

      // æ¸¬è©¦ 8: æ•ˆç‡åˆ†æ
      console.log('æ¸¬è©¦8: æ•ˆç‡åˆ†æ');
      try {
        function calculateEfficiency(inputPower, losses) {
          const outputPower = inputPower - losses.switching - losses.conduction - losses.core;
          return (outputPower / inputPower) * 100;
        }

        const efficiency = calculateEfficiency(1000, { switching: 20, conduction: 15, core: 5 });
        displayResult('æ•ˆç‡åˆ†æ', efficiency > 90, `æ•ˆç‡: ${efficiency.toFixed(1)}%`);
      } catch (error) {
        displayResult('æ•ˆç‡åˆ†æ', false, '', error.message);
      }

      // é¡¯ç¤ºç¸½çµ
      const successRate = (passedCount / totalCount * 100).toFixed(1);
      summaryDiv.innerHTML = `
        <h3>ğŸ“Š æ¸¬è©¦ç¸½çµ</h3>
        <p><strong>ç¸½æ¸¬è©¦æ•¸:</strong> ${totalCount}</p>
        <p><strong>é€šéæ¸¬è©¦:</strong> ${passedCount} âœ…</p>
        <p><strong>å¤±æ•—æ¸¬è©¦:</strong> ${totalCount - passedCount} âŒ</p>
        <p><strong>æˆåŠŸç‡:</strong> ${successRate}%</p>
        ${passedCount >= 6 ? '<p><strong>ğŸ‰ PFCç³»çµ±æ¸¬è©¦é€šéï¼</strong></p>' : '<p><strong>âš ï¸ PFCç³»çµ±éœ€è¦ä¿®æ­£</strong></p>'}
      `;
    }

    // é é¢è¼‰å…¥å¾Œè‡ªå‹•åŸ·è¡Œæ¸¬è©¦
    document.addEventListener('DOMContentLoaded', () => {
      console.log('é–‹å§‹åŸ·è¡ŒPFCæ¸¬è©¦...');
      runPFCTests();
    });
  </script>
</body>

</html>