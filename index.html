<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript 測試頁面</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .output {
            background: #f0f0f0;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            font-family: monospace;
            border-left: 4px solid #007acc;
        }
        .error {
            background: #ffebee;
            border-left: 4px solid #f44336;
            color: #c62828;
        }
        button {
            background: #007acc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #005a9e;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>JavaScript 自動調試測試</h1>
        
        <h2>測試案例</h2>
        <button onclick="testBasicOperations()">基本運算測試</button>
        <button onclick="testArrayOperations()">陣列操作測試</button>
        <button onclick="testErrorHandling()">錯誤處理測試</button>
        <button onclick="testAsyncOperations()">異步操作測試</button>
        <button onclick="clearOutput()">清除輸出</button>
        
        <h2>輸出結果</h2>
        <div id="output"></div>
    </div>

    <script>
        // 自動錯誤捕獲和日誌系統
        class DebugLogger {
            constructor() {
                this.outputElement = document.getElementById('output');
                this.setupErrorHandling();
            }

            // 設置全局錯誤處理
            setupErrorHandling() {
                window.addEventListener('error', (event) => {
                    this.logError(`運行時錯誤: ${event.message}`, event.filename, event.lineno);
                });

                window.addEventListener('unhandledrejection', (event) => {
                    this.logError(`未處理的Promise拒絕: ${event.reason}`);
                });
            }

            // 記錄普通訊息
            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = 'output';
                logEntry.innerHTML = `<strong>[${timestamp}] ${type.toUpperCase()}:</strong> ${message}`;
                this.outputElement.appendChild(logEntry);
                console.log(`[${timestamp}] ${type.toUpperCase()}: ${message}`);
            }

            // 記錄錯誤
            logError(message, filename = '', line = '') {
                const timestamp = new Date().toLocaleTimeString();
                const errorEntry = document.createElement('div');
                errorEntry.className = 'output error';
                errorEntry.innerHTML = `<strong>[${timestamp}] ERROR:</strong> ${message}${filename ? ` (${filename}:${line})` : ''}`;
                this.outputElement.appendChild(errorEntry);
                console.error(`[${timestamp}] ERROR: ${message}`);
            }

            // 清除輸出
            clear() {
                this.outputElement.innerHTML = '';
            }
        }

        // 初始化調試記錄器
        const logger = new DebugLogger();

        // 安全執行函數 - 自動捕獲錯誤
        function safeExecute(fn, description) {
            try {
                logger.log(`開始執行: ${description}`);
                const result = fn();
                
                // 如果是Promise，處理異步結果
                if (result && typeof result.then === 'function') {
                    return result
                        .then(res => {
                            logger.log(`✅ ${description} 成功完成: ${JSON.stringify(res)}`);
                            return res;
                        })
                        .catch(err => {
                            logger.logError(`❌ ${description} 失敗: ${err.message}`);
                            throw err;
                        });
                } else {
                    logger.log(`✅ ${description} 成功完成: ${JSON.stringify(result)}`);
                    return result;
                }
            } catch (error) {
                logger.logError(`❌ ${description} 失敗: ${error.message}`);
                return null;
            }
        }

        // 測試函數 1: 基本運算
        function testBasicOperations() {
            safeExecute(() => {
                const a = 10;
                const b = 5;
                const results = {
                    addition: a + b,
                    subtraction: a - b,
                    multiplication: a * b,
                    division: a / b
                };
                return results;
            }, '基本數學運算');
        }

        // 測試函數 2: 陣列操作
        function testArrayOperations() {
            safeExecute(() => {
                const numbers = [1, 2, 3, 4, 5];
                const results = {
                    original: numbers,
                    doubled: numbers.map(x => x * 2),
                    sum: numbers.reduce((acc, curr) => acc + curr, 0),
                    filtered: numbers.filter(x => x > 3)
                };
                return results;
            }, '陣列操作測試');
        }

        // 測試函數 3: 錯誤處理
        function testErrorHandling() {
            safeExecute(() => {
                // 故意製造錯誤來測試錯誤處理
                throw new Error('這是一個測試錯誤');
            }, '錯誤處理測試');

            // 測試未定義變數錯誤
            safeExecute(() => {
                return undefinedVariable.someProperty;
            }, '未定義變數錯誤測試');
        }

        // 測試函數 4: 異步操作
        function testAsyncOperations() {
            safeExecute(async () => {
                // 模擬異步操作
                const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
                
                await delay(1000);
                const data = await fetch('https://jsonplaceholder.typicode.com/posts/1')
                    .then(response => response.json());
                
                return {
                    message: '異步操作完成',
                    data: data.title
                };
            }, '異步操作測試');
        }

        // 清除輸出
        function clearOutput() {
            logger.clear();
        }

        // 頁面載入完成後的初始化
        document.addEventListener('DOMContentLoaded', () => {
            logger.log('頁面載入完成，JavaScript調試系統已啟動');
            logger.log('點擊按鈕開始測試各種功能');
        });
    </script>
</body>
</html>