<!DOCTYPE html>
<html>

<head>
  <title>RHS向量調試測試</title>
</head>

<body>
  <h1>RHS向量調試測試</h1>
  <div id="output"></div>

  <script type="module">
    let output = document.getElementById('output');

    function log(message) {
      console.log(message);
      output.innerHTML += message + '<br>';
    }

    try {
      // 加載AkingSPICE
      log('加載AkingSPICE...');
      const { VoltageSource, Resistor, ExplicitStateSolver } = window.AkingSPICE;

      // 創建最簡單的電路: 5V電壓源 + 10Ω電阻
      const v1 = new VoltageSource('V1', ['n1', 'gnd'], 5);
      const r1 = new Resistor('R1', ['n1', 'gnd'], 10);

      log('元件創建完成');
      log(`V1: nodes=${v1.nodes}, value=${v1.value}`);
      log(`R1: nodes=${r1.nodes}, value=${r1.value}`);

      // 創建並初始化求解器
      const solver = new ExplicitStateSolver([v1, r1]);
      log('求解器創建完成');

      try {
        solver.initialize();
        log('求解器初始化完成');
      } catch (initError) {
        log('❌ 初始化錯誤: ' + initError.message);
        throw initError;
      }

      // 檢查預處理結果
      const circuitData = solver.circuitData;
      if (!circuitData) {
        log('❌ circuitData仍為null');
        return;
      }

      log(`\n=== 電路預處理結果 ===`);
      log(`節點數: ${circuitData.nodeCount}`);
      log(`節點映射: ${JSON.stringify(Array.from(circuitData.nodeMap))}`);

      // 檢查G矩陣
      log(`\n=== G矩陣條目 ===`);
      const entries = solver.preprocessor.gMatrixEntries;
      for (const entry of entries) {
        log(`G[${entry.row},${entry.col}] = ${entry.value}`);
      }

      // **關鍵檢查：手動調用updateRHS並觀察結果**
      log(`\n=== 手動RHS更新測試 ===`);

      // 創建空的RHS向量
      const testRHS = new Float32Array(circuitData.nodeCount);
      const testState = new Float32Array(0); // 沒有狀態變量

      log(`初始RHS: [${Array.from(testRHS)}]`);

      // 手動調用電壓源的updateRHS
      const v1Data = circuitData.componentData.get('V1');
      log(`V1數據: ${JSON.stringify(v1Data || 'undefined')}`);
      log(`V1預處理節點索引: node1=${v1.node1Idx}, node2=${v1.node2Idx}`);
      log(`V1大導納: ${v1.largeAdmittance}`);

      v1.updateRHS(testRHS, testState, 0, v1Data);
      log(`V1 updateRHS後: [${Array.from(testRHS)}]`);

      // 手動調用電阻的updateRHS (應該不變)
      const r1Data = circuitData.componentData.get('R1');
      r1.updateRHS(testRHS, testState, 0, r1Data);
      log(`R1 updateRHS後: [${Array.from(testRHS)}]`);

      // 檢查求解器的完整流程
      log(`\n=== 完整求解流程 ===`);

      // 檢查第一次求解前的RHS
      solver.buildRHSVector();
      log(`求解器RHS: [${Array.from(solver.rhsVector)}]`);

      // 執行一步
      solver.step(1e-6);

      // 檢查結果
      const nodeVoltages = solver.getNodeVoltages();
      log(`\n=== 最終結果 ===`);
      for (const [node, voltage] of Object.entries(nodeVoltages)) {
        log(`節點${node}: ${voltage}V`);
      }

      log(`\n期望結果: n1節點應該是5V (因為5V電壓源)`);
      log(`實際結果: ${nodeVoltages.n1}V`);

      if (Math.abs(nodeVoltages.n1 - 5) < 0.1) {
        log('✅ 測試通過！');
      } else {
        log('❌ 測試失敗！');
      }

    } catch (error) {
      log('❌ 錯誤: ' + error.message);
      log('Stack: ' + error.stack);
    }
  </script>

  <script src="lib-dist/AkingSPICE.umd.js"></script>
</body>

</html>