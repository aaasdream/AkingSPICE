<!DOCTYPE html>
<html>
<head>
    <title>LLCé›»è·¯æœ€çµ‚æ¸¬è©¦</title>
</head>
<body>
    <h1>LLCé›»è·¯æœ€çµ‚æ¸¬è©¦</h1>
    <canvas id="waveform" width="800" height="400" style="border: 1px solid black;"></canvas>
    <div id="controls">
        <button onclick="startSimulation()">é–‹å§‹ä»¿çœŸ</button>
        <button onclick="stopSimulation()">åœæ­¢</button>
        <div id="output"></div>
    </div>

    <script src="lib-dist/AkingSPICE.umd.js"></script>
    <script>
        let output = document.getElementById('output');
        let canvas = document.getElementById('waveform');
        let ctx = canvas.getContext('2d');
        let animationId = null;
        
        function log(msg) {
            console.log(msg);
            output.innerHTML += msg + '<br>';
            output.scrollTop = output.scrollHeight;
        }
        
        async function startSimulation() {
            try {
                log('ğŸš€ é–‹å§‹LLCè«§æŒ¯è½‰æ›å™¨ä»¿çœŸ...');
                
                const { VoltageSource, Resistor, Capacitor, Inductor, Diode, ExplicitStateSolver } = window.AkingSPICE;
                
                // æ§‹å»ºLLCè«§æŒ¯è½‰æ›å™¨
                // è¼¸å…¥: 400V DC
                // è«§æŒ¯åƒæ•¸: Lr=10ÂµH, Cr=100nF, Lm=50ÂµH  
                // è¼¸å‡ºæ•´æµ: 12V/5A
                
                const components = [
                    // è¼¸å…¥é›»å£“æº
                    new VoltageSource('Vin', ['vin', 'gnd'], 400),
                    
                    // è«§æŒ¯é›»æ„Ÿå’Œé›»å®¹
                    new Inductor('Lr', ['vin', 'res_node'], 10e-6),        // 10ÂµH
                    new Capacitor('Cr', ['res_node', 'center'], 100e-9),   // 100nF
                    
                    // ç£åŒ–é›»æ„Ÿ (è®Šå£“å™¨)
                    new Inductor('Lm', ['center', 'gnd'], 50e-6),          // 50ÂµH
                    
                    // è¼¸å‡ºæ•´æµ (ç°¡åŒ–ç‚ºé›»é˜»è² è¼‰)
                    new Resistor('Rload', ['center', 'gnd'], 2.4),         // 12V/5A = 2.4Î©
                ];
                
                log(`å…ƒä»¶æ•¸é‡: ${components.length}`);
                log('é›»è·¯æ‹“æ’²: Vin -> Lr -> Cr -> Lm || Rload');
                
                // å‰µå»ºæ±‚è§£å™¨
                const solver = new ExplicitStateSolver();
                await solver.initialize(components, 1e-7);  // 100nsæ™‚é–“æ­¥
                
                log('âœ… æ±‚è§£å™¨åˆå§‹åŒ–å®Œæˆ');
                log(`ç¯€é»æ•¸: ${solver.circuitData.nodeCount}`);
                log(`ç‹€æ…‹è®Šé‡æ•¸: ${solver.circuitData.stateCount}`);
                
                // æº–å‚™æ³¢å½¢è¨˜éŒ„
                const waveforms = {
                    time: [],
                    vinVoltage: [],
                    resVoltage: [], 
                    centerVoltage: [],
                    lrCurrent: [],
                    crVoltage: [],
                    lmCurrent: []
                };
                
                let step = 0;
                const maxSteps = 500;
                
                function simulate() {
                    if (step >= maxSteps) {
                        log(`âœ… ä»¿çœŸå®Œæˆ (${step}æ­¥)`);
                        drawWaveforms(waveforms);
                        return;
                    }
                    
                    // åŸ·è¡Œä¸€æ­¥ä»¿çœŸ
                    const result = solver.step();
                    
                    // è¨˜éŒ„æ³¢å½¢æ•¸æ“š
                    const t = result.time;
                    waveforms.time.push(t * 1e6);  // è½‰æ›ç‚ºå¾®ç§’
                    waveforms.vinVoltage.push(result.nodeVoltages.vin || 0);
                    waveforms.resVoltage.push(result.nodeVoltages.res_node || 0);
                    waveforms.centerVoltage.push(result.nodeVoltages.center || 0);
                    waveforms.lrCurrent.push(result.stateVariables.Lr || 0);
                    waveforms.crVoltage.push(result.stateVariables.Cr || 0);
                    waveforms.lmCurrent.push(result.stateVariables.Lm || 0);
                    
                    // æ¯100æ­¥è¼¸å‡ºä¸€æ¬¡ç‹€æ…‹
                    if (step % 100 === 0) {
                        log(`t=${t.toExponential(2)}s: Vcenter=${(result.nodeVoltages.center || 0).toFixed(2)}V, Ilr=${(result.stateVariables.Lr || 0).toFixed(3)}A`);
                    }
                    
                    step++;
                    
                    // å¯¦æ™‚ç¹ªè£½
                    if (step % 10 === 0) {
                        drawWaveforms(waveforms);
                    }
                    
                    // ç¹¼çºŒä»¿çœŸ
                    animationId = requestAnimationFrame(simulate);
                }
                
                // é–‹å§‹ä»¿çœŸå¾ªç’°
                animate = simulate;
                simulate();
                
            } catch (error) {
                log('âŒ ä»¿çœŸéŒ¯èª¤: ' + error.message);
                console.error(error);
            }
        }
        
        function stopSimulation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
                log('â¹ï¸ ä»¿çœŸå·²åœæ­¢');
            }
        }
        
        function drawWaveforms(waveforms) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (waveforms.time.length < 2) return;
            
            const width = canvas.width - 60;
            const height = canvas.height - 60;
            const offsetX = 30;
            const offsetY = 30;
            
            // ç¹ªè£½ç¶²æ ¼
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = offsetX + (width * i / 10);
                const y = offsetY + (height * i / 10);
                ctx.beginPath();
                ctx.moveTo(x, offsetY);
                ctx.lineTo(x, offsetY + height);
                ctx.moveTo(offsetX, y);
                ctx.lineTo(offsetX + width, y);
                ctx.stroke();
            }
            
            // ç¹ªè£½æ³¢å½¢
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ff8000', '#8000ff', '#00ffff'];
            const labels = ['Vin', 'Vres', 'Vcenter', 'Ilr', 'Vcr', 'Ilm'];
            const datasets = [
                waveforms.vinVoltage,
                waveforms.resVoltage, 
                waveforms.centerVoltage,
                waveforms.lrCurrent,
                waveforms.crVoltage,
                waveforms.lmCurrent
            ];
            
            datasets.forEach((data, idx) => {
                if (data.length < 2) return;
                
                ctx.strokeStyle = colors[idx % colors.length];
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                // è‡ªå‹•ç¸®æ”¾
                const minVal = Math.min(...data);
                const maxVal = Math.max(...data);
                const range = Math.max(Math.abs(maxVal), Math.abs(minVal), 1e-6);
                
                for (let i = 0; i < data.length; i++) {
                    const x = offsetX + (width * i / (data.length - 1));
                    const y = offsetY + height/2 - (data[i] / range) * (height/4);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                // ç¹ªè£½æ¨™ç±¤
                ctx.fillStyle = colors[idx % colors.length];
                ctx.font = '12px Arial';
                ctx.fillText(`${labels[idx]}: ${data[data.length-1]?.toFixed(3) || 0}`, 10, 20 + idx * 15);
            });
            
            // ç¹ªè£½æ™‚é–“è»¸
            ctx.fillStyle = '#000';
            ctx.font = '10px Arial';
            const timeRange = waveforms.time[waveforms.time.length-1] - waveforms.time[0];
            ctx.fillText(`æ™‚é–“: ${timeRange.toFixed(1)}Âµs`, width - 100, height + 45);
        }
    </script>
</body>
</html>