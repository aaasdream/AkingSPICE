<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>ExplicitStateSolveræ·±åº¦å•é¡Œåˆ†æ</title>
  <style>
    body {
      font-family: Arial;
      padding: 20px;
      background: #1a1a1a;
      color: white;
    }

    .container {
      max-width: 1000px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 10px;
    }

    #log {
      height: 600px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.6);
      padding: 15px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      margin-top: 20px;
    }

    .success {
      color: #27ae60;
    }

    .error {
      color: #e74c3c;
    }

    .warning {
      color: #f39c12;
    }

    .info {
      color: #3498db;
    }

    .matrix {
      color: #9b59b6;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>ğŸ” ExplicitStateSolveræ·±åº¦å•é¡Œåˆ†æ</h1>
    <p>ğŸ’” æ‰¾å‡ºç‚ºä»€éº¼åŸºæœ¬é›»è·¯éƒ½ç„¡æ³•æ­£å¸¸å·¥ä½œ</p>

    <div id="log">é–‹å§‹æ·±åº¦å•é¡Œåˆ†æ...<br></div>
  </div>

  <script src="./lib-dist/AkingSPICE.umd.js"></script>

  <script>
    function log(message, type = 'info') {
      const colors = {
        'success': '#27ae60',
        'error': '#e74c3c',
        'warning': '#f39c12',
        'info': '#3498db',
        'matrix': '#9b59b6'
      };

      const time = new Date().toLocaleTimeString();
      const logElement = document.getElementById('log');
      logElement.innerHTML += `<span style="color: ${colors[type]};">[${time}] ${message}</span><br>`;
      logElement.scrollTop = logElement.scrollHeight;
    }

    document.addEventListener('DOMContentLoaded', function () {
      log('ğŸ” é–‹å§‹ExplicitStateSolveræ·±åº¦å•é¡Œåˆ†æ', 'success');

      if (!window.AkingSPICE) {
        log('âŒ AkingSPICEæœªè¼‰å…¥', 'error');
        return;
      }

      const { VoltageSource, Resistor, ExplicitStateSolver } = window.AkingSPICE;

      try {
        log('ğŸ’” å•é¡Œ1: åŸºæœ¬é›»è·¯é›»å£“ç‚º0 - æ‰‹å‹•é©—è­‰ç†è«–', 'error');

        // æœ€ç°¡å–®çš„é›»è·¯: 5V + 10Î©
        // ç†è«–: V_node1 = 5V, I = 5V/10Î© = 0.5A, P = 2.5W
        log('ğŸ“‹ ç†è«–è¨ˆç®—:', 'info');
        log('  é›»è·¯: 5Vé›»æº + 10Î©é›»é˜» (ä¸¦è¯)', 'info');
        log('  ç†è«–ç¯€é»é›»å£“: V1 = 5.0V', 'success');
        log('  ç†è«–é›»æµ: I = 5V/10Î© = 0.5A', 'success');
        log('  ç†è«–åŠŸç‡: P = 5V * 0.5A = 2.5W', 'success');

        // å‰µå»ºçµ„ä»¶
        const v1 = new VoltageSource('V1', [1, 0], 5.0);
        const r1 = new Resistor('R1', [1, 0], 10.0);

        log('ğŸ”§ æª¢æŸ¥çµ„ä»¶å‰µå»º:', 'info');
        log(`  VoltageSource: name=${v1.name}, nodes=[${v1.nodes}], value=${v1.value}`, 'info');
        log(`  Resistor: name=${r1.name}, nodes=[${r1.nodes}], value=${r1.value}`, 'info');

        // æª¢æŸ¥çµ„ä»¶æ–¹æ³•
        log('ğŸ” æª¢æŸ¥çµ„ä»¶æ–¹æ³•:', 'info');
        log(`  VoltageSource.stamp: ${typeof v1.stamp}`, 'info');
        log(`  Resistor.stamp: ${typeof r1.stamp}`, 'info');
        log(`  Resistor.getResistance: ${typeof r1.getResistance}`, 'info');

        if (r1.getResistance) {
          log(`  å¯¦éš›é›»é˜»å€¼: ${r1.getResistance()}Î©`, 'info');
        }

        const components = [v1, r1];

        log('âš™ï¸ å‰µå»ºä¸¦åˆå§‹åŒ–æ±‚è§£å™¨:', 'info');
        const solver = new ExplicitStateSolver();

        // åœ¨åˆå§‹åŒ–å‰æª¢æŸ¥æ±‚è§£å™¨
        log('ğŸ” æ±‚è§£å™¨åˆå§‹åŒ–å‰ç‹€æ…‹:', 'info');
        log(`  preprocessor: ${typeof solver.preprocessor}`, 'info');
        log(`  linearSolver: ${typeof solver.linearSolver}`, 'info');

        // åˆå§‹åŒ–æ±‚è§£å™¨
        log('ğŸš€ åŸ·è¡Œæ±‚è§£å™¨åˆå§‹åŒ–...', 'info');
        const initResult = solver.initialize(components, 1e-3, {
          debug: true,
          maxIterations: 10,
          tolerance: 1e-2
        });

        log('âœ… åˆå§‹åŒ–å®Œæˆï¼Œæª¢æŸ¥å…§éƒ¨ç‹€æ…‹:', 'success');

        // æª¢æŸ¥é›»è·¯æ•¸æ“š
        if (solver.circuitData) {
          const cd = solver.circuitData;
          log('ğŸ“Š é›»è·¯æ•¸æ“š:', 'info');
          log(`  ç¯€é»æ•¸: ${cd.nodeCount}`, 'info');
          log(`  çµ„ä»¶æ•¸: ${cd.componentCount}`, 'info');
          log(`  ç‹€æ…‹è®Šé‡æ•¸: ${cd.stateCount}`, 'info');

          if (cd.nodes) {
            log(`  ç¯€é»åˆ—è¡¨: [${cd.nodes.join(', ')}]`, 'info');
          }

          if (cd.nodeMap) {
            log('  ç¯€é»æ˜ å°„:', 'info');
            for (const node in cd.nodeMap) {
              log(`    ç¯€é»${node} -> ç´¢å¼•${cd.nodeMap[node]}`, 'info');
            }
          }
        }

        // æª¢æŸ¥GçŸ©é™£
        if (solver.gMatrix) {
          const G = solver.gMatrix;
          log('ğŸ§® GçŸ©é™£ (å°ç´çŸ©é™£):', 'matrix');
          log(`  å°ºå¯¸: ${G.rows}x${G.cols}`, 'matrix');

          if (G.rows <= 5) {
            log('  GçŸ©é™£å…§å®¹:', 'matrix');
            for (let i = 0; i < G.rows; i++) {
              let row = '    [';
              for (let j = 0; j < G.cols; j++) {
                const val = G.get(i, j);
                row += val.toExponential(2);
                if (j < G.cols - 1) row += ', ';
              }
              row += ']';
              log(row, 'matrix');
            }
          }

          // æª¢æŸ¥å°è§’ç·šå…ƒç´ 
          log('  å°è§’ç·šå…ƒç´ æª¢æŸ¥:', 'matrix');
          for (let i = 0; i < G.rows; i++) {
            const diag = G.get(i, i);
            log(`    G[${i},${i}] = ${diag.toExponential(3)}`, diag > 1e-10 ? 'success' : 'error');
          }
        }

        // æª¢æŸ¥å³å´å‘é‡
        if (solver.rhsVector) {
          const rhs = solver.rhsVector;
          log('ğŸ“ å³å´å‘é‡ (é›»æµæº):', 'matrix');
          log(`  é•·åº¦: ${rhs.length}`, 'matrix');

          if (rhs.length <= 10) {
            let rhsStr = '  [';
            for (let i = 0; i < rhs.length; i++) {
              rhsStr += rhs[i].toExponential(2);
              if (i < rhs.length - 1) rhsStr += ', ';
            }
            rhsStr += ']';
            log(rhsStr, 'matrix');
          }
        }

        log('âš¡ åŸ·è¡Œç¬¬ä¸€æ­¥æ±‚è§£...', 'info');
        const result = solver.step();

        log('ğŸ“Š æ±‚è§£çµæœåˆ†æ:', 'info');
        log(`  çµæœé¡å‹: ${typeof result}`, 'info');

        if (result.nodeVoltages) {
          log('  ç¯€é»é›»å£“:', 'info');
          for (const node in result.nodeVoltages) {
            const voltage = result.nodeVoltages[node];
            log(`    ç¯€é»${node}: ${voltage.toExponential(6)}V`, Math.abs(voltage) > 1e-6 ? 'success' : 'error');
          }

          // æ‰‹å‹•é©—è­‰æ­å§†å®šå¾‹
          const v_node1 = result.nodeVoltages[1] || 0;
          if (Math.abs(v_node1) < 1e-6) {
            log('âŒ è‡´å‘½å•é¡Œ: ç¯€é»1é›»å£“å¹¾ä¹ç‚º0!', 'error');
            log('ğŸ’¡ å¯èƒ½åŸå› :', 'warning');
            log('   1. GçŸ©é™£æ§‹å»ºéŒ¯èª¤', 'warning');
            log('   2. é›»å£“æºstampéŒ¯èª¤', 'warning');
            log('   3. ç·šæ€§æ±‚è§£å™¨å•é¡Œ', 'warning');
            log('   4. ç¯€é»æ˜ å°„éŒ¯èª¤', 'warning');
          } else {
            const calculated_current = v_node1 / 10.0;
            const calculated_power = v_node1 * calculated_current;
            log('âœ… é›»è·¯è¨ˆç®—æ­£ç¢º:', 'success');
            log(`   ç¯€é»1é›»å£“: ${v_node1.toFixed(3)}V`, 'success');
            log(`   è¨ˆç®—é›»æµ: ${calculated_current.toFixed(3)}A`, 'success');
            log(`   è¨ˆç®—åŠŸç‡: ${calculated_power.toFixed(3)}W`, 'success');
          }
        } else {
          log('âŒ è‡´å‘½éŒ¯èª¤: çµæœä¸­æ²’æœ‰ç¯€é»é›»å£“!', 'error');
        }

        // æ‰‹å‹•æ¸¬è©¦ç·šæ€§æ±‚è§£å™¨
        log('ğŸ§ª æ‰‹å‹•æ¸¬è©¦ç·šæ€§æ±‚è§£å™¨:', 'info');

        if (solver.gMatrix && solver.rhsVector && solver.linearSolver) {
          try {
            log('  æ¸¬è©¦ç›´æ¥æ±‚è§£å™¨...', 'info');
            const manualSolution = solver.linearSolver.directSolve(solver.gMatrix, solver.rhsVector);
            log('  ç›´æ¥æ±‚è§£çµæœ:', 'success');
            for (let i = 0; i < manualSolution.length; i++) {
              log(`    x[${i}] = ${manualSolution[i].toExponential(6)}`, 'success');
            }
          } catch (directError) {
            log(`  ç›´æ¥æ±‚è§£å¤±æ•—: ${directError.message}`, 'error');
          }
        }

        log('ğŸ¯ å•é¡Œè¨ºæ–·å®Œæˆ', 'success');

      } catch (error) {
        log(`âŒ è¨ºæ–·éç¨‹éŒ¯èª¤: ${error.message}`, 'error');
        console.error('å®Œæ•´éŒ¯èª¤:', error);

        if (error.stack) {
          const stackLines = error.stack.split('\n').slice(0, 10);
          log('éŒ¯èª¤å †ç–Š:', 'error');
          stackLines.forEach((line, i) => {
            log(`  ${i + 1}. ${line.trim()}`, 'error');
          });
        }
      }
    });

  </script>
</body>

</html>