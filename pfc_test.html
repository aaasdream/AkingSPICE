<!DOCTYPE html>
<html lang="zh-TW">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PFCæ§åˆ¶ç³»çµ±æ¸¬è©¦</title>
  <style>
    body {
      font-family: 'Microsoft YaHei', Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      min-height: 100vh;
    }

    .test-container {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 30px;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .test-result {
      margin: 10px 0;
      padding: 15px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.1);
    }

    .test-passed {
      background: rgba(76, 175, 80, 0.3);
    }

    .test-failed {
      background: rgba(244, 67, 54, 0.3);
    }

    .test-running {
      background: rgba(255, 193, 7, 0.3);
    }

    .progress-bar {
      width: 100%;
      height: 20px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      overflow: hidden;
      margin: 20px 0;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4CAF50, #2196F3);
      width: 0%;
      transition: width 0.5s ease;
    }
  </style>
</head>

<body>
  <div class="test-container">
    <h1>ğŸ§ª PFCæ§åˆ¶ç³»çµ±è‡ªå‹•æ¸¬è©¦</h1>
    <p>æ¸¬è©¦åŠŸç‡å› æ•¸æ ¡æ­£é›»è·¯çš„æ§åˆ¶ç®—æ³•å’Œæ€§èƒ½</p>

    <div class="progress-bar">
      <div class="progress-fill" id="progressBar"></div>
    </div>

    <div id="testResults"></div>

    <button onclick="startPFCTests()"
      style="padding: 15px 30px; background: #4CAF50; color: white; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; margin-top: 20px;">é–‹å§‹æ¸¬è©¦</button>
  </div>

  <script type="module">
    // PFCæ§åˆ¶ç³»çµ±æ¸¬è©¦å®¢æˆ¶ç«¯ (ç°¡åŒ–ç‰ˆ)
    class PFCTestClient {
      constructor() {
        this.akingModules = null;
        this.pfcSystem = null;
        this.testResults = [];
        this.currentTest = 0;
        this.totalTests = 8;
      }

      displayResult(testName, passed, details = '', error = '') {
        const resultsDiv = document.getElementById('testResults');
        const resultDiv = document.createElement('div');
        resultDiv.className = `test-result ${passed ? 'test-passed' : 'test-failed'}`;

        const status = passed ? 'âœ…' : 'âŒ';
        const time = Date.now();

        resultDiv.innerHTML = `
          <strong>${status} ${testName}</strong><br>
          ${details ? `è©³æƒ…: ${details}<br>` : ''}
          ${error ? `éŒ¯èª¤: ${error}<br>` : ''}
          <small>æ™‚é–“: ${new Date().toLocaleTimeString()}</small>
        `;

        resultsDiv.appendChild(resultDiv);

        // æ›´æ–°é€²åº¦æ¢
        this.currentTest++;
        const progress = (this.currentTest / this.totalTests) * 100;
        document.getElementById('progressBar').style.width = `${progress}%`;
      }

      async startTests() {
        document.getElementById('testResults').innerHTML = '';
        this.currentTest = 0;

        console.log('ğŸš€ é–‹å§‹PFCæ§åˆ¶ç³»çµ±æ¸¬è©¦');

        const tests = [
          { name: 'AkingSPICEæ¨¡çµ„è¼‰å…¥', func: () => this.testModuleLoading() },
          { name: 'PFCé›»è·¯å‰µå»º', func: () => this.testPFCCircuitCreation() },
          { name: 'PWMæ§åˆ¶ç®—æ³•', func: () => this.testPWMControl() },
          { name: 'PIæ§åˆ¶å™¨', func: () => this.testPIController() },
          { name: 'åŠŸç‡å› æ•¸è¨ˆç®—', func: () => this.testPowerFactorCalculation() },
          { name: 'é›»è·¯ç©©å®šæ€§', func: () => this.testCircuitStability() },
          { name: 'å‹•æ…‹éŸ¿æ‡‰', func: () => this.testDynamicResponse() },
          { name: 'æ•ˆç‡åˆ†æ', func: () => this.testEfficiencyAnalysis() }
        ];

        for (const test of tests) {
          try {
            console.log(`åŸ·è¡Œæ¸¬è©¦: ${test.name}`);
            const result = await test.func();
            this.displayResult(
              test.name,
              result.passed,
              result.details ? JSON.stringify(result.details) : '',
              result.error || ''
            );

            // æ·»åŠ å°å»¶é²è®“ç”¨æˆ¶çœ‹åˆ°æ¸¬è©¦é€²å±•
            await new Promise(resolve => setTimeout(resolve, 500));
          } catch (error) {
            this.displayResult(test.name, false, '', error.message);
          }
        }

        console.log('âœ… PFCæ¸¬è©¦å®Œæˆ');
      }

      async testModuleLoading() {
        try {
          this.akingModules = await import('./lib-dist/AkingSPICE.es.js');

          const requiredModules = ['AkingSPICE', 'ExplicitStateSolver', 'VoltageSource',
            'Resistor', 'Capacitor', 'Inductor', 'Diode'];
          const missing = requiredModules.filter(module => !this.akingModules[module]);

          if (missing.length > 0) {
            return { passed: false, error: `ç¼ºå°‘æ¨¡çµ„: ${missing.join(', ')}` };
          }

          return { passed: true, details: { modulesCount: Object.keys(this.akingModules).length } };

        } catch (error) {
          return { passed: false, error: error.message };
        }
      }

      async testPFCCircuitCreation() {
        try {
          if (!this.akingModules) {
            return { passed: false, error: 'æ¨¡çµ„æœªè¼‰å…¥' };
          }

          const { VoltageSource, Resistor, Capacitor, Inductor, Diode, ExplicitStateSolver } = this.akingModules;

          // å‰µå»ºPFCé›»è·¯
          const components = [];

          // ACé›»å£“æº
          components.push(new VoltageSource('Vin', ['ac_in', 'gnd'], 311)); // 220V RMS

          // PFCé›»æ„Ÿ
          components.push(new Inductor('L1', ['ac_in', 'sw_node'], 1e-3)); // 1mH

          // é–‹é—œé›»é˜»
          components.push(new Resistor('Sw', ['sw_node', 'gnd'], 100));

          // æ•´æµäºŒæ¥µé«”
          components.push(new Diode('D1', ['sw_node', 'dc_bus']));

          // è¼¸å‡ºé›»å®¹
          components.push(new Capacitor('Cout', ['dc_bus', 'gnd'], 470e-6)); // 470ÂµF

          // è² è¼‰é›»é˜»
          components.push(new Resistor('Rload', ['dc_bus', 'gnd'], 160)); // 1kW @ 400V

          // å‰µå»ºæ±‚è§£å™¨
          const solver = new ExplicitStateSolver();
          await solver.initialize(components, 1e-6);

          // æ¸¬è©¦ä¸€æ­¥è¨ˆç®—
          const result = solver.step();

          solver.destroy();

          return {
            passed: true,
            details: {
              componentsCount: components.length,
              nodeVoltages: Object.keys(result.nodeVoltages || {}).length
            }
          };

        } catch (error) {
          return { passed: false, error: error.message };
        }
      }

      async testPWMControl() {
        try {
          // æ¸¬è©¦PWMæ§åˆ¶ç®—æ³•
          const pwmController = {
            switchFreq: 50000,
            targetVout: 400,
            kp: 0.1,

            calculateDuty: function (vout, time) {
              const error = this.targetVout - vout;
              let duty = 0.5 + error * this.kp * 0.001;
              return Math.max(0.1, Math.min(0.9, duty));
            }
          };

          // æ¸¬è©¦ä¸åŒè¼¸å‡ºé›»å£“ä¸‹çš„å ç©ºæ¯”
          const testCases = [
            { vout: 350, expectedRange: [0.5, 0.9] },
            { vout: 400, expectedRange: [0.3, 0.7] },
            { vout: 450, expectedRange: [0.1, 0.5] }
          ];

          for (const testCase of testCases) {
            const duty = pwmController.calculateDuty(testCase.vout, 0);

            if (duty < testCase.expectedRange[0] || duty > testCase.expectedRange[1]) {
              return {
                passed: false,
                error: `PWMå ç©ºæ¯”ç•°å¸¸: Vout=${testCase.vout}V, Duty=${duty.toFixed(3)}`
              };
            }
          }

          return {
            passed: true,
            details: {
              testCases: testCases.length,
              switchFreq: pwmController.switchFreq
            }
          };

        } catch (error) {
          return { passed: false, error: error.message };
        }
      }

      async testPIController() {
        try {
          // æ¸¬è©¦PIæ§åˆ¶å™¨
          class PIController {
            constructor(kp, ki, dt) {
              this.kp = kp;
              this.ki = ki;
              this.dt = dt;
              this.integral = 0;
              this.lastError = 0;
            }

            update(setpoint, measurement) {
              const error = setpoint - measurement;
              this.integral += error * this.dt;

              // ç©åˆ†é™åˆ¶
              this.integral = Math.max(-1, Math.min(1, this.integral));

              const output = this.kp * error + this.ki * this.integral;
              this.lastError = error;

              return output;
            }

            reset() {
              this.integral = 0;
              this.lastError = 0;
            }
          }

          const pi = new PIController(0.1, 10, 1e-6);

          // æ¸¬è©¦éšèºéŸ¿æ‡‰
          let output = 350; // åˆå§‹è¼¸å‡ºé›»å£“
          const setpoint = 400; // ç›®æ¨™é›»å£“

          for (let i = 0; i < 1000; i++) {
            const control = pi.update(setpoint, output);
            // ç°¡åŒ–çš„ç³»çµ±éŸ¿æ‡‰ - æ›´å¼·çš„éŸ¿æ‡‰
            output += control * 0.05;
          }

          // æª¢æŸ¥æ˜¯å¦æ”¶æ–‚åˆ°è¨­å®šå€¼
          const steadyStateError = Math.abs(setpoint - output);

          if (steadyStateError > 5) {
            return {
              passed: false,
              error: `PIæ§åˆ¶å™¨æœªæ”¶æ–‚: èª¤å·®=${steadyStateError.toFixed(2)}V`
            };
          }

          return {
            passed: true,
            details: {
              finalOutput: output.toFixed(2),
              steadyStateError: steadyStateError.toFixed(2)
            }
          };

        } catch (error) {
          return { passed: false, error: error.message };
        }
      }

      async testPowerFactorCalculation() {
        try {
          // æ¸¬è©¦åŠŸç‡å› æ•¸è¨ˆç®—
          function calculatePowerFactor(vRMS, iRMS, realPower) {
            const apparentPower = vRMS * iRMS;
            if (apparentPower === 0) return 0;

            const pf = realPower / apparentPower;
            return Math.max(0, Math.min(1, pf));
          }

          const testCases = [
            { vRMS: 220, iRMS: 4.55, realPower: 1000, expected: 1.0 },
            { vRMS: 220, iRMS: 5.0, realPower: 1000, expected: 0.91 },
            { vRMS: 220, iRMS: 6.0, realPower: 1000, expected: 0.76 }
          ];

          for (const testCase of testCases) {
            const pf = calculatePowerFactor(testCase.vRMS, testCase.iRMS, testCase.realPower);
            const error = Math.abs(pf - testCase.expected);

            if (error > 0.05) {
              return {
                passed: false,
                error: `åŠŸç‡å› æ•¸è¨ˆç®—éŒ¯èª¤: æœŸæœ›=${testCase.expected}, å¯¦éš›=${pf.toFixed(3)}`
              };
            }
          }

          return {
            passed: true,
            details: { testCasesCount: testCases.length }
          };

        } catch (error) {
          return { passed: false, error: error.message };
        }
      }

      async testCircuitStability() {
        try {
          if (!this.akingModules) {
            return { passed: false, error: 'æ¨¡çµ„æœªè¼‰å…¥' };
          }

          const { VoltageSource, Resistor, Capacitor, Inductor, ExplicitStateSolver } = this.akingModules;

          // å‰µå»ºç°¡åŒ–çš„RLCé›»è·¯ä¾†æ¸¬è©¦æ•¸å€¼ç©©å®šæ€§
          const components = [
            new VoltageSource('V1', ['vin', 'gnd'], 400),
            new Resistor('R1', ['vin', 'vout'], 100),
            new Inductor('L1', ['vout', 'node2'], 1e-3),
            new Capacitor('C1', ['node2', 'gnd'], 470e-6)
          ];

          const solver = new ExplicitStateSolver();
          await solver.initialize(components, 1e-6);

          // é‹è¡Œ1000æ­¥æª¢æŸ¥ç©©å®šæ€§
          let maxVoltage = 0;
          let unstable = false;

          for (let i = 0; i < 1000; i++) {
            const result = solver.step();

            // æª¢æŸ¥æ‰€æœ‰ç¯€é»é›»å£“
            for (const [node, voltage] of Object.entries(result.nodeVoltages || {})) {
              if (isNaN(voltage) || Math.abs(voltage) > 10000) {
                unstable = true;
                break;
              }
              maxVoltage = Math.max(maxVoltage, Math.abs(voltage));
            }

            if (unstable) break;
          }

          solver.destroy();

          if (unstable) {
            return { passed: false, error: 'é›»è·¯æ•¸å€¼ä¸ç©©å®š' };
          }

          return {
            passed: true,
            details: {
              maxVoltage: maxVoltage.toFixed(2),
              simulationSteps: 1000
            }
          };

        } catch (error) {
          return { passed: false, error: error.message };
        }
      }

      async testDynamicResponse() {
        try {
          // æ¸¬è©¦ç³»çµ±å‹•æ…‹éŸ¿æ‡‰ç‰¹æ€§
          function simulateStepResponse(transferFunction, steps) {
            const response = [];
            let y = 0; // åˆå§‹è¼¸å‡º

            for (let i = 0; i < steps; i++) {
              // ç°¡åŒ–çš„ä¸€éšç³»çµ±ï¼šy(n+1) = a*y(n) + b*u(n)
              const u = i > 10 ? 1 : 0; // éšèºè¼¸å…¥
              y = transferFunction.a * y + transferFunction.b * u;
              response.push(y);
            }

            return response;
          }

          // PFCç³»çµ±è¿‘ä¼¼ç‚ºä¸€éšç³»çµ±
          const pfcSystem = { a: 0.99, b: 0.01 };
          const response = simulateStepResponse(pfcSystem, 100);

          // æª¢æŸ¥éŸ¿æ‡‰ç‰¹æ€§
          const finalValue = response[response.length - 1];
          const settlingTime = response.findIndex(val => Math.abs(val - finalValue) < 0.02 * finalValue);

          if (settlingTime === -1 || settlingTime > 95) {
            return {
              passed: false,
              error: `ç³»çµ±éŸ¿æ‡‰éæ…¢: å»ºç«‹æ™‚é–“=${settlingTime || 'N/A'}æ­¥`
            };
          }

          return {
            passed: true,
            details: {
              settlingTime: settlingTime,
              finalValue: finalValue.toFixed(3)
            }
          };

        } catch (error) {
          return { passed: false, error: error.message };
        }
      }

      async testEfficiencyAnalysis() {
        try {
          // æ¸¬è©¦æ•ˆç‡åˆ†æåŠŸèƒ½
          function calculateEfficiency(inputPower, outputPower, losses) {
            if (inputPower <= 0) return 0;

            const theoreticalOutput = inputPower - losses.switching - losses.conduction - losses.core;
            const efficiency = (theoreticalOutput / inputPower) * 100;

            return Math.max(0, Math.min(100, efficiency));
          }

          const testScenarios = [
            {
              inputPower: 1000,
              losses: { switching: 20, conduction: 15, core: 5 },
              expectedMin: 94
            },
            {
              inputPower: 500,
              losses: { switching: 15, conduction: 10, core: 3 },
              expectedMin: 92
            }
          ];

          for (const scenario of testScenarios) {
            const efficiency = calculateEfficiency(scenario.inputPower, 0, scenario.losses);

            if (efficiency < scenario.expectedMin) {
              return {
                passed: false,
                error: `æ•ˆç‡éä½: ${efficiency.toFixed(1)}% < ${scenario.expectedMin}%`
              };
            }
          }

          return {
            passed: true,
            details: {
              testScenarios: testScenarios.length,
              averageEfficiency: testScenarios.map(s =>
                calculateEfficiency(s.inputPower, 0, s.losses)
              ).reduce((a, b) => a + b) / testScenarios.length
            }
          };

        } catch (error) {
          return { passed: false, error: error.message };
        }
      }
    }

    // å…¨å±€è®Šé‡å’Œå‡½æ•¸
    let pfcTestClient = null;

    window.startPFCTests = async function () {
      if (!pfcTestClient) {
        pfcTestClient = new PFCTestClient();
      }
      await pfcTestClient.startTests();
    };

    // é é¢è¼‰å…¥å®Œæˆå¾Œåˆå§‹åŒ–ä¸¦è‡ªå‹•é–‹å§‹æ¸¬è©¦
    document.addEventListener('DOMContentLoaded', async () => {
      pfcTestClient = new PFCTestClient();
      console.log('PFCæ¸¬è©¦ç³»çµ±å·²åˆå§‹åŒ–');

      // è‡ªå‹•é–‹å§‹æ¸¬è©¦ï¼ˆå»¶é²1ç§’è®“é é¢å®Œå…¨è¼‰å…¥ï¼‰
      setTimeout(async () => {
        console.log('è‡ªå‹•é–‹å§‹PFCæ¸¬è©¦...');
        await startPFCTests();
      }, 1000);
    });
  </script>
</body>

</html>