<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é¡¯å¼æ±‚è§£å™¨æ•¸å€¼ç©©å®šæ€§æ¸¬è©¦</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        .test-section {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-left: 4px solid #007bff;
            border-radius: 5px;
        }
        .result {
            margin: 15px 0;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
        }
        .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        .info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .plot-container {
            margin: 20px 0;
            text-align: center;
        }
        canvas {
            border: 1px solid #ddd;
            max-width: 100%;
            height: auto;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background: #e9ecef;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”§ é¡¯å¼æ±‚è§£å™¨æ•¸å€¼ç©©å®šæ€§æ¸¬è©¦</h1>
        <p>æ­¤æ¸¬è©¦é©—è­‰ä¿®æ­£å¾Œçš„é¡¯å¼æ±‚è§£å™¨åœ¨è™•ç†RCé›»è·¯æ™‚çš„æ•¸å€¼ç©©å®šæ€§ï¼Œç‰¹åˆ¥æ˜¯ç§»é™¤å¤§å°ç´å¾Œçš„æ”¹é€²æ•ˆæœã€‚</p>

        <div class="controls">
            <label>æ™‚é–“æ­¥é•· (Âµs): </label>
            <input type="number" id="timeStep" value="1" min="0.1" max="100" step="0.1">
            
            <label>æ¨¡æ“¬æ™‚é–“ (ms): </label>
            <input type="number" id="simTime" value="5" min="1" max="50" step="1">
            
            <button onclick="runStabilityTest()">ğŸš€ åŸ·è¡Œç©©å®šæ€§æ¸¬è©¦</button>
            <button onclick="compareWithImplicit()">ğŸ“Š å°æ¯”éš±å¼æ±‚è§£å™¨</button>
            <button onclick="clearResults()">ğŸ§¹ æ¸…é™¤çµæœ</button>
        </div>

        <div class="test-section">
            <h2>æ¸¬è©¦é›»è·¯: ç°¡å–®RCé›»è·¯</h2>
            <p>VIN (5V DC) â†’ R1 (1kÎ©) â†’ C1 (1ÂµF) â†’ GND</p>
            <div id="circuitInfo" class="info result">
                ç†è«–æ™‚é–“å¸¸æ•¸ Ï„ = RC = 1kÎ© Ã— 1ÂµF = 1ms<br>
                ç†è«–ç©©æ…‹é›»å£“: 5V<br>
                ç†è«–å……é›»æ›²ç·š: Vc(t) = 5 Ã— (1 - e^(-t/Ï„))
            </div>
        </div>

        <div class="test-section">
            <h2>ç©©å®šæ€§æ¸¬è©¦çµæœ</h2>
            <div id="testResults"></div>
            
            <div class="plot-container">
                <canvas id="plotCanvas" width="800" height="400"></canvas>
            </div>
        </div>

        <div class="test-section">
            <h2>æ•¸å€¼ç©©å®šæ€§åˆ†æ</h2>
            <div id="stabilityAnalysis"></div>
        </div>
    </div>

    <script type="module">
        import { AkingSPICE } from './lib-dist/AkingSPICE.es.js';

        let testResults = [];
        let canvas, ctx;

        window.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById('plotCanvas');
            ctx = canvas.getContext('2d');
            clearCanvas();
        });

        window.runStabilityTest = async function() {
            const timeStepUs = parseFloat(document.getElementById('timeStep').value);
            const simTimeMs = parseFloat(document.getElementById('simTime').value);
            
            const timeStep = timeStepUs * 1e-6;  // è½‰æ›ç‚ºç§’
            const totalTime = simTimeMs * 1e-3;   // è½‰æ›ç‚ºç§’
            
            const resultsDiv = document.getElementById('testResults');
            const analysisDiv = document.getElementById('stabilityAnalysis');
            
            resultsDiv.innerHTML = '<div class="info result">æ­£åœ¨åŸ·è¡Œæ¸¬è©¦...</div>';
            
            try {
                // å‰µå»ºæ¸¬è©¦é›»è·¯
                const spice = new AkingSPICE();
                
                // ç°¡å–®RCé›»è·¯: VIN(5V) - R1(1k) - C1(1Âµ) - GND
                spice.addVoltageSource('VIN', ['n1', '0'], 5);
                spice.addResistor('R1', ['n1', 'n2'], 1000);
                spice.addCapacitor('C1', ['n2', '0'], 1e-6, { ic: 0 });
                
                console.log('ğŸ§ª é–‹å§‹é¡¯å¼æ±‚è§£å™¨ç©©å®šæ€§æ¸¬è©¦');
                console.log(`åƒæ•¸: dt=${timeStep*1e6}Âµs, ç¸½æ™‚é–“=${totalTime*1e3}ms`);
                
                // ä½¿ç”¨é¡¯å¼æ±‚è§£å™¨
                spice.useExplicitSolver();
                spice.setTimeStep(timeStep);
                
                // åŸ·è¡Œæš«æ…‹åˆ†æ
                const startTime = performance.now();
                const result = await spice.transientAnalysis(totalTime, timeStep);
                const endTime = performance.now();
                
                if (result && result.timePoints && result.timePoints.length > 0) {
                    testResults = result;
                    
                    // åˆ†æçµæœ
                    const analysis = analyzeStability(result, totalTime);
                    
                    // é¡¯ç¤ºçµæœ
                    resultsDiv.innerHTML = `
                        <div class="success result">
                            âœ… æ¸¬è©¦æˆåŠŸå®Œæˆï¼<br>
                            æ¨¡æ“¬é»æ•¸: ${result.timePoints.length}<br>
                            è¨ˆç®—æ™‚é–“: ${(endTime - startTime).toFixed(2)}ms<br>
                            å¹³å‡æ¯æ­¥: ${((endTime - startTime) / result.timePoints.length).toFixed(3)}ms
                        </div>
                    `;
                    
                    // é¡¯ç¤ºç©©å®šæ€§åˆ†æ
                    displayStabilityAnalysis(analysis, analysisDiv);
                    
                    // ç¹ªåœ–
                    plotResults(result);
                    
                } else {
                    throw new Error('æ¨¡æ“¬çµæœç‚ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¢º');
                }
                
            } catch (error) {
                console.error('æ¸¬è©¦å¤±æ•—:', error);
                resultsDiv.innerHTML = `
                    <div class="error result">
                        âŒ æ¸¬è©¦å¤±æ•—: ${error.message}<br>
                        é€™å¯èƒ½è¡¨ç¤ºæ•¸å€¼ä¸ç©©å®šæˆ–å…¶ä»–éŒ¯èª¤ã€‚
                    </div>
                `;
                
                analysisDiv.innerHTML = `
                    <div class="warning result">
                        âš ï¸ ç”±æ–¼æ¸¬è©¦å¤±æ•—ï¼Œç„¡æ³•é€²è¡Œç©©å®šæ€§åˆ†æã€‚<br>
                        å»ºè­°: å˜—è©¦å¢å¤§æ™‚é–“æ­¥é•·æˆ–æª¢æŸ¥é›»è·¯å®šç¾©ã€‚
                    </div>
                `;
            }
        };

        function analyzeStability(result, totalTime) {
            const times = result.timePoints;
            const voltages = result.voltageData['n2'] || [];  // é›»å®¹é›»å£“
            
            if (!voltages || voltages.length === 0) {
                return { stable: false, reason: 'ç„¡é›»å£“æ•¸æ“š' };
            }
            
            // æª¢æŸ¥æ•¸å€¼ç©©å®šæ€§
            let hasNaN = false;
            let hasInfinite = false;
            let maxVoltage = -Infinity;
            let minVoltage = Infinity;
            let oscillations = 0;
            let lastSign = 0;
            
            for (let i = 0; i < voltages.length; i++) {
                const v = voltages[i];
                
                if (isNaN(v)) hasNaN = true;
                if (!isFinite(v)) hasInfinite = true;
                
                maxVoltage = Math.max(maxVoltage, v);
                minVoltage = Math.min(minVoltage, v);
                
                // æª¢æ¸¬æŒ¯ç›ª (ç›¸é„°é»æ–œç‡è®Šè™Ÿ)
                if (i > 0) {
                    const slope = voltages[i] - voltages[i-1];
                    const sign = Math.sign(slope);
                    if (sign !== 0 && lastSign !== 0 && sign !== lastSign) {
                        oscillations++;
                    }
                    lastSign = sign;
                }
            }
            
            // ç†è«–å€¼åˆ†æ
            const R = 1000;  // 1kÎ©
            const C = 1e-6;  // 1ÂµF
            const timeConstant = R * C;  // 1ms
            const theoreticalFinal = 5.0;  // 5V
            
            const finalVoltage = voltages[voltages.length - 1];
            const settlingTime = findSettlingTime(times, voltages, theoreticalFinal);
            
            return {
                stable: !hasNaN && !hasInfinite && Math.abs(finalVoltage) < 100,
                hasNaN,
                hasInfinite,
                maxVoltage,
                minVoltage,
                oscillations,
                finalVoltage,
                theoreticalFinal,
                error: Math.abs(finalVoltage - theoreticalFinal),
                relativeError: Math.abs(finalVoltage - theoreticalFinal) / theoreticalFinal * 100,
                settlingTime,
                theoreticalSettlingTime: timeConstant * 4,  // 4Ï„ = 99.3% ç©©å®š
                timeConstant
            };
        }

        function findSettlingTime(times, voltages, target, tolerance = 0.02) {
            // æ‰¾åˆ°é›»å£“ç©©å®šåœ¨ç›®æ¨™å€¼Â±2%å…§çš„æ™‚é–“
            const upperBound = target * (1 + tolerance);
            const lowerBound = target * (1 - tolerance);
            
            for (let i = voltages.length - 1; i >= 0; i--) {
                if (voltages[i] < lowerBound || voltages[i] > upperBound) {
                    return i < times.length - 1 ? times[i + 1] : times[times.length - 1];
                }
            }
            return times[0];  // å¦‚æœä¸€é–‹å§‹å°±ç©©å®š
        }

        function displayStabilityAnalysis(analysis, div) {
            let html = '';
            
            if (analysis.stable) {
                html += '<div class="success result">âœ… æ•¸å€¼ç©©å®š - æœªæª¢æ¸¬åˆ°ç™¼æ•£æˆ–ç•°å¸¸å€¼</div>';
            } else {
                html += '<div class="error result">âŒ æ•¸å€¼ä¸ç©©å®šæª¢æ¸¬</div>';
            }
            
            html += `<div class="info result">
                ğŸ“Š æ•¸å€¼çµ±è¨ˆ:<br>
                â€¢ æœ€çµ‚é›»å£“: ${analysis.finalVoltage.toFixed(4)}V (ç†è«–å€¼: ${analysis.theoreticalFinal}V)<br>
                â€¢ çµ•å°èª¤å·®: ${analysis.error.toFixed(4)}V<br>
                â€¢ ç›¸å°èª¤å·®: ${analysis.relativeError.toFixed(2)}%<br>
                â€¢ é›»å£“ç¯„åœ: ${analysis.minVoltage.toFixed(4)}V ~ ${analysis.maxVoltage.toFixed(4)}V<br>
                â€¢ æŒ¯ç›ªæ¬¡æ•¸: ${analysis.oscillations}<br>
                â€¢ ç©©å®šæ™‚é–“: ${(analysis.settlingTime * 1000).toFixed(2)}ms (ç†è«–: ${(analysis.theoreticalSettlingTime * 1000).toFixed(2)}ms)
            </div>`;
            
            if (analysis.hasNaN) {
                html += '<div class="error result">âŒ æª¢æ¸¬åˆ° NaN å€¼ - åš´é‡æ•¸å€¼éŒ¯èª¤</div>';
            }
            
            if (analysis.hasInfinite) {
                html += '<div class="error result">âŒ æª¢æ¸¬åˆ°ç„¡çª®å¤§å€¼ - æ•¸å€¼ç™¼æ•£</div>';
            }
            
            if (analysis.relativeError > 10) {
                html += '<div class="warning result">âš ï¸ ç›¸å°èª¤å·®éå¤§ (>10%) - å¯èƒ½éœ€è¦æ›´å°çš„æ™‚é–“æ­¥é•·</div>';
            } else if (analysis.relativeError > 5) {
                html += '<div class="warning result">âš ï¸ ç›¸å°èª¤å·®è¼ƒå¤§ (>5%) - å»ºè­°æª¢æŸ¥æ•¸å€¼ç²¾åº¦</div>';
            }
            
            if (analysis.oscillations > analysis.timePoints?.length / 10) {
                html += '<div class="warning result">âš ï¸ æª¢æ¸¬åˆ°éå¤šæŒ¯ç›ª - å¯èƒ½å­˜åœ¨æ•¸å€¼ä¸ç©©å®š</div>';
            }
            
            div.innerHTML = html;
        }

        function plotResults(result) {
            clearCanvas();
            
            const times = result.timePoints;
            const voltages = result.voltageData['n2'] || [];
            
            if (!times || !voltages || times.length === 0) return;
            
            const width = canvas.width;
            const height = canvas.height;
            const margin = 50;
            
            // è¨­ç½®åæ¨™ç³»
            const xMin = 0;
            const xMax = times[times.length - 1] * 1000;  // è½‰æ›ç‚ºms
            const yMin = 0;
            const yMax = 6;
            
            // ç¹ªè£½åº§æ¨™è»¸
            drawAxes(margin, width - margin, margin, height - margin, xMin, xMax, yMin, yMax);
            
            // ç¹ªè£½ç†è«–æ›²ç·š (ç¶ è‰²è™›ç·š)
            drawTheoreticalCurve(times, margin, width - margin, margin, height - margin, xMin, xMax, yMin, yMax);
            
            // ç¹ªè£½å¯¦éš›çµæœ (è—è‰²å¯¦ç·š)
            drawDataCurve(times, voltages, margin, width - margin, margin, height - margin, xMin, xMax, yMin, yMax, 'blue', 2);
            
            // æ·»åŠ åœ–ä¾‹
            drawLegend();
        }

        function drawAxes(x1, x2, y1, y2, xMin, xMax, yMin, yMax) {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x1, y2);
            ctx.lineTo(x2, y2);  // Xè»¸
            ctx.moveTo(x1, y1);
            ctx.lineTo(x1, y2);  // Yè»¸
            ctx.stroke();
            
            // æ¨™ç±¤
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('æ™‚é–“ (ms)', (x1 + x2) / 2, y2 + 30);
            
            ctx.save();
            ctx.translate(x1 - 30, (y1 + y2) / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('é›»å£“ (V)', 0, 0);
            ctx.restore();
            
            // åˆ»åº¦
            const xTicks = 5;
            const yTicks = 6;
            
            for (let i = 0; i <= xTicks; i++) {
                const x = x1 + (x2 - x1) * i / xTicks;
                const value = xMin + (xMax - xMin) * i / xTicks;
                ctx.beginPath();
                ctx.moveTo(x, y2);
                ctx.lineTo(x, y2 + 5);
                ctx.stroke();
                ctx.fillText(value.toFixed(1), x, y2 + 20);
            }
            
            for (let i = 0; i <= yTicks; i++) {
                const y = y2 - (y2 - y1) * i / yTicks;
                const value = yMin + (yMax - yMin) * i / yTicks;
                ctx.beginPath();
                ctx.moveTo(x1, y);
                ctx.lineTo(x1 - 5, y);
                ctx.stroke();
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(1), x1 - 10, y + 3);
            }
        }

        function drawTheoreticalCurve(times, x1, x2, y1, y2, xMin, xMax, yMin, yMax) {
            const timeConstant = 1e-3;  // 1ms
            const finalVoltage = 5.0;
            
            ctx.strokeStyle = '#28a745';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            
            let firstPoint = true;
            for (const t of times) {
                const theoretical = finalVoltage * (1 - Math.exp(-t / timeConstant));
                const x = x1 + (x2 - x1) * (t * 1000 - xMin) / (xMax - xMin);
                const y = y2 - (y2 - y1) * (theoretical - yMin) / (yMax - yMin);
                
                if (firstPoint) {
                    ctx.moveTo(x, y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawDataCurve(times, data, x1, x2, y1, y2, xMin, xMax, yMin, yMax, color, lineWidth) {
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            
            let firstPoint = true;
            for (let i = 0; i < Math.min(times.length, data.length); i++) {
                const x = x1 + (x2 - x1) * (times[i] * 1000 - xMin) / (xMax - xMin);
                const y = y2 - (y2 - y1) * (data[i] - yMin) / (yMax - yMin);
                
                if (firstPoint) {
                    ctx.moveTo(x, y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        }

        function drawLegend() {
            const x = canvas.width - 200;
            const y = 50;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(x, y, 180, 60);
            ctx.strokeStyle = '#ccc';
            ctx.strokeRect(x, y, 180, 60);
            
            // ç†è«–æ›²ç·š
            ctx.strokeStyle = '#28a745';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(x + 10, y + 20);
            ctx.lineTo(x + 40, y + 20);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('ç†è«–æ›²ç·š', x + 50, y + 25);
            
            // å¯¦éš›çµæœ
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + 10, y + 40);
            ctx.lineTo(x + 40, y + 40);
            ctx.stroke();
            
            ctx.fillText('é¡¯å¼æ±‚è§£å™¨', x + 50, y + 45);
        }

        function clearCanvas() {
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        window.compareWithImplicit = function() {
            alert('éš±å¼æ±‚è§£å™¨å°æ¯”åŠŸèƒ½å°‡åœ¨ä¸‹ä¸€éšæ®µå¯¦ç¾');
        };

        window.clearResults = function() {
            document.getElementById('testResults').innerHTML = '';
            document.getElementById('stabilityAnalysis').innerHTML = '';
            clearCanvas();
            testResults = [];
        };

    </script>
</body>
</html>