{"version":3,"file":"AkingSPICE.es.js","sources":["../src/components/base.js","../src/components/resistor.js","../src/components/capacitor.js","../src/components/inductor.js","../src/components/sources.js","../src/components/mosfet.js","../src/parser/netlist.js","../src/core/linalg.js","../src/core/mna.js","../src/analysis/transient.js","../src/analysis/dc.js","../src/core/solver.js","../src/components/threephase.js","../src/components/vcmosfet.js","../src/components/diode.js","../src/components/transformer.js"],"sourcesContent":["/**\r\n * 基礎元件類別 - 所有電路元件的抽象基類\r\n * \r\n * 這個基類定義了所有電路元件必須實現的介面，包括：\r\n * - 元件識別信息 (名稱、類型、節點)\r\n * - 參數管理 (值、溫度係數等)\r\n * - MNA印記方法介面\r\n * - 時域分析所需的歷史狀態管理\r\n */\r\n\r\nexport class BaseComponent {\r\n    /**\r\n     * @param {string} name 元件名稱 (如 'R1', 'C2')\r\n     * @param {string} type 元件類型 (如 'R', 'C', 'L', 'V', 'I')\r\n     * @param {string[]} nodes 連接節點列表\r\n     * @param {number|string} value 元件值或表達式\r\n     * @param {Object} params 額外參數\r\n     */\r\n    constructor(name, type, nodes, value, params = {}) {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.nodes = [...nodes]; // 複製節點陣列\r\n        this.rawValue = value;\r\n        this.params = { ...params };\r\n        \r\n        // 解析數值\r\n        this.value = this.parseValue(value);\r\n        \r\n        // 暫態分析相關\r\n        this.timeStep = null;\r\n        this.previousValues = new Map(); // 存儲歷史值\r\n        this.historyTerm = 0;\r\n        \r\n        // 操作點信息\r\n        this.operatingPoint = {\r\n            voltage: 0,\r\n            current: 0,\r\n            power: 0\r\n        };\r\n        \r\n        // 模型參數\r\n        this.temperature = params.temp || 27; // 攝氏度\r\n        this.isNonlinear = false;\r\n    }\r\n\r\n    /**\r\n     * 解析元件值，支援工程記號 (如 1K, 2.2u, 3.3m)\r\n     * @param {number|string} value 要解析的值\r\n     * @returns {number} 解析後的數值\r\n     */\r\n    parseValue(value) {\r\n        if (typeof value === 'number') {\r\n            return value;\r\n        }\r\n        \r\n        if (typeof value === 'string') {\r\n            // 移除空白，但保持大小寫敏感性用於區分 M/m\r\n            const trimmedValue = value.trim();\r\n            \r\n            // 工程記號對應表 (大小寫敏感)\r\n            const suffixes = {\r\n                'T': 1e12,   // Tera\r\n                'G': 1e9,    // Giga  \r\n                'MEG': 1e6,  // Mega (特殊處理，避免與 M 混淆)\r\n                'M': 1e6,    // Mega (大寫M = 百萬)\r\n                'K': 1e3,    // Kilo (大寫K)\r\n                'k': 1e3,    // Kilo (小寫k，也常用)\r\n                'm': 1e-3,   // milli (小寫m = 毫)\r\n                'u': 1e-6,   // micro (小寫u)\r\n                'µ': 1e-6,   // micro (μ符號)\r\n                'n': 1e-9,   // nano (小寫n)\r\n                'p': 1e-12,  // pico (小寫p)\r\n                'f': 1e-15   // femto (小寫f)\r\n            };\r\n            \r\n            // 特殊處理MEG (避免與單個M混淆)\r\n            if (trimmedValue.toUpperCase().endsWith('MEG')) {\r\n                const numPart = parseFloat(trimmedValue.slice(0, -3));\r\n                if (!isNaN(numPart)) {\r\n                    return numPart * 1e6;\r\n                }\r\n            }\r\n            \r\n            // 處理其他後綴 (保持大小寫敏感)\r\n            for (const [suffix, multiplier] of Object.entries(suffixes)) {\r\n                if (trimmedValue.endsWith(suffix)) {\r\n                    const numPart = parseFloat(trimmedValue.slice(0, -suffix.length));\r\n                    if (!isNaN(numPart)) {\r\n                        return numPart * multiplier;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // 如果沒有後綴，直接解析數字\r\n            const numValue = parseFloat(trimmedValue);\r\n            if (!isNaN(numValue)) {\r\n                return numValue;\r\n            }\r\n        }\r\n        \r\n        throw new Error(`Cannot parse value: ${value}`);\r\n    }\r\n\r\n    /**\r\n     * 檢查此元件是否需要額外的電流變數 (如電感、電壓源)\r\n     * @returns {boolean}\r\n     */\r\n    needsCurrentVariable() {\r\n        return this.type === 'L' || this.type === 'V' || this.type.includes('V');\r\n    }\r\n\r\n    /**\r\n     * 初始化暫態分析\r\n     * @param {number} timeStep 時間步長\r\n     */\r\n    initTransient(timeStep) {\r\n        this.timeStep = timeStep;\r\n        this.previousValues.clear();\r\n        this.historyTerm = 0;\r\n    }\r\n\r\n    /**\r\n     * 更新歷史狀態 (在每個時間步結束時調用)\r\n     * @param {Map<string, number>} nodeVoltages 節點電壓\r\n     * @param {Map<string, number>} branchCurrents 支路電流\r\n     */\r\n    updateHistory(nodeVoltages, branchCurrents) {\r\n        // 基類預設實現 - 子類應該覆蓋這個方法\r\n        const v1 = nodeVoltages.get(this.nodes[0]) || 0;\r\n        const v2 = nodeVoltages.get(this.nodes[1]) || 0;\r\n        const voltage = v1 - v2;\r\n        \r\n        this.previousValues.set('voltage', voltage);\r\n        this.operatingPoint.voltage = voltage;\r\n    }\r\n\r\n    /**\r\n     * 計算功耗\r\n     * @returns {number} 功耗 (瓦特)\r\n     */\r\n    calculatePower() {\r\n        return Math.abs(this.operatingPoint.voltage * this.operatingPoint.current);\r\n    }\r\n\r\n    /**\r\n     * 獲取元件信息字符串\r\n     * @returns {string}\r\n     */\r\n    toString() {\r\n        return `${this.name} (${this.type}): ${this.nodes.join('-')} = ${this.value}`;\r\n    }\r\n\r\n    /**\r\n     * 驗證元件的有效性\r\n     * @returns {boolean}\r\n     */\r\n    isValid() {\r\n        return this.name && this.type && this.nodes.length >= 2 && \r\n               !isNaN(this.value) && isFinite(this.value);\r\n    }\r\n\r\n    /**\r\n     * 克隆元件\r\n     * @returns {BaseComponent}\r\n     */\r\n    clone() {\r\n        // 對於具體的元件類型，使用正確的構造函數參數\r\n        if (this.constructor.name === 'Resistor' || \r\n            this.constructor.name === 'Capacitor' || \r\n            this.constructor.name === 'Inductor') {\r\n            return new this.constructor(this.name, this.nodes, this.rawValue, this.params);\r\n        } else if (this.constructor.name === 'VoltageSource' || \r\n                   this.constructor.name === 'CurrentSource') {\r\n            return new this.constructor(this.name, this.nodes, this.rawValue, this.params);\r\n        } else {\r\n            // 默認的BaseComponent構造函數\r\n            return new this.constructor(this.name, this.type, this.nodes, this.rawValue, this.params);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 序列化為JSON\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return {\r\n            name: this.name,\r\n            type: this.type,\r\n            nodes: this.nodes,\r\n            value: this.value,\r\n            rawValue: this.rawValue,\r\n            params: this.params\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 從JSON反序列化\r\n     * @param {Object} json JSON對象\r\n     * @returns {BaseComponent}\r\n     */\r\n    static fromJSON(json) {\r\n        return new BaseComponent(json.name, json.type, json.nodes, json.rawValue, json.params);\r\n    }\r\n}\r\n\r\n/**\r\n * 線性雙端元件基類\r\n * 提供電阻、電容、電感等線性元件的共同功能\r\n */\r\nexport class LinearTwoTerminal extends BaseComponent {\r\n    constructor(name, type, nodes, value, params = {}) {\r\n        super(name, type, nodes, value, params);\r\n        \r\n        if (nodes.length !== 2) {\r\n            throw new Error(`${type} ${name} must have exactly 2 nodes`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 獲取元件兩端的電壓\r\n     * @param {Map<string, number>} nodeVoltages 節點電壓映射\r\n     * @returns {number} 電壓差 V(n1) - V(n2)\r\n     */\r\n    getVoltage(nodeVoltages) {\r\n        const v1 = nodeVoltages.get(this.nodes[0]) || 0;\r\n        const v2 = nodeVoltages.get(this.nodes[1]) || 0;\r\n        return v1 - v2;\r\n    }\r\n}\r\n\r\n/**\r\n * 受控源基類\r\n * 為各種受控源 (VCVS, VCCS, CCVS, CCCS) 提供基礎架構\r\n */\r\nexport class ControlledSource extends BaseComponent {\r\n    /**\r\n     * @param {string} name 元件名稱\r\n     * @param {string} type 元件類型\r\n     * @param {string[]} outputNodes 輸出節點 [正, 負]\r\n     * @param {string[]} controlNodes 控制節點 [正, 負]\r\n     * @param {number} gainValue 增益值\r\n     * @param {Object} params 額外參數\r\n     */\r\n    constructor(name, type, outputNodes, controlNodes, gainValue, params = {}) {\r\n        // 合併輸出和控制節點\r\n        const allNodes = [...outputNodes, ...controlNodes];\r\n        super(name, type, allNodes, gainValue, params);\r\n        \r\n        this.outputNodes = [...outputNodes];\r\n        this.controlNodes = [...controlNodes];\r\n        \r\n        if (outputNodes.length !== 2 || controlNodes.length !== 2) {\r\n            throw new Error(`${type} ${name} must have 2 output nodes and 2 control nodes`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 獲取控制信號 (電壓或電流)\r\n     * @param {Map<string, number>} nodeVoltages 節點電壓\r\n     * @param {Map<string, number>} branchCurrents 支路電流\r\n     * @returns {number} 控制信號值\r\n     */\r\n    getControlSignal(nodeVoltages, branchCurrents) {\r\n        // 基類預設返回控制電壓\r\n        const vc1 = nodeVoltages.get(this.controlNodes[0]) || 0;\r\n        const vc2 = nodeVoltages.get(this.controlNodes[1]) || 0;\r\n        return vc1 - vc2;\r\n    }\r\n}","/**\r\n * 電阻元件模型\r\n * 實現線性電阻的所有功能，包括溫度係數和功率計算\r\n */\r\n\r\nimport { LinearTwoTerminal } from './base.js';\r\n\r\nexport class Resistor extends LinearTwoTerminal {\r\n    /**\r\n     * @param {string} name 電阻名稱 (如 'R1')\r\n     * @param {string[]} nodes 連接節點 [n1, n2]\r\n     * @param {number|string} resistance 電阻值 (歐姆)\r\n     * @param {Object} params 額外參數\r\n     */\r\n    constructor(name, nodes, resistance, params = {}) {\r\n        super(name, 'R', nodes, resistance, params);\r\n        \r\n        // 電阻特定參數\r\n        this.tc1 = params.tc1 || 0;      // 一次溫度係數 (1/°C)\r\n        this.tc2 = params.tc2 || 0;      // 二次溫度係數 (1/°C²)\r\n        this.tnom = params.tnom || 27;   // 標稱溫度 (°C)\r\n        this.powerRating = params.power || Infinity; // 額定功率 (W)\r\n        \r\n        // 計算當前溫度下的電阻值\r\n        this.updateTemperatureCoefficient();\r\n    }\r\n\r\n    /**\r\n     * 根據溫度更新電阻值\r\n     */\r\n    updateTemperatureCoefficient() {\r\n        const deltaT = this.temperature - this.tnom;\r\n        const tempFactor = 1 + this.tc1 * deltaT + this.tc2 * deltaT * deltaT;\r\n        this.actualValue = this.value * tempFactor;\r\n    }\r\n\r\n    /**\r\n     * 獲取當前工作溫度下的電阻值\r\n     * @returns {number} 實際電阻值 (歐姆)\r\n     */\r\n    getResistance() {\r\n        return this.actualValue || this.value;\r\n    }\r\n\r\n    /**\r\n     * 獲取電導值\r\n     * @returns {number} 電導值 (西門子)\r\n     */\r\n    getConductance() {\r\n        const resistance = this.getResistance();\r\n        if (resistance === 0) {\r\n            throw new Error(`Zero resistance in ${this.name}`);\r\n        }\r\n        return 1 / resistance;\r\n    }\r\n\r\n    /**\r\n     * 計算通過電阻的電流 (使用歐姆定律)\r\n     * @param {Map<string, number>} nodeVoltages 節點電壓\r\n     * @returns {number} 電流 (安培)，正值表示從n1流向n2\r\n     */\r\n    getCurrent(nodeVoltages) {\r\n        const voltage = this.getVoltage(nodeVoltages);\r\n        const current = voltage / this.getResistance();\r\n        this.operatingPoint.current = current;\r\n        return current;\r\n    }\r\n\r\n    /**\r\n     * 更新歷史狀態\r\n     * @param {Map<string, number>} nodeVoltages 節點電壓\r\n     * @param {Map<string, number>} branchCurrents 支路電流\r\n     */\r\n    updateHistory(nodeVoltages, branchCurrents) {\r\n        super.updateHistory(nodeVoltages, branchCurrents);\r\n        \r\n        // 計算並存儲電流\r\n        const current = this.getCurrent(nodeVoltages);\r\n        this.previousValues.set('current', current);\r\n        \r\n        // 計算功耗\r\n        this.operatingPoint.power = this.operatingPoint.voltage * current;\r\n    }\r\n\r\n    /**\r\n     * 檢查是否超過功率額定值\r\n     * @returns {boolean} 如果超過額定功率返回true\r\n     */\r\n    isOverPower() {\r\n        return this.operatingPoint.power > this.powerRating;\r\n    }\r\n\r\n    /**\r\n     * 獲取電阻器資訊\r\n     * @returns {Object} 詳細信息\r\n     */\r\n    getInfo() {\r\n        return {\r\n            ...super.toJSON(),\r\n            actualResistance: this.getResistance(),\r\n            conductance: this.getConductance(),\r\n            tc1: this.tc1,\r\n            tc2: this.tc2,\r\n            powerRating: this.powerRating,\r\n            operatingPoint: { ...this.operatingPoint },\r\n            overPower: this.isOverPower()\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 驗證電阻器參數\r\n     * @returns {boolean}\r\n     */\r\n    isValid() {\r\n        return super.isValid() && this.value > 0;\r\n    }\r\n\r\n    toString() {\r\n        const resistance = this.getResistance();\r\n        let resistanceStr;\r\n        \r\n        // 格式化電阻值顯示\r\n        if (resistance >= 1e6) {\r\n            resistanceStr = `${(resistance / 1e6).toFixed(2)}MΩ`;\r\n        } else if (resistance >= 1e3) {\r\n            resistanceStr = `${(resistance / 1e3).toFixed(2)}kΩ`;\r\n        } else {\r\n            resistanceStr = `${resistance.toFixed(2)}Ω`;\r\n        }\r\n        \r\n        return `${this.name}: ${this.nodes[0]}-${this.nodes[1]} ${resistanceStr}`;\r\n    }\r\n}\r\n\r\n/**\r\n * 可變電阻 (電位器) 模型\r\n */\r\nexport class Potentiometer extends Resistor {\r\n    /**\r\n     * @param {string} name 電位器名稱\r\n     * @param {string[]} nodes 連接節點 [端子1, 滑動端, 端子2]\r\n     * @param {number} totalResistance 總電阻值\r\n     * @param {number} position 滑動位置 (0-1)\r\n     * @param {Object} params 額外參數\r\n     */\r\n    constructor(name, nodes, totalResistance, position = 0.5, params = {}) {\r\n        // 電位器需要3個節點\r\n        if (nodes.length !== 3) {\r\n            throw new Error('Potentiometer must have exactly 3 nodes');\r\n        }\r\n        \r\n        super(name, [nodes[0], nodes[2]], totalResistance, params);\r\n        this.type = 'POT';\r\n        this.nodes = [...nodes]; // [端子1, 滑動端, 端子2]\r\n        this.position = Math.max(0, Math.min(1, position)); // 限制在0-1範圍\r\n        this.totalResistance = totalResistance;\r\n    }\r\n\r\n    /**\r\n     * 設置滑動位置\r\n     * @param {number} position 位置 (0-1)\r\n     */\r\n    setPosition(position) {\r\n        this.position = Math.max(0, Math.min(1, position));\r\n    }\r\n\r\n    /**\r\n     * 獲取上半段電阻值 (端子1到滑動端)\r\n     * @returns {number} 電阻值\r\n     */\r\n    getUpperResistance() {\r\n        const minRes = 1e-6; // 防止零電阻\r\n        return Math.max(minRes, this.totalResistance * this.position);\r\n    }\r\n\r\n    /**\r\n     * 獲取下半段電阻值 (滑動端到端子2)\r\n     * @returns {number} 電阻值\r\n     */\r\n    getLowerResistance() {\r\n        const minRes = 1e-6; // 防止零電阻\r\n        return Math.max(minRes, this.totalResistance * (1 - this.position));\r\n    }\r\n\r\n    toString() {\r\n        return `${this.name}: ${this.nodes[0]}-${this.nodes[1]}-${this.nodes[2]} ${this.totalResistance}Ω (pos: ${(this.position * 100).toFixed(1)}%)`;\r\n    }\r\n}","/**\r\n * 電容元件模型\r\n * 實現線性電容的所有功能，包括暫態分析的伴隨模型\r\n */\r\n\r\nimport { LinearTwoTerminal } from './base.js';\r\n\r\nexport class Capacitor extends LinearTwoTerminal {\r\n    /**\r\n     * @param {string} name 電容名稱 (如 'C1')\r\n     * @param {string[]} nodes 連接節點 [n1, n2]\r\n     * @param {number|string} capacitance 電容值 (法拉)\r\n     * @param {Object} params 額外參數\r\n     */\r\n    constructor(name, nodes, capacitance, params = {}) {\r\n        super(name, 'C', nodes, capacitance, params);\r\n        \r\n        // 電容特定參數\r\n        this.ic = params.ic || 0;        // 初始電壓 (V)\r\n        this.tc1 = params.tc1 || 0;      // 一次溫度係數\r\n        this.tc2 = params.tc2 || 0;      // 二次溫度係數\r\n        this.tnom = params.tnom || 27;   // 標稱溫度 (°C)\r\n        this.voltageRating = params.voltage || Infinity; // 額定電壓 (V)\r\n        \r\n        // 暫態分析相關\r\n        this.equivalentConductance = 0;  // 等效電導 G_eq = C/h\r\n        this.historyCurrentSource = 0;   // 歷史電流源 I_hist\r\n        \r\n        // 計算溫度修正後的電容值\r\n        this.updateTemperatureCoefficient();\r\n    }\r\n\r\n    /**\r\n     * 根據溫度更新電容值\r\n     */\r\n    updateTemperatureCoefficient() {\r\n        const deltaT = this.temperature - this.tnom;\r\n        const tempFactor = 1 + this.tc1 * deltaT + this.tc2 * deltaT * deltaT;\r\n        this.actualValue = this.value * tempFactor;\r\n    }\r\n\r\n    /**\r\n     * 獲取當前工作溫度下的電容值\r\n     * @returns {number} 實際電容值 (法拉)\r\n     */\r\n    getCapacitance() {\r\n        return this.actualValue || this.value;\r\n    }\r\n\r\n    /**\r\n     * 初始化暫態分析\r\n     * @param {number} timeStep 時間步長\r\n     */\r\n    initTransient(timeStep) {\r\n        super.initTransient(timeStep);\r\n        \r\n        const C = this.getCapacitance();\r\n        this.equivalentConductance = C / timeStep;\r\n        \r\n        // 初始條件：設置初始電壓\r\n        this.previousValues.set('voltage', this.ic);\r\n        this.historyCurrentSource = -this.equivalentConductance * this.ic;\r\n    }\r\n\r\n    /**\r\n     * 計算伴隨模型的歷史項\r\n     * 電容的伴隨模型：i_c(t) = C/h * [v(t) - v(t-h)] + i_hist\r\n     * 其中 i_hist = -C/h * v(t-h)\r\n     */\r\n    updateCompanionModel() {\r\n        if (!this.timeStep) return;\r\n        \r\n        const previousVoltage = this.previousValues.get('voltage') || 0;\r\n        this.historyCurrentSource = -this.equivalentConductance * previousVoltage;\r\n        this.historyTerm = this.historyCurrentSource;\r\n    }\r\n\r\n    /**\r\n     * 計算電容電流 i = C * dv/dt\r\n     * @param {Map<string, number>} nodeVoltages 節點電壓\r\n     * @returns {number} 電流 (安培)，正值表示從n1流向n2\r\n     */\r\n    getCurrent(nodeVoltages) {\r\n        const currentVoltage = this.getVoltage(nodeVoltages);\r\n        \r\n        if (!this.timeStep) {\r\n            // DC分析：電容視為開路\r\n            this.operatingPoint.current = 0;\r\n            return 0;\r\n        }\r\n        \r\n        const previousVoltage = this.previousValues.get('voltage') || 0;\r\n        const C = this.getCapacitance();\r\n        \r\n        // 數值微分：i = C * (v(t) - v(t-h)) / h\r\n        const current = C * (currentVoltage - previousVoltage) / this.timeStep;\r\n        this.operatingPoint.current = current;\r\n        return current;\r\n    }\r\n\r\n    /**\r\n     * 計算存儲的能量 E = 0.5 * C * V²\r\n     * @param {Map<string, number>} nodeVoltages 節點電壓\r\n     * @returns {number} 能量 (焦耳)\r\n     */\r\n    getStoredEnergy(nodeVoltages) {\r\n        const voltage = this.getVoltage(nodeVoltages);\r\n        const C = this.getCapacitance();\r\n        return 0.5 * C * voltage * voltage;\r\n    }\r\n\r\n    /**\r\n     * 更新歷史狀態\r\n     * @param {Map<string, number>} nodeVoltages 節點電壓\r\n     * @param {Map<string, number>} branchCurrents 支路電流\r\n     */\r\n    updateHistory(nodeVoltages, branchCurrents) {\r\n        super.updateHistory(nodeVoltages, branchCurrents);\r\n        \r\n        const voltage = this.getVoltage(nodeVoltages);\r\n        const current = this.getCurrent(nodeVoltages);\r\n        \r\n        // 🔥 關鍵修正：先為下一個時間步準備伴隨模型（基於當前歷史值）\r\n        this.updateCompanionModel();\r\n        \r\n        // 然後更新歷史值為當前值\r\n        this.previousValues.set('voltage', voltage);\r\n        this.previousValues.set('current', current);\r\n        \r\n        // 計算功耗 (對理想電容應該為0，但實際中可能有數值誤差)\r\n        this.operatingPoint.power = voltage * current;\r\n    }\r\n\r\n    /**\r\n     * 檢查是否超過電壓額定值\r\n     * @param {Map<string, number>} nodeVoltages 節點電壓\r\n     * @returns {boolean} 如果超過額定電壓返回true\r\n     */\r\n    isOverVoltage(nodeVoltages) {\r\n        const voltage = Math.abs(this.getVoltage(nodeVoltages));\r\n        return voltage > this.voltageRating;\r\n    }\r\n\r\n    /**\r\n     * 獲取電容器資訊\r\n     * @param {Map<string, number>} nodeVoltages 節點電壓\r\n     * @returns {Object} 詳細信息\r\n     */\r\n    getInfo(nodeVoltages = null) {\r\n        const info = {\r\n            ...super.toJSON(),\r\n            actualCapacitance: this.getCapacitance(),\r\n            ic: this.ic,\r\n            tc1: this.tc1,\r\n            tc2: this.tc2,\r\n            voltageRating: this.voltageRating,\r\n            operatingPoint: { ...this.operatingPoint }\r\n        };\r\n        \r\n        if (nodeVoltages) {\r\n            info.storedEnergy = this.getStoredEnergy(nodeVoltages);\r\n            info.overVoltage = this.isOverVoltage(nodeVoltages);\r\n        }\r\n        \r\n        if (this.timeStep) {\r\n            info.equivalentConductance = this.equivalentConductance;\r\n            info.historyCurrentSource = this.historyCurrentSource;\r\n        }\r\n        \r\n        return info;\r\n    }\r\n\r\n    /**\r\n     * 驗證電容器參數\r\n     * @returns {boolean}\r\n     */\r\n    isValid() {\r\n        return super.isValid() && this.value > 0;\r\n    }\r\n\r\n    toString() {\r\n        const capacitance = this.getCapacitance();\r\n        let capacitanceStr;\r\n        \r\n        // 格式化電容值顯示\r\n        if (capacitance >= 1e-3) {\r\n            capacitanceStr = `${(capacitance * 1e3).toFixed(2)}mF`;\r\n        } else if (capacitance >= 1e-6) {\r\n            capacitanceStr = `${(capacitance * 1e6).toFixed(2)}µF`;\r\n        } else if (capacitance >= 1e-9) {\r\n            capacitanceStr = `${(capacitance * 1e9).toFixed(2)}nF`;\r\n        } else if (capacitance >= 1e-12) {\r\n            capacitanceStr = `${(capacitance * 1e12).toFixed(2)}pF`;\r\n        } else {\r\n            capacitanceStr = `${capacitance.toExponential(2)}F`;\r\n        }\r\n        \r\n        let result = `${this.name}: ${this.nodes[0]}-${this.nodes[1]} ${capacitanceStr}`;\r\n        if (this.ic !== 0) {\r\n            result += ` IC=${this.ic}V`;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * 可變電容 (變容二極體或可調電容) 模型\r\n */\r\nexport class VariableCapacitor extends Capacitor {\r\n    /**\r\n     * @param {string} name 可變電容名稱\r\n     * @param {string[]} nodes 連接節點 [n1, n2]\r\n     * @param {number} minCapacitance 最小電容值\r\n     * @param {number} maxCapacitance 最大電容值\r\n     * @param {number} controlValue 控制值 (0-1 或電壓值)\r\n     * @param {Object} params 額外參數\r\n     */\r\n    constructor(name, nodes, minCapacitance, maxCapacitance, controlValue = 0.5, params = {}) {\r\n        const averageCapacitance = (minCapacitance + maxCapacitance) / 2;\r\n        super(name, nodes, averageCapacitance, params);\r\n        \r\n        this.type = 'VCAP';\r\n        this.minCapacitance = minCapacitance;\r\n        this.maxCapacitance = maxCapacitance;\r\n        this.controlValue = controlValue;\r\n        this.controlType = params.controlType || 'linear'; // 'linear' 或 'voltage'\r\n    }\r\n\r\n    /**\r\n     * 根據控制值計算當前電容值\r\n     * @returns {number} 當前電容值\r\n     */\r\n    getCapacitance() {\r\n        let ratio;\r\n        \r\n        if (this.controlType === 'voltage') {\r\n            // 基於電壓的控制 (如變容二極體)\r\n            const Vj = this.controlValue; // 反向偏壓\r\n            const C0 = this.maxCapacitance; // 零偏壓時的電容\r\n            const Vbi = 0.7; // 內建電位 (V)\r\n            const m = 0.5; // 分級係數\r\n            \r\n            // 變容二極體方程式: C = C0 / (1 - Vj/Vbi)^m\r\n            if (Vj < Vbi) {\r\n                ratio = C0 / Math.pow(1 - Vj/Vbi, m);\r\n                ratio = Math.max(this.minCapacitance, Math.min(this.maxCapacitance, ratio));\r\n            } else {\r\n                ratio = this.minCapacitance;\r\n            }\r\n        } else {\r\n            // 線性控制 (如可調電容)\r\n            const normalizedControl = Math.max(0, Math.min(1, this.controlValue));\r\n            ratio = this.minCapacitance + normalizedControl * (this.maxCapacitance - this.minCapacitance);\r\n        }\r\n        \r\n        // 應用溫度係數\r\n        const deltaT = this.temperature - this.tnom;\r\n        const tempFactor = 1 + this.tc1 * deltaT + this.tc2 * deltaT * deltaT;\r\n        \r\n        return ratio * tempFactor;\r\n    }\r\n\r\n    /**\r\n     * 設置控制值\r\n     * @param {number} value 控制值\r\n     */\r\n    setControlValue(value) {\r\n        this.controlValue = value;\r\n    }\r\n\r\n    toString() {\r\n        const capacitance = this.getCapacitance();\r\n        const minCap = this.minCapacitance * 1e12;\r\n        const maxCap = this.maxCapacitance * 1e12;\r\n        const currentCap = capacitance * 1e12;\r\n        \r\n        return `${this.name}: ${this.nodes[0]}-${this.nodes[1]} ${currentCap.toFixed(2)}pF (${minCap.toFixed(0)}-${maxCap.toFixed(0)}pF, ctrl=${this.controlValue})`;\r\n    }\r\n}","/**\r\n * 電感元件模型\r\n * 實現線性電感的所有功能，包括暫態分析的伴隨模型\r\n */\r\n\r\nimport { LinearTwoTerminal } from './base.js';\r\n\r\nexport class Inductor extends LinearTwoTerminal {\r\n    /**\r\n     * @param {string} name 電感名稱 (如 'L1')\r\n     * @param {string[]} nodes 連接節點 [n1, n2]\r\n     * @param {number|string} inductance 電感值 (亨利)\r\n     * @param {Object} params 額外參數\r\n     */\r\n    constructor(name, nodes, inductance, params = {}) {\r\n        super(name, 'L', nodes, inductance, params);\r\n        \r\n        // 電感特定參數\r\n        this.ic = params.ic || 0;        // 初始電流 (A)\r\n        this.resistance = params.r || 0; // 寄生電阻 (Ω)\r\n        this.tc1 = params.tc1 || 0;      // 一次溫度係數\r\n        this.tc2 = params.tc2 || 0;      // 二次溫度係數\r\n        this.tnom = params.tnom || 27;   // 標稱溫度 (°C)\r\n        this.currentRating = params.current || Infinity; // 額定電流 (A)\r\n        \r\n        // 暫態分析相關\r\n        this.equivalentResistance = 0;   // 等效電阻 R_eq = L/h\r\n        this.historyVoltageSource = 0;   // 歷史電壓源 V_hist\r\n        \r\n        // 電感需要電流變數\r\n        this.needsCurrentVar = true;\r\n        \r\n        // 🔥 新增：用於儲存耦合資訊\r\n        this.couplings = null;\r\n        \r\n        // 計算溫度修正後的電感值\r\n        this.updateTemperatureCoefficient();\r\n    }\r\n\r\n    /**\r\n     * 根據溫度更新電感值\r\n     */\r\n    updateTemperatureCoefficient() {\r\n        const deltaT = this.temperature - this.tnom;\r\n        const tempFactor = 1 + this.tc1 * deltaT + this.tc2 * deltaT * deltaT;\r\n        this.actualValue = this.value * tempFactor;\r\n    }\r\n\r\n    /**\r\n     * 獲取當前工作溫度下的電感值\r\n     * @returns {number} 實際電感值 (亨利)\r\n     */\r\n    getInductance() {\r\n        return this.actualValue || this.value;\r\n    }\r\n\r\n    /**\r\n     * 檢查此元件是否需要額外的電流變數\r\n     * @returns {boolean}\r\n     */\r\n    needsCurrentVariable() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * 初始化暫態分析\r\n     * @param {number} timeStep 時間步長\r\n     */\r\n    initTransient(timeStep) {\r\n        super.initTransient(timeStep);\r\n        \r\n        const L = this.getInductance();\r\n        this.equivalentResistance = L / timeStep;\r\n        \r\n        // 初始條件：設置初始電流\r\n        this.previousValues.set('current', this.ic);\r\n        this.historyVoltageSource = this.equivalentResistance * this.ic;\r\n    }\r\n\r\n    /**\r\n     * 計算伴隨模型的歷史項\r\n     * 電感的伴隨模型：v_L(t) = R_eq * i(t) + V_hist\r\n     * 其中 R_eq = L/h, V_hist = R_eq * i(t-h)\r\n     */\r\n    updateCompanionModel() {\r\n        if (!this.timeStep) return;\r\n        \r\n        const previousCurrent = this.previousValues.get('current') || 0;\r\n        this.historyVoltageSource = this.equivalentResistance * previousCurrent;\r\n        this.historyTerm = previousCurrent; // 用於MNA矩陣\r\n    }\r\n\r\n    /**\r\n     * 計算電感電壓 v = L * di/dt\r\n     * @param {number} current 當前電流\r\n     * @returns {number} 電壓 (伏特)\r\n     */\r\n    getVoltageFromCurrent(current) {\r\n        if (!this.timeStep) {\r\n            // DC分析：電感視為短路 (忽略寄生電阻)\r\n            return current * this.resistance;\r\n        }\r\n        \r\n        const previousCurrent = this.previousValues.get('current') || 0;\r\n        const L = this.getInductance();\r\n        \r\n        // 數值微分：v = L * (i(t) - i(t-h)) / h + R * i(t)\r\n        const diDt = (current - previousCurrent) / this.timeStep;\r\n        const voltage = L * diDt + this.resistance * current;\r\n        \r\n        this.operatingPoint.current = current;\r\n        this.operatingPoint.voltage = voltage;\r\n        \r\n        return voltage;\r\n    }\r\n\r\n    /**\r\n     * 計算存儲的磁能 E = 0.5 * L * I²\r\n     * @param {number} current 電流\r\n     * @returns {number} 能量 (焦耳)\r\n     */\r\n    getStoredEnergy(current) {\r\n        const L = this.getInductance();\r\n        return 0.5 * L * current * current;\r\n    }\r\n\r\n    /**\r\n     * 更新歷史狀態\r\n     * @param {Map<string, number>} nodeVoltages 節點電壓\r\n     * @param {Map<string, number>} branchCurrents 支路電流\r\n     */\r\n    updateHistory(nodeVoltages, branchCurrents) {\r\n        super.updateHistory(nodeVoltages, branchCurrents);\r\n        \r\n        const current = branchCurrents.get(this.name) || 0;\r\n        const voltage = this.getVoltageFromCurrent(current);\r\n        \r\n        // 🔥 關鍵修正：先為下一個時間步準備伴隨模型（基於當前歷史值）\r\n        this.updateCompanionModel();\r\n        \r\n        // 然後更新歷史值為當前值\r\n        this.previousValues.set('current', current);\r\n        this.previousValues.set('voltage', voltage);\r\n        \r\n        // 計算功耗 (理想電感功耗為0，但可能有寄生電阻)\r\n        this.operatingPoint.power = voltage * current;\r\n    }\r\n\r\n    /**\r\n     * 檢查是否超過電流額定值\r\n     * @param {number} current 電流\r\n     * @returns {boolean} 如果超過額定電流返回true\r\n     */\r\n    isOverCurrent(current) {\r\n        return Math.abs(current) > this.currentRating;\r\n    }\r\n\r\n    /**\r\n     * 獲取電感器資訊\r\n     * @param {number} current 當前電流\r\n     * @returns {Object} 詳細信息\r\n     */\r\n    getInfo(current = null) {\r\n        const info = {\r\n            ...super.toJSON(),\r\n            actualInductance: this.getInductance(),\r\n            ic: this.ic,\r\n            resistance: this.resistance,\r\n            tc1: this.tc1,\r\n            tc2: this.tc2,\r\n            currentRating: this.currentRating,\r\n            operatingPoint: { ...this.operatingPoint }\r\n        };\r\n        \r\n        if (current !== null) {\r\n            info.storedEnergy = this.getStoredEnergy(current);\r\n            info.overCurrent = this.isOverCurrent(current);\r\n        }\r\n        \r\n        if (this.timeStep) {\r\n            info.equivalentResistance = this.equivalentResistance;\r\n            info.historyVoltageSource = this.historyVoltageSource;\r\n        }\r\n        \r\n        return info;\r\n    }\r\n\r\n    /**\r\n     * 驗證電感器參數\r\n     * @returns {boolean}\r\n     */\r\n    isValid() {\r\n        return super.isValid() && this.value > 0;\r\n    }\r\n\r\n    toString() {\r\n        const inductance = this.getInductance();\r\n        let inductanceStr;\r\n        \r\n        // 格式化電感值顯示\r\n        if (inductance >= 1) {\r\n            inductanceStr = `${inductance.toFixed(3)}H`;\r\n        } else if (inductance >= 1e-3) {\r\n            inductanceStr = `${(inductance * 1e3).toFixed(2)}mH`;\r\n        } else if (inductance >= 1e-6) {\r\n            inductanceStr = `${(inductance * 1e6).toFixed(2)}µH`;\r\n        } else if (inductance >= 1e-9) {\r\n            inductanceStr = `${(inductance * 1e9).toFixed(2)}nH`;\r\n        } else {\r\n            inductanceStr = `${inductance.toExponential(2)}H`;\r\n        }\r\n        \r\n        let result = `${this.name}: ${this.nodes[0]}-${this.nodes[1]} ${inductanceStr}`;\r\n        \r\n        if (this.resistance > 0) {\r\n            result += ` R=${this.resistance}Ω`;\r\n        }\r\n        \r\n        if (this.ic !== 0) {\r\n            result += ` IC=${this.ic}A`;\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * 耦合電感 (變壓器) 模型\r\n */\r\nexport class CoupledInductor {\r\n    /**\r\n     * @param {string} name 耦合電感名稱\r\n     * @param {Inductor} L1 第一個電感\r\n     * @param {Inductor} L2 第二個電感  \r\n     * @param {number} couplingFactor 耦合係數 k (0 < k ≤ 1)\r\n     * @param {Object} params 額外參數\r\n     */\r\n    constructor(name, L1, L2, couplingFactor, params = {}) {\r\n        this.name = name;\r\n        this.type = 'K';\r\n        this.L1 = L1;\r\n        this.L2 = L2;\r\n        this.k = Math.max(0, Math.min(1, couplingFactor)); // 限制在0-1範圍\r\n        this.params = params;\r\n        \r\n        // 計算互感 M = k * sqrt(L1 * L2)\r\n        this.mutualInductance = this.k * Math.sqrt(L1.getInductance() * L2.getInductance());\r\n        \r\n        // 極性 (dot convention)\r\n        this.dotNodes = params.dotNodes || [L1.nodes[0], L2.nodes[0]];\r\n    }\r\n\r\n    /**\r\n     * 獲取互感值\r\n     * @returns {number} 互感 (亨利)\r\n     */\r\n    getMutualInductance() {\r\n        // 重新計算，因為電感值可能改變\r\n        return this.k * Math.sqrt(this.L1.getInductance() * this.L2.getInductance());\r\n    }\r\n\r\n    /**\r\n     * 獲取耦合電感資訊\r\n     * @returns {Object} 詳細信息\r\n     */\r\n    getInfo() {\r\n        return {\r\n            name: this.name,\r\n            type: this.type,\r\n            L1: this.L1.name,\r\n            L2: this.L2.name,\r\n            couplingFactor: this.k,\r\n            mutualInductance: this.getMutualInductance(),\r\n            dotNodes: this.dotNodes,\r\n            L1_inductance: this.L1.getInductance(),\r\n            L2_inductance: this.L2.getInductance()\r\n        };\r\n    }\r\n\r\n    toString() {\r\n        const M = this.getMutualInductance();\r\n        return `${this.name}: ${this.L1.name}-${this.L2.name} k=${this.k} M=${(M * 1e6).toFixed(2)}µH`;\r\n    }\r\n}\r\n\r\n/**\r\n * 可變電感 (可調電感或電感器) 模型\r\n */\r\nexport class VariableInductor extends Inductor {\r\n    /**\r\n     * @param {string} name 可變電感名稱\r\n     * @param {string[]} nodes 連接節點 [n1, n2]\r\n     * @param {number} minInductance 最小電感值\r\n     * @param {number} maxInductance 最大電感值\r\n     * @param {number} controlValue 控制值 (0-1)\r\n     * @param {Object} params 額外參數\r\n     */\r\n    constructor(name, nodes, minInductance, maxInductance, controlValue = 0.5, params = {}) {\r\n        const averageInductance = (minInductance + maxInductance) / 2;\r\n        super(name, nodes, averageInductance, params);\r\n        \r\n        this.type = 'VIND';\r\n        this.minInductance = minInductance;\r\n        this.maxInductance = maxInductance;\r\n        this.controlValue = Math.max(0, Math.min(1, controlValue)); // 限制在0-1範圍\r\n    }\r\n\r\n    /**\r\n     * 根據控制值計算當前電感值\r\n     * @returns {number} 當前電感值\r\n     */\r\n    getInductance() {\r\n        const baseInductance = this.minInductance + \r\n            this.controlValue * (this.maxInductance - this.minInductance);\r\n        \r\n        // 應用溫度係數\r\n        const deltaT = this.temperature - this.tnom;\r\n        const tempFactor = 1 + this.tc1 * deltaT + this.tc2 * deltaT * deltaT;\r\n        \r\n        return baseInductance * tempFactor;\r\n    }\r\n\r\n    /**\r\n     * 設置控制值\r\n     * @param {number} value 控制值 (0-1)\r\n     */\r\n    setControlValue(value) {\r\n        this.controlValue = Math.max(0, Math.min(1, value));\r\n    }\r\n\r\n    toString() {\r\n        const inductance = this.getInductance();\r\n        const minInd = this.minInductance * 1e6;\r\n        const maxInd = this.maxInductance * 1e6;\r\n        const currentInd = inductance * 1e6;\r\n        \r\n        return `${this.name}: ${this.nodes[0]}-${this.nodes[1]} ${currentInd.toFixed(2)}µH (${minInd.toFixed(0)}-${maxInd.toFixed(0)}µH, ctrl=${(this.controlValue * 100).toFixed(1)}%)`;\r\n    }\r\n}","/**\r\n * 電壓源和電流源元件模型\r\n * 實現各種獨立源，包括DC、AC、脈衝、正弦波等\r\n */\r\n\r\nimport { BaseComponent } from './base.js';\r\n\r\n/**\r\n * 獨立電壓源基類\r\n */\r\nexport class VoltageSource extends BaseComponent {\r\n    /**\r\n     * @param {string} name 電壓源名稱 (如 'VIN', 'V1')\r\n     * @param {string[]} nodes 連接節點 [正, 負]\r\n     * @param {number|Object} source 電壓值或源描述對象\r\n     * @param {Object} params 額外參數\r\n     */\r\n    constructor(name, nodes, source, params = {}) {\r\n        // 不讓 BaseComponent 解析 value，我們自己處理\r\n        super(name, 'V', nodes, 0, params);\r\n        \r\n        if (nodes.length !== 2) {\r\n            throw new Error(`Voltage source ${name} must have exactly 2 nodes`);\r\n        }\r\n        \r\n        // 保存原始源描述\r\n        this.rawSource = source;\r\n        \r\n        // 解析源描述\r\n        this.sourceConfig = this.parseSourceConfig(source);\r\n        this.needsCurrentVar = true;\r\n        \r\n        // 設置默認值為 DC 值\r\n        this.value = this.sourceConfig.dc || this.sourceConfig.amplitude || 0;\r\n    }\r\n\r\n    /**\r\n     * 解析源配置\r\n     * @param {number|Object|string} source 源描述\r\n     * @returns {Object} 標準化的源配置\r\n     */\r\n    parseSourceConfig(source) {\r\n        // 如果是數字，視為DC源\r\n        if (typeof source === 'number') {\r\n            return {\r\n                type: 'DC',\r\n                dc: source,\r\n                amplitude: source,\r\n                offset: source\r\n            };\r\n        }\r\n        \r\n        // 如果是字符串，解析SPICE格式\r\n        if (typeof source === 'string') {\r\n            return this.parseSpiceSource(source);\r\n        }\r\n        \r\n        // 如果是對象，直接使用\r\n        if (typeof source === 'object') {\r\n            return {\r\n                type: source.type || 'DC',\r\n                ...source\r\n            };\r\n        }\r\n        \r\n        throw new Error(`Invalid voltage source specification: ${source}`);\r\n    }\r\n\r\n    /**\r\n     * 解析SPICE格式的源描述\r\n     * @param {string} sourceStr SPICE格式字符串\r\n     * @returns {Object} 源配置\r\n     */\r\n    parseSpiceSource(sourceStr) {\r\n        const str = sourceStr.trim().toUpperCase();\r\n        \r\n        // DC源: \"DC(5)\" 或 \"5\" 或 \"5V\" - 支援科學記號和單位後綴\r\n        const dcMatch = str.match(/^(?:DC\\()?(-?[\\d.]+(?:[eE][-+]?\\d+)?)(?:V)?(?:\\))?$/);\r\n        if (dcMatch) {\r\n            const value = parseFloat(dcMatch[1]);\r\n            return {\r\n                type: 'DC',\r\n                dc: value,\r\n                amplitude: value,\r\n                offset: value\r\n            };\r\n        }\r\n        \r\n        // 正弦波: \"SINE(offset amplitude frequency delay damping)\" - 支援科學記號\r\n        const sineMatch = str.match(/^SINE\\(\\s*([-\\d.]+(?:[eE][-+]?\\d+)?)?\\s*([-\\d.]+(?:[eE][-+]?\\d+)?)?\\s*([-\\d.]+(?:[eE][-+]?\\d+)?)?\\s*([-\\d.]+(?:[eE][-+]?\\d+)?)?\\s*([-\\d.]+(?:[eE][-+]?\\d+)?)?\\s*\\)$/);\r\n        if (sineMatch) {\r\n            return {\r\n                type: 'SINE',\r\n                offset: parseFloat(sineMatch[1] || '0'),\r\n                amplitude: parseFloat(sineMatch[2] || '0'),\r\n                frequency: parseFloat(sineMatch[3] || '1'),\r\n                delay: parseFloat(sineMatch[4] || '0'),\r\n                damping: parseFloat(sineMatch[5] || '0')\r\n            };\r\n        }\r\n        \r\n        // 脈衝波: \"PULSE(v1 v2 td tr tf pw per)\" - 支援科學記號\r\n        const pulseMatch = str.match(/^PULSE\\(\\s*([-\\d.]+(?:[eE][-+]?\\d+)?)\\s+([-\\d.]+(?:[eE][-+]?\\d+)?)\\s*([-\\d.]+(?:[eE][-+]?\\d+)?)?\\s*([-\\d.]+(?:[eE][-+]?\\d+)?)?\\s*([-\\d.]+(?:[eE][-+]?\\d+)?)?\\s*([-\\d.]+(?:[eE][-+]?\\d+)?)?\\s*([-\\d.]+(?:[eE][-+]?\\d+)?)?\\s*\\)$/);\r\n        if (pulseMatch) {\r\n            return {\r\n                type: 'PULSE',\r\n                v1: parseFloat(pulseMatch[1]),\r\n                v2: parseFloat(pulseMatch[2]),\r\n                td: parseFloat(pulseMatch[3] || '0'),      // 延遲時間\r\n                tr: parseFloat(pulseMatch[4] || '1e-9'),   // 上升時間\r\n                tf: parseFloat(pulseMatch[5] || '1e-9'),   // 下降時間\r\n                pw: parseFloat(pulseMatch[6] || '1e-6'),   // 脈寬\r\n                per: parseFloat(pulseMatch[7] || '2e-6')   // 周期\r\n            };\r\n        }\r\n        \r\n        throw new Error(`Cannot parse voltage source: ${sourceStr}`);\r\n    }\r\n\r\n    /**\r\n     * 檢查此元件是否需要額外的電流變數\r\n     * @returns {boolean}\r\n     */\r\n    needsCurrentVariable() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * 獲取指定時間的電壓值\r\n     * @param {number} time 時間 (秒)\r\n     * @returns {number} 電壓值 (伏特)\r\n     */\r\n    getValue(time = 0) {\r\n        const config = this.sourceConfig;\r\n        \r\n        switch (config.type) {\r\n            case 'DC':\r\n                return config.dc || 0;\r\n                \r\n            case 'SINE':\r\n                return this.getSineValue(time, config);\r\n                \r\n            case 'PULSE':\r\n                return this.getPulseValue(time, config);\r\n                \r\n            case 'EXP':\r\n                return this.getExpValue(time, config);\r\n                \r\n            case 'PWL':\r\n                return this.getPWLValue(time, config);\r\n                \r\n            default:\r\n                console.warn(`Unknown voltage source type: ${config.type}`);\r\n                return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 計算正弦波值\r\n     * v(t) = offset + amplitude * sin(2π * frequency * (t - delay)) * exp(-damping * (t - delay))\r\n     */\r\n    getSineValue(time, config) {\r\n        const { offset, amplitude, frequency, delay, damping } = config;\r\n        \r\n        if (time < delay) {\r\n            return offset;\r\n        }\r\n        \r\n        const t = time - delay;\r\n        const omega = 2 * Math.PI * frequency;\r\n        const dampingFactor = damping > 0 ? Math.exp(-damping * t) : 1;\r\n        \r\n        return offset + amplitude * Math.sin(omega * t) * dampingFactor;\r\n    }\r\n\r\n    /**\r\n     * 計算脈衝波值\r\n     */\r\n    getPulseValue(time, config) {\r\n        const { v1, v2, td, tr, tf, pw, per } = config;\r\n        \r\n        if (time < td) {\r\n            return v1;\r\n        }\r\n        \r\n        // 計算在周期內的時間\r\n        const cycleTime = (time - td) % per;\r\n        \r\n        if (cycleTime <= tr) {\r\n            // 上升沿\r\n            return v1 + (v2 - v1) * (cycleTime / tr);\r\n        } else if (cycleTime <= tr + pw) {\r\n            // 高電平\r\n            return v2;\r\n        } else if (cycleTime <= tr + pw + tf) {\r\n            // 下降沿\r\n            const fallTime = cycleTime - tr - pw;\r\n            return v2 - (v2 - v1) * (fallTime / tf);\r\n        } else {\r\n            // 低電平\r\n            return v1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 計算指數波值 (用於EXP源)\r\n     */\r\n    getExpValue(time, config) {\r\n        const { v1, v2, td1, tau1, td2, tau2 } = config;\r\n        \r\n        if (time < td1) {\r\n            return v1;\r\n        } else if (time < td2) {\r\n            const t = time - td1;\r\n            return v1 + (v2 - v1) * (1 - Math.exp(-t / tau1));\r\n        } else {\r\n            const t1 = td2 - td1;\r\n            const t2 = time - td2;\r\n            const v_td2 = v1 + (v2 - v1) * (1 - Math.exp(-t1 / tau1));\r\n            return v_td2 + (v1 - v_td2) * (1 - Math.exp(-t2 / tau2));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 計算分段線性值 (用於PWL源)\r\n     */\r\n    getPWLValue(time, config) {\r\n        const { points } = config;\r\n        \r\n        if (!points || points.length === 0) {\r\n            return 0;\r\n        }\r\n        \r\n        // 找到時間點在哪個段落中\r\n        for (let i = 0; i < points.length - 1; i++) {\r\n            const [t1, v1] = points[i];\r\n            const [t2, v2] = points[i + 1];\r\n            \r\n            if (time >= t1 && time <= t2) {\r\n                // 線性插值\r\n                return v1 + (v2 - v1) * (time - t1) / (t2 - t1);\r\n            }\r\n        }\r\n        \r\n        // 如果時間超出範圍，返回最後一個值\r\n        if (time >= points[points.length - 1][0]) {\r\n            return points[points.length - 1][1];\r\n        }\r\n        \r\n        // 如果時間在第一個點之前，返回第一個值\r\n        return points[0][1];\r\n    }\r\n\r\n    /**\r\n     * 獲取電壓源信息\r\n     * @param {number} time 當前時間\r\n     * @returns {Object}\r\n     */\r\n    getInfo(time = 0) {\r\n        return {\r\n            ...super.toJSON(),\r\n            sourceConfig: this.sourceConfig,\r\n            currentValue: this.getValue(time),\r\n            operatingPoint: { ...this.operatingPoint }\r\n        };\r\n    }\r\n\r\n    toString() {\r\n        const config = this.sourceConfig;\r\n        let valueStr;\r\n        \r\n        switch (config.type) {\r\n            case 'DC':\r\n                valueStr = `DC(${config.dc}V)`;\r\n                break;\r\n            case 'SINE':\r\n                valueStr = `SINE(${config.offset}V, ${config.amplitude}V, ${config.frequency}Hz)`;\r\n                break;\r\n            case 'PULSE':\r\n                valueStr = `PULSE(${config.v1}V, ${config.v2}V, ${config.per * 1e6}µs)`;\r\n                break;\r\n            default:\r\n                valueStr = `${config.type}`;\r\n        }\r\n        \r\n        return `${this.name}: ${this.nodes[0]}(+) ${this.nodes[1]}(-) ${valueStr}`;\r\n    }\r\n\r\n    /**\r\n     * 動態設置電壓值（用於控制系統）\r\n     * @param {number} newValue 新的電壓值\r\n     */\r\n    setValue(newValue) {\r\n        this.value = newValue;\r\n        // 如果是DC源，同時更新源配置\r\n        if (this.sourceConfig.type === 'DC') {\r\n            this.sourceConfig.dc = newValue;\r\n            this.sourceConfig.amplitude = newValue;\r\n            this.sourceConfig.offset = newValue;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * 獨立電流源類\r\n */\r\nexport class CurrentSource extends BaseComponent {\r\n    /**\r\n     * @param {string} name 電流源名稱 (如 'IIN', 'I1')\r\n     * @param {string[]} nodes 連接節點 [流出, 流入]\r\n     * @param {number|Object} source 電流值或源描述對象\r\n     * @param {Object} params 額外參數\r\n     */\r\n    constructor(name, nodes, source, params = {}) {\r\n        // 不讓 BaseComponent 解析 value，我們自己處理\r\n        super(name, 'I', nodes, 0, params);\r\n        \r\n        if (nodes.length !== 2) {\r\n            throw new Error(`Current source ${name} must have exactly 2 nodes`);\r\n        }\r\n        \r\n        // 保存原始源描述\r\n        this.rawSource = source;\r\n        \r\n        // 解析源描述 (使用與電壓源相同的邏輯)\r\n        this.sourceConfig = this.parseSourceConfig(source);\r\n        \r\n        // 設置默認值為 DC 值\r\n        this.value = this.sourceConfig.dc || this.sourceConfig.amplitude || 0;\r\n    }\r\n\r\n    /**\r\n     * 解析源配置 (與電壓源相同的邏輯)\r\n     */\r\n    parseSourceConfig(source) {\r\n        // 複用電壓源的解析邏輯\r\n        const voltageSource = new VoltageSource('temp', ['1', '0'], source);\r\n        return voltageSource.sourceConfig;\r\n    }\r\n\r\n    /**\r\n     * 獲取指定時間的電流值\r\n     * @param {number} time 時間 (秒)\r\n     * @returns {number} 電流值 (安培)\r\n     */\r\n    getValue(time = 0) {\r\n        // 複用電壓源的計算邏輯\r\n        const tempVoltageSource = new VoltageSource('temp', ['1', '0'], this.sourceConfig);\r\n        tempVoltageSource.sourceConfig = this.sourceConfig;\r\n        return tempVoltageSource.getValue(time);\r\n    }\r\n\r\n    /**\r\n     * 檢查此元件是否需要額外的電流變數\r\n     * @returns {boolean}\r\n     */\r\n    needsCurrentVariable() {\r\n        return false; // 電流源不需要額外的電流變數\r\n    }\r\n\r\n    /**\r\n     * 獲取電流源信息\r\n     * @param {number} time 當前時間\r\n     * @returns {Object}\r\n     */\r\n    getInfo(time = 0) {\r\n        return {\r\n            ...super.toJSON(),\r\n            sourceConfig: this.sourceConfig,\r\n            currentValue: this.getValue(time),\r\n            operatingPoint: { ...this.operatingPoint }\r\n        };\r\n    }\r\n\r\n    toString() {\r\n        const config = this.sourceConfig;\r\n        let valueStr;\r\n        \r\n        switch (config.type) {\r\n            case 'DC':\r\n                valueStr = `DC(${config.dc}A)`;\r\n                break;\r\n            case 'SINE':\r\n                valueStr = `SINE(${config.offset}A, ${config.amplitude}A, ${config.frequency}Hz)`;\r\n                break;\r\n            case 'PULSE':\r\n                valueStr = `PULSE(${config.v1}A, ${config.v2}A, ${config.per * 1e6}µs)`;\r\n                break;\r\n            default:\r\n                valueStr = `${config.type}`;\r\n        }\r\n        \r\n        return `${this.name}: ${this.nodes[0]}→${this.nodes[1]} ${valueStr}`;\r\n    }\r\n}\r\n\r\n/**\r\n * 壓控電壓源 (VCVS)\r\n */\r\nexport class VCVS extends BaseComponent {\r\n    /**\r\n     * @param {string} name VCVS名稱 (如 'E1')\r\n     * @param {string[]} outputNodes 輸出節點 [正, 負]\r\n     * @param {string[]} controlNodes 控制節點 [正, 負]\r\n     * @param {number} gain 電壓增益\r\n     * @param {Object} params 額外參數\r\n     */\r\n    constructor(name, outputNodes, controlNodes, gain, params = {}) {\r\n        const allNodes = [...outputNodes, ...controlNodes];\r\n        super(name, 'VCVS', allNodes, gain, params);\r\n        \r\n        this.outputNodes = [...outputNodes];\r\n        this.controlNodes = [...controlNodes];\r\n        this.gain = gain;\r\n    }\r\n\r\n    needsCurrentVariable() {\r\n        return true; // VCVS需要電流變數\r\n    }\r\n\r\n    toString() {\r\n        return `${this.name}: ${this.outputNodes[0]}-${this.outputNodes[1]} = ${this.gain} * (${this.controlNodes[0]}-${this.controlNodes[1]})`;\r\n    }\r\n}\r\n\r\n/**\r\n * 壓控電流源 (VCCS)  \r\n */\r\nexport class VCCS extends BaseComponent {\r\n    /**\r\n     * @param {string} name VCCS名稱 (如 'G1')\r\n     * @param {string[]} outputNodes 輸出節點 [流出, 流入]\r\n     * @param {string[]} controlNodes 控制節點 [正, 負]\r\n     * @param {number} transconductance 跨導 (S)\r\n     * @param {Object} params 額外參數\r\n     */\r\n    constructor(name, outputNodes, controlNodes, transconductance, params = {}) {\r\n        const allNodes = [...outputNodes, ...controlNodes];\r\n        super(name, 'VCCS', allNodes, transconductance, params);\r\n        \r\n        this.outputNodes = [...outputNodes];\r\n        this.controlNodes = [...controlNodes];\r\n        this.transconductance = transconductance;\r\n    }\r\n\r\n    needsCurrentVariable() {\r\n        return false; // VCCS不需要額外的電流變數\r\n    }\r\n\r\n    toString() {\r\n        return `${this.name}: I(${this.outputNodes[0]}→${this.outputNodes[1]}) = ${this.transconductance} * V(${this.controlNodes[0]}-${this.controlNodes[1]})`;\r\n    }\r\n}\r\n\r\n/**\r\n * 電流控制電流源 (CCCS)\r\n * Current-Controlled Current Source\r\n * 輸出電流 = 增益 × 控制電流\r\n * 典型應用：電晶體 Beta 特性、電流鏡\r\n */\r\nexport class CCCS extends BaseComponent {\r\n    /**\r\n     * @param {string} name CCCS名稱 (如 'F1')\r\n     * @param {string[]} outputNodes 輸出節點 [流出, 流入]\r\n     * @param {string} controlElement 控制元件名稱（通過其電流來控制）\r\n     * @param {number} currentGain 電流增益（無單位）\r\n     * @param {Object} params 額外參數\r\n     */\r\n    constructor(name, outputNodes, controlElement, currentGain, params = {}) {\r\n        super(name, 'CCCS', outputNodes, currentGain, params);\r\n        \r\n        if (outputNodes.length !== 2) {\r\n            throw new Error(`CCCS ${name} must have exactly 2 output nodes`);\r\n        }\r\n        \r\n        this.outputNodes = [...outputNodes];\r\n        this.controlElement = controlElement; // 控制元件的名稱\r\n        this.currentGain = currentGain;       // 電流增益 F\r\n        \r\n        // CCCS 需要監控控制元件的電流\r\n        this.controlCurrent = 0;\r\n    }\r\n\r\n    /**\r\n     * 設定控制電流（由解算器在每個時間步調用）\r\n     * @param {number} current 控制元件的電流\r\n     */\r\n    setControlCurrent(current) {\r\n        this.controlCurrent = current;\r\n    }\r\n\r\n    /**\r\n     * 獲取輸出電流\r\n     * @returns {number} 輸出電流 = F × I_control\r\n     */\r\n    getOutputCurrent() {\r\n        return this.currentGain * this.controlCurrent;\r\n    }\r\n\r\n    /**\r\n     * 為 MNA 分析提供印花支援\r\n     * CCCS 需要在控制元件電流確定後才能計算\r\n     */\r\n    stamp(matrix, rhs, nodeMap, voltageSourceMap, time) {\r\n        const outputCurrent = this.getOutputCurrent();\r\n        \r\n        // 獲取輸出節點索引\r\n        const node1 = this.outputNodes[0] === '0' ? -1 : nodeMap.get(this.outputNodes[0]);\r\n        const node2 = this.outputNodes[1] === '0' ? -1 : nodeMap.get(this.outputNodes[1]);\r\n        \r\n        // 印花電流源到 RHS 向量\r\n        if (node1 >= 0) {\r\n            rhs.addAt(node1, -outputCurrent); // 流出節點\r\n        }\r\n        if (node2 >= 0) {\r\n            rhs.addAt(node2, outputCurrent);  // 流入節點\r\n        }\r\n    }\r\n\r\n    needsCurrentVariable() {\r\n        return false; // CCCS 本身不需要額外的電流變數\r\n    }\r\n\r\n    toString() {\r\n        return `${this.name}: I(${this.outputNodes[0]}→${this.outputNodes[1]}) = ${this.currentGain} * I(${this.controlElement})`;\r\n    }\r\n\r\n    clone() {\r\n        return new CCCS(this.name, [...this.outputNodes], this.controlElement, this.currentGain, { ...this.params });\r\n    }\r\n}\r\n\r\n/**\r\n * 電流控制電壓源 (CCVS)\r\n * Current-Controlled Voltage Source\r\n * 輸出電壓 = 轉移阻抗 × 控制電流\r\n * 典型應用：霍爾感測器、變壓器建模\r\n */\r\nexport class CCVS extends BaseComponent {\r\n    /**\r\n     * @param {string} name CCVS名稱 (如 'H1')\r\n     * @param {string[]} outputNodes 輸出節點 [正, 負]\r\n     * @param {string} controlElement 控制元件名稱（通過其電流來控制）\r\n     * @param {number} transresistance 轉移阻抗 (Ω)\r\n     * @param {Object} params 額外參數\r\n     */\r\n    constructor(name, outputNodes, controlElement, transresistance, params = {}) {\r\n        super(name, 'CCVS', outputNodes, transresistance, params);\r\n        \r\n        if (outputNodes.length !== 2) {\r\n            throw new Error(`CCVS ${name} must have exactly 2 output nodes`);\r\n        }\r\n        \r\n        this.outputNodes = [...outputNodes];\r\n        this.controlElement = controlElement; // 控制元件的名稱\r\n        this.transresistance = transresistance; // 轉移阻抗 H (Ω)\r\n        \r\n        // CCVS 需要監控控制元件的電流\r\n        this.controlCurrent = 0;\r\n    }\r\n\r\n    /**\r\n     * 設定控制電流（由解算器在每個時間步調用）\r\n     * @param {number} current 控制元件的電流\r\n     */\r\n    setControlCurrent(current) {\r\n        this.controlCurrent = current;\r\n    }\r\n\r\n    /**\r\n     * 獲取輸出電壓\r\n     * @returns {number} 輸出電壓 = H × I_control\r\n     */\r\n    getOutputVoltage() {\r\n        return this.transresistance * this.controlCurrent;\r\n    }\r\n\r\n    /**\r\n     * 為 MNA 分析提供印花支援\r\n     * CCVS 作為電壓源需要額外的電流變數\r\n     */\r\n    stamp(matrix, rhs, nodeMap, voltageSourceMap, time) {\r\n        const outputVoltage = this.getOutputVoltage();\r\n        \r\n        // 獲取節點索引\r\n        const node1 = this.outputNodes[0] === '0' ? -1 : nodeMap.get(this.outputNodes[0]);\r\n        const node2 = this.outputNodes[1] === '0' ? -1 : nodeMap.get(this.outputNodes[1]);\r\n        \r\n        // 獲取電壓源的電流變數索引\r\n        const currentVarIndex = voltageSourceMap.get(this.name);\r\n        if (currentVarIndex === undefined) {\r\n            throw new Error(`CCVS ${this.name}: Current variable not found in voltage source map`);\r\n        }\r\n        \r\n        const matrixSize = matrix.rows;\r\n        \r\n        // 印花電壓源約束方程：V+ - V- = V_output\r\n        if (node1 >= 0) {\r\n            matrix.addAt(currentVarIndex, node1, 1);   // 電流方程中的電壓項\r\n            matrix.addAt(node1, currentVarIndex, 1);   // 節點方程中的電流項\r\n        }\r\n        if (node2 >= 0) {\r\n            matrix.addAt(currentVarIndex, node2, -1);  // 電流方程中的電壓項\r\n            matrix.addAt(node2, currentVarIndex, -1);  // 節點方程中的電流項\r\n        }\r\n        \r\n        // 右側向量：電壓約束\r\n        rhs.setAt(currentVarIndex, outputVoltage);\r\n    }\r\n\r\n    needsCurrentVariable() {\r\n        return true; // CCVS 需要電流變數（作為電壓源）\r\n    }\r\n\r\n    toString() {\r\n        return `${this.name}: V(${this.outputNodes[0]}-${this.outputNodes[1]}) = ${this.transresistance} * I(${this.controlElement})`;\r\n    }\r\n\r\n    clone() {\r\n        return new CCVS(this.name, [...this.outputNodes], this.controlElement, this.transresistance, { ...this.params });\r\n    }\r\n}","/**\r\n * MOSFET 元件模型 (專為電力電子控制模擬設計)\r\n * \r\n * 特點：\r\n * - 外部可控的 ON/OFF 狀態 (不依賴 Vgs)\r\n * - 內建體二極體模型\r\n * - 適用於 PWM 控制系統模擬\r\n */\r\n\r\nimport { BaseComponent } from './base.js';\r\n\r\n/**\r\n * 理想 MOSFET 開關模型\r\n * \r\n * 這個模型專為電力電子控制模擬設計，重點是：\r\n * 1. 開關狀態由外部控制器決定，而不是 Vgs\r\n * 2. 包含並聯的體二極體\r\n * 3. 支援快速狀態切換\r\n */\r\nexport class MOSFET extends BaseComponent {\r\n    /**\r\n     * @param {string} name MOSFET名稱 (如 'M1', 'Q1')\r\n     * @param {string[]} nodes 連接節點 [drain, source, gate] (gate節點在此模型中僅用於標識)\r\n     * @param {Object} params 參數 {Ron, Roff, Vf_diode, Von_diode}\r\n     */\r\n    constructor(name, nodes, params = {}) {\r\n        // 對於 MNA 分析，MOSFET 只需要2個節點 (drain, source)\r\n        // gate 節點僅用於模型內部管理，不參與矩陣構建\r\n        const mnaNodes = nodes.length >= 3 ? [nodes[0], nodes[1]] : nodes;\r\n        super(name, 'M', mnaNodes, 0, params);\r\n        \r\n        if (nodes.length < 2) {\r\n            throw new Error(`MOSFET ${name} must have at least 2 nodes: [drain, source], optional gate`);\r\n        }\r\n        \r\n        // MOSFET 開關參數 - 安全地解析參數，如果解析失敗使用默認值\r\n        this.Ron = this.safeParseValue(params.Ron, 1e-3);        // 導通電阻 (默認 1mΩ)\r\n        this.Roff = this.safeParseValue(params.Roff, 1e6);       // 關斷電阻 (默認 1MΩ，不要太大)\r\n        \r\n        // 體二極體參數\r\n        this.Vf_diode = this.safeParseValue(params.Vf_diode, 0.7);     // 二極體順向電壓 (默認 0.7V)\r\n        this.Von_diode = this.safeParseValue(params.Von_diode, 0.001);  // 二極體導通電阻 (默認 1mΩ)\r\n        this.Roff_diode = this.safeParseValue(params.Roff_diode, 1e6); // 二極體反向電阻 (默認 1MΩ)\r\n        \r\n        // 控制狀態\r\n        this.gateState = false; // false = OFF, true = ON\r\n        this.isExtControlled = true; // 標記這是外部控制的開關\r\n        \r\n        // 節點分配\r\n        this.drain = nodes[0];\r\n        this.source = nodes[1]; \r\n        this.gate = nodes[2] || null;   // 可選的gate節點，僅用於標識\r\n        \r\n        // 狀態追蹤\r\n        this.mosfetCurrent = 0;\r\n        \r\n        // 初始化參數驗證\r\n        this.validate();\r\n    }\r\n\r\n    /**\r\n     * 安全地解析數值參數，如果失敗則返回默認值\r\n     * @param {*} value 要解析的值\r\n     * @param {number} defaultValue 默認值\r\n     * @returns {number} 解析後的數值或默認值\r\n     */\r\n    safeParseValue(value, defaultValue) {\r\n        try {\r\n            if (value === undefined || value === null) {\r\n                return defaultValue;\r\n            }\r\n            return this.parseValue(value);\r\n        } catch (error) {\r\n            return defaultValue;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 驗證MOSFET參數\r\n     */\r\n    validate() {\r\n        if (this.Ron <= 0) {\r\n            throw new Error(`MOSFET ${this.name}: Ron must be positive`);\r\n        }\r\n        if (this.Roff <= this.Ron) {\r\n            throw new Error(`MOSFET ${this.name}: Roff must be greater than Ron`);\r\n        }\r\n        \r\n        // 狀態追蹤\r\n        this.mosfetCurrent = 0;\r\n        this.diodeCurrent = 0;\r\n        this.totalCurrent = 0;\r\n        this.drainSourceVoltage = 0;\r\n    }\r\n\r\n    /**\r\n     * 設置 MOSFET 開關狀態 (外部控制接口)\r\n     * @param {boolean} state true = ON, false = OFF\r\n     */\r\n    setGateState(state) {\r\n        this.gateState = Boolean(state);\r\n    }\r\n\r\n    /**\r\n     * 獲取當前開關狀態\r\n     * @returns {boolean}\r\n     */\r\n    getGateState() {\r\n        return this.gateState;\r\n    }\r\n\r\n    /**\r\n     * 計算 MOSFET 通道的等效電阻\r\n     * @returns {number} 等效電阻 (歐姆)\r\n     */\r\n    getMOSFETResistance() {\r\n        return this.gateState ? this.Ron : this.Roff;\r\n    }\r\n\r\n    /**\r\n     * 計算體二極體的等效電阻\r\n     * @param {number} vds Drain-Source 電壓 (V)\r\n     * @returns {number} 等效電阻 (歐姆)\r\n     */\r\n    getBodyDiodeResistance(vds) {\r\n        // 體二極體：當 Vs > Vd + Vf 時導通 (即 vds < -Vf)\r\n        const isDiodeForward = vds < -this.Vf_diode;\r\n        return isDiodeForward ? this.Von_diode : this.Roff_diode;\r\n    }\r\n\r\n    /**\r\n     * 計算總的等效電阻 (MOSFET 通道與體二極體並聯)\r\n     * @param {number} vds Drain-Source 電壓 (V)\r\n     * @returns {number} 等效電阻 (歐姆)\r\n     */\r\n    getEquivalentResistance(vds) {\r\n        const rMosfet = this.getMOSFETResistance();\r\n        const rDiode = this.getBodyDiodeResistance(vds);\r\n        \r\n        // 並聯電阻計算: 1/Rtotal = 1/R1 + 1/R2\r\n        const rTotal = 1 / (1/rMosfet + 1/rDiode);\r\n        return rTotal;\r\n    }\r\n\r\n    /**\r\n     * 為 MNA 分析提供印花 (stamping) 支援\r\n     * 注意：這是一個非線性元件，需要在每次迭代中更新\r\n     * \r\n     * @param {Matrix} matrix MNA 矩陣\r\n     * @param {Vector} rhs 右側向量  \r\n     * @param {Map} nodeMap 節點映射\r\n     * @param {Map} voltageSourceMap 電壓源映射\r\n     * @param {number} time 當前時間\r\n     */\r\n    stamp(matrix, rhs, nodeMap, voltageSourceMap, time) {\r\n        // 獲取節點索引，接地節點返回 -1\r\n        const drainIndex = this.drain === '0' || this.drain === 'gnd' ? -1 : nodeMap.get(this.drain);\r\n        const sourceIndex = this.source === '0' || this.source === 'gnd' ? -1 : nodeMap.get(this.source);\r\n        \r\n        if (drainIndex === undefined || sourceIndex === undefined) {\r\n            throw new Error(`MOSFET ${this.name}: Node mapping not found (drain: ${this.drain}, source: ${this.source})`);\r\n        }\r\n\r\n        // 獲取當前 Drain-Source 電壓 (初始化時為0)\r\n        let vds = 0;\r\n        if (this.drainSourceVoltage !== undefined) {\r\n            vds = this.drainSourceVoltage;\r\n        }\r\n\r\n        const resistance = this.getEquivalentResistance(vds);\r\n        const conductance = 1 / resistance;\r\n\r\n        // 印花導納矩陣 (類似電阻的印花方式)\r\n        // 接地節點 (index = -1) 不需要印花到矩陣中\r\n        if (drainIndex >= 0) {\r\n            matrix.addAt(drainIndex, drainIndex, conductance);\r\n            if (sourceIndex >= 0) {\r\n                matrix.addAt(drainIndex, sourceIndex, -conductance);\r\n            }\r\n        }\r\n        \r\n        if (sourceIndex >= 0) {\r\n            matrix.addAt(sourceIndex, sourceIndex, conductance);\r\n            if (drainIndex >= 0) {\r\n                matrix.addAt(sourceIndex, drainIndex, -conductance);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 更新元件狀態 (在每個時間步後調用)\r\n     * @param {number} vds Drain-Source 電壓\r\n     * @param {number} ids Drain-Source 電流\r\n     */\r\n    updateState(vds, ids) {\r\n        this.drainSourceVoltage = vds;\r\n        this.totalCurrent = ids;\r\n        \r\n        // 估算通道電流和二極體電流的分配\r\n        const rMosfet = this.getMOSFETResistance();\r\n        const rDiode = this.getBodyDiodeResistance(vds);\r\n        const rTotal = this.getEquivalentResistance(vds);\r\n        \r\n        // 電流分配 (基於並聯電阻的電流分割)\r\n        this.mosfetCurrent = ids * (rTotal / rMosfet);\r\n        this.diodeCurrent = ids * (rTotal / rDiode);\r\n    }\r\n\r\n    /**\r\n     * 計算通過MOSFET的總電流\r\n     * @param {Map<string, number>} nodeVoltages 節點電壓\r\n     * @returns {number} 總電流 (安培)，正值表示從drain流向source\r\n     */\r\n    getCurrent(nodeVoltages) {\r\n        const vds = this.getVoltage(nodeVoltages); // drain-source電壓\r\n        this.drainSourceVoltage = vds;\r\n        \r\n        const rTotal = this.getEquivalentResistance(vds);\r\n        const ids = vds / rTotal;\r\n        \r\n        // 更新電流狀態\r\n        this.totalCurrent = ids;\r\n        this.operatingPoint.current = ids;\r\n        \r\n        return ids;\r\n    }\r\n\r\n    /**\r\n     * 檢查是否需要電流變數 (對於理想開關，通常不需要)\r\n     * @returns {boolean}\r\n     */\r\n    needsCurrentVariable() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * 獲取元件資訊字串\r\n     * @returns {string}\r\n     */\r\n    toString() {\r\n        const gateInfo = this.gate ? ` G=${this.gate}` : ' (Ext. Control)';\r\n        return `${this.name} (MOSFET): D=${this.drain} S=${this.source}${gateInfo}, ` +\r\n               `State=${this.gateState ? 'ON' : 'OFF'}, Ron=${this.Ron}Ω, Roff=${this.Roff}Ω`;\r\n    }\r\n\r\n    /**\r\n     * 獲取詳細的工作狀態\r\n     * @returns {Object}\r\n     */\r\n    getOperatingStatus() {\r\n        return {\r\n            name: this.name,\r\n            type: 'MOSFET',\r\n            gateState: this.gateState ? 'ON' : 'OFF',\r\n            drainSourceVoltage: this.drainSourceVoltage,\r\n            totalCurrent: this.totalCurrent,\r\n            mosfetCurrent: this.mosfetCurrent,\r\n            diodeCurrent: this.diodeCurrent,\r\n            currentResistance: this.getEquivalentResistance(this.drainSourceVoltage),\r\n            bodyDiodeActive: this.drainSourceVoltage < -this.Vf_diode\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 序列化為 JSON\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            gateState: this.gateState,\r\n            Ron: this.Ron,\r\n            Roff: this.Roff,\r\n            Vf_diode: this.Vf_diode,\r\n            Von_diode: this.Von_diode,\r\n            operatingStatus: this.getOperatingStatus()\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 復製 MOSFET\r\n     * @returns {MOSFET}\r\n     */\r\n    clone() {\r\n        const cloned = new MOSFET(this.name, this.nodes, {\r\n            Ron: this.Ron,\r\n            Roff: this.Roff,\r\n            Vf_diode: this.Vf_diode,\r\n            Von_diode: this.Von_diode,\r\n            Roff_diode: this.Roff_diode\r\n        });\r\n        cloned.setGateState(this.gateState);\r\n        return cloned;\r\n    }\r\n}","/**\r\n * SPICE風格網表解析器\r\n * \r\n * 解析傳統SPICE格式的網表文件，建立電路元件列表\r\n */\r\n\r\nimport { Resistor } from '../components/resistor.js';\r\nimport { Capacitor } from '../components/capacitor.js';\r\nimport { Inductor } from '../components/inductor.js';\r\nimport { VoltageSource, CurrentSource, VCVS, VCCS } from '../components/sources.js';\r\nimport { MOSFET } from '../components/mosfet.js';\r\n\r\n/**\r\n * 網表解析器\r\n */\r\nexport class NetlistParser {\r\n    constructor() {\r\n        this.components = [];\r\n        this.models = new Map(); // .MODEL 定義\r\n        this.parameters = new Map(); // .PARAM 定義\r\n        this.analyses = []; // .TRAN, .DC 等分析指令\r\n        this.options = new Map(); // .OPTIONS 設置\r\n        this.includes = []; // .INCLUDE 文件\r\n        \r\n        // 解析統計\r\n        this.stats = {\r\n            totalLines: 0,\r\n            parsedLines: 0,\r\n            skippedLines: 0,\r\n            errors: []\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 解析網表字符串\r\n     * @param {string} netlistText 網表內容\r\n     * @returns {Object} 解析結果\r\n     */\r\n    parse(netlistText) {\r\n        this.reset();\r\n        \r\n        const lines = netlistText.split(/\\r?\\n/).map(line => line.trim());\r\n        this.stats.totalLines = lines.length;\r\n        \r\n        console.log(`Parsing netlist with ${lines.length} lines...`);\r\n        \r\n        try {\r\n            // 預處理：移除註釋、合併續行\r\n            const processedLines = this.preprocessLines(lines);\r\n            \r\n            // 逐行解析\r\n            for (let i = 0; i < processedLines.length; i++) {\r\n                const line = processedLines[i];\r\n                if (line.length === 0) continue;\r\n                \r\n                try {\r\n                    this.parseLine(line, i + 1);\r\n                    this.stats.parsedLines++;\r\n                } catch (error) {\r\n                    this.stats.errors.push({\r\n                        line: i + 1,\r\n                        content: line,\r\n                        error: error.message\r\n                    });\r\n                }\r\n            }\r\n            \r\n            console.log(`Netlist parsing completed: ${this.components.length} components, ${this.stats.errors.length} errors`);\r\n            \r\n            return {\r\n                components: this.components,\r\n                models: this.models,\r\n                parameters: this.parameters,\r\n                analyses: this.analyses,\r\n                options: this.options,\r\n                stats: this.stats\r\n            };\r\n            \r\n        } catch (error) {\r\n            console.error('Netlist parsing failed:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 重置解析器狀態\r\n     */\r\n    reset() {\r\n        this.components = [];\r\n        this.models.clear();\r\n        this.parameters.clear();\r\n        this.analyses = [];\r\n        this.options.clear();\r\n        this.includes = [];\r\n        this.stats = {\r\n            totalLines: 0,\r\n            parsedLines: 0,\r\n            skippedLines: 0,\r\n            errors: []\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 預處理網表行\r\n     * @param {string[]} lines 原始行\r\n     * @returns {string[]} 處理後的行\r\n     */\r\n    preprocessLines(lines) {\r\n        const processed = [];\r\n        let currentLine = '';\r\n        \r\n        for (let line of lines) {\r\n            // 移除註釋 (以 * 或 ; 開頭的行)\r\n            if (line.startsWith('*') || line.startsWith(';')) {\r\n                continue;\r\n            }\r\n            \r\n            // 移除行內註釋 ($ 或 ; 之後的內容)\r\n            const commentIndex = Math.min(\r\n                line.indexOf('$') >= 0 ? line.indexOf('$') : line.length,\r\n                line.indexOf(';') >= 0 ? line.indexOf(';') : line.length\r\n            );\r\n            line = line.substring(0, commentIndex).trim();\r\n            \r\n            if (line.length === 0) continue;\r\n            \r\n            // 處理續行 (以 + 開頭)\r\n            if (line.startsWith('+')) {\r\n                currentLine += ' ' + line.substring(1).trim();\r\n            } else {\r\n                if (currentLine.length > 0) {\r\n                    processed.push(currentLine);\r\n                }\r\n                currentLine = line;\r\n            }\r\n        }\r\n        \r\n        // 添加最後一行\r\n        if (currentLine.length > 0) {\r\n            processed.push(currentLine);\r\n        }\r\n        \r\n        return processed;\r\n    }\r\n\r\n    /**\r\n     * 解析單行網表\r\n     * @param {string} line 網表行\r\n     * @param {number} lineNumber 行號\r\n     * @returns {BaseComponent} 創建的組件 (如果是組件行)\r\n     */\r\n    parseLine(line, lineNumber = 1) {\r\n        const tokens = line.split(/\\s+/);\r\n        if (tokens.length === 0) return null;\r\n        \r\n        const firstChar = tokens[0][0].toUpperCase();\r\n        let component = null;\r\n        \r\n        try {\r\n            switch (firstChar) {\r\n                case 'R':\r\n                    component = this.parseResistor(tokens);\r\n                    break;\r\n                case 'C':\r\n                    component = this.parseCapacitor(tokens);\r\n                    break;\r\n                case 'L':\r\n                    component = this.parseInductor(tokens);\r\n                    break;\r\n                case 'V':\r\n                    component = this.parseVoltageSource(tokens);\r\n                    break;\r\n                case 'I':\r\n                    component = this.parseCurrentSource(tokens);\r\n                    break;\r\n                case 'E':\r\n                    component = this.parseVCVS(tokens);\r\n                    break;\r\n                case 'G':\r\n                    component = this.parseVCCS(tokens);\r\n                    break;\r\n                case 'M':\r\n                    component = this.parseMOSFET(tokens);\r\n                    break;\r\n                case '.':\r\n                    this.parseDirective(tokens);\r\n                    break;\r\n                default:\r\n                    console.warn(`Unknown component type: ${tokens[0]} (line ${lineNumber})`);\r\n                    this.stats.skippedLines++;\r\n            }\r\n        } catch (error) {\r\n            throw new Error(`Line ${lineNumber}: ${error.message}`);\r\n        }\r\n        \r\n        return component;\r\n    }\r\n\r\n    /**\r\n     * 解析電阻\r\n     * 格式: R<name> <node1> <node2> <value> [parameters]\r\n     * @returns {Resistor} 創建的電阻組件\r\n     */\r\n    parseResistor(tokens) {\r\n        if (tokens.length < 4) {\r\n            throw new Error('Resistor requires at least 4 tokens: R<name> <node1> <node2> <value>');\r\n        }\r\n        \r\n        const name = tokens[0];\r\n        const nodes = [tokens[1], tokens[2]];\r\n        const value = tokens[3];\r\n        const params = this.parseParameters(tokens.slice(4));\r\n        \r\n        const resistor = new Resistor(name, nodes, value, params);\r\n        this.components.push(resistor);\r\n        return resistor;\r\n    }\r\n\r\n    /**\r\n     * 解析電容\r\n     * 格式: C<name> <node1> <node2> <value> [IC=<initial_voltage>]\r\n     * @returns {Capacitor} 創建的電容組件\r\n     */\r\n    parseCapacitor(tokens) {\r\n        if (tokens.length < 4) {\r\n            throw new Error('Capacitor requires at least 4 tokens: C<name> <node1> <node2> <value>');\r\n        }\r\n        \r\n        const name = tokens[0];\r\n        const nodes = [tokens[1], tokens[2]];\r\n        const value = tokens[3];\r\n        const params = this.parseParameters(tokens.slice(4));\r\n        \r\n        const capacitor = new Capacitor(name, nodes, value, params);\r\n        this.components.push(capacitor);\r\n        return capacitor;\r\n    }\r\n\r\n    /**\r\n     * 解析電感\r\n     * 格式: L<name> <node1> <node2> <value> [IC=<initial_current>]\r\n     * @returns {Inductor} 創建的電感組件\r\n     */\r\n    parseInductor(tokens) {\r\n        if (tokens.length < 4) {\r\n            throw new Error('Inductor requires at least 4 tokens: L<name> <node1> <node2> <value>');\r\n        }\r\n        \r\n        const name = tokens[0];\r\n        const nodes = [tokens[1], tokens[2]];\r\n        const value = tokens[3];\r\n        const params = this.parseParameters(tokens.slice(4));\r\n        \r\n        const inductor = new Inductor(name, nodes, value, params);\r\n        this.components.push(inductor);\r\n        return inductor;\r\n    }\r\n\r\n    /**\r\n     * 解析 MOSFET\r\n     * 格式: M<name> <drain> <source> <gate> [Ron=<value>] [Roff=<value>] [Vf=<value>]\r\n     * @returns {MOSFET} 創建的 MOSFET 組件\r\n     */\r\n    parseMOSFET(tokens) {\r\n        if (tokens.length < 4) {\r\n            throw new Error('MOSFET requires at least 4 tokens: M<name> <drain> <source> <gate>');\r\n        }\r\n        \r\n        const name = tokens[0];\r\n        const drain = tokens[1];\r\n        const source = tokens[2];\r\n        const gate = tokens[3];\r\n        // 完整節點信息，但只有 drain 和 source 會被用於 MNA 矩陣\r\n        const allNodes = [drain, source, gate];\r\n        \r\n        // 解析 MOSFET 參數\r\n        const params = this.parseParameters(tokens.slice(4));\r\n        \r\n        // 參數會通過 MOSFET 構造函數中的 parseValue 方法處理\r\n        const mosfetParams = {\r\n            Ron: params.Ron || params.ron || '1m',        // 默認 1mΩ\r\n            Roff: params.Roff || params.roff || '1M',     // 默認 1MΩ  \r\n            Vf_diode: params.Vf || params.vf || params.Vf_diode || '0.7',\r\n            Von_diode: params.Von_diode || params.von_diode || '1m',\r\n            Roff_diode: params.Roff_diode || params.roff_diode || '1M'\r\n        };\r\n        \r\n        const mosfet = new MOSFET(name, allNodes, mosfetParams);\r\n        this.components.push(mosfet);\r\n        return mosfet;\r\n    }\r\n\r\n    /**\r\n     * 解析電壓源\r\n     * 格式: V<name> <node+> <node-> <source_spec>\r\n     * @returns {VoltageSource} 創建的電壓源組件\r\n     */\r\n    parseVoltageSource(tokens) {\r\n        if (tokens.length < 4) {\r\n            throw new Error('Voltage source requires at least 4 tokens: V<name> <node+> <node-> <source>');\r\n        }\r\n        \r\n        const name = tokens[0];\r\n        const nodes = [tokens[1], tokens[2]];\r\n        \r\n        // 合併source specification (可能包含空格)\r\n        let sourceSpec = tokens.slice(3).join(' ');\r\n        \r\n        // 解析參數\r\n        const params = {};\r\n        \r\n        const voltageSource = new VoltageSource(name, nodes, sourceSpec, params);\r\n        this.components.push(voltageSource);\r\n        return voltageSource;\r\n    }\r\n\r\n    /**\r\n     * 解析電流源\r\n     * 格式: I<name> <node+> <node-> <source_spec>\r\n     * @returns {CurrentSource} 創建的電流源組件\r\n     */\r\n    parseCurrentSource(tokens) {\r\n        if (tokens.length < 4) {\r\n            throw new Error('Current source requires at least 4 tokens: I<name> <node+> <node-> <source>');\r\n        }\r\n        \r\n        const name = tokens[0];\r\n        const nodes = [tokens[1], tokens[2]];\r\n        \r\n        // 合併source specification\r\n        let sourceSpec = tokens.slice(3).join(' ');\r\n        const params = {};\r\n        \r\n        const currentSource = new CurrentSource(name, nodes, sourceSpec, params);\r\n        this.components.push(currentSource);\r\n        return currentSource;\r\n    }\r\n\r\n    /**\r\n     * 解析壓控電壓源 (VCVS)\r\n     * 格式: E<name> <out+> <out-> <in+> <in-> <gain>\r\n     */\r\n    parseVCVS(tokens) {\r\n        if (tokens.length < 6) {\r\n            throw new Error('VCVS requires 6 tokens: E<name> <out+> <out-> <in+> <in-> <gain>');\r\n        }\r\n        \r\n        const name = tokens[0];\r\n        const outputNodes = [tokens[1], tokens[2]];\r\n        const controlNodes = [tokens[3], tokens[4]];\r\n        const gain = parseFloat(tokens[5]);\r\n        \r\n        const vcvs = new VCVS(name, outputNodes, controlNodes, gain);\r\n        this.components.push(vcvs);\r\n    }\r\n\r\n    /**\r\n     * 解析壓控電流源 (VCCS)\r\n     * 格式: G<name> <out+> <out-> <in+> <in-> <transconductance>\r\n     */\r\n    parseVCCS(tokens) {\r\n        if (tokens.length < 6) {\r\n            throw new Error('VCCS requires 6 tokens: G<name> <out+> <out-> <in+> <in-> <gm>');\r\n        }\r\n        \r\n        const name = tokens[0];\r\n        const outputNodes = [tokens[1], tokens[2]];\r\n        const controlNodes = [tokens[3], tokens[4]];\r\n        const transconductance = parseFloat(tokens[5]);\r\n        \r\n        const vccs = new VCCS(name, outputNodes, controlNodes, transconductance);\r\n        this.components.push(vccs);\r\n    }\r\n\r\n    /**\r\n     * 解析指令 (以 . 開頭的行)\r\n     * @param {string[]} tokens 標記陣列\r\n     */\r\n    parseDirective(tokens) {\r\n        const directive = tokens[0].toLowerCase();\r\n        \r\n        switch (directive) {\r\n            case '.tran':\r\n                this.parseTranDirective(tokens);\r\n                break;\r\n            case '.dc':\r\n                this.parseDCDirective(tokens);\r\n                break;\r\n            case '.param':\r\n                this.parseParamDirective(tokens);\r\n                break;\r\n            case '.model':\r\n                this.parseModelDirective(tokens);\r\n                break;\r\n            case '.options':\r\n                this.parseOptionsDirective(tokens);\r\n                break;\r\n            case '.end':\r\n                // 網表結束標記\r\n                break;\r\n            case '.title':\r\n                // 標題行，忽略\r\n                break;\r\n            default:\r\n                console.warn(`Unknown directive: ${directive}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 解析 .TRAN 指令\r\n     * 格式: .TRAN <tstep> <tstop> [tstart] [tmax]\r\n     */\r\n    parseTranDirective(tokens) {\r\n        if (tokens.length < 3) {\r\n            throw new Error('.TRAN requires at least 2 parameters: .TRAN <tstep> <tstop>');\r\n        }\r\n        \r\n        const analysis = {\r\n            type: 'TRAN',\r\n            tstep: tokens[1],\r\n            tstop: tokens[2],\r\n            tstart: tokens[3] || '0',\r\n            tmax: tokens[4] || tokens[1]\r\n        };\r\n        \r\n        this.analyses.push(analysis);\r\n    }\r\n\r\n    /**\r\n     * 解析 .DC 指令\r\n     */\r\n    parseDCDirective(tokens) {\r\n        const analysis = {\r\n            type: 'DC',\r\n            parameters: tokens.slice(1)\r\n        };\r\n        \r\n        this.analyses.push(analysis);\r\n    }\r\n\r\n    /**\r\n     * 解析 .PARAM 指令\r\n     */\r\n    parseParamDirective(tokens) {\r\n        for (let i = 1; i < tokens.length; i++) {\r\n            const param = tokens[i];\r\n            const equalIndex = param.indexOf('=');\r\n            if (equalIndex > 0) {\r\n                const name = param.substring(0, equalIndex);\r\n                const value = param.substring(equalIndex + 1);\r\n                this.parameters.set(name, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 解析 .MODEL 指令\r\n     */\r\n    parseModelDirective(tokens) {\r\n        if (tokens.length < 3) {\r\n            throw new Error('.MODEL requires at least 2 parameters: .MODEL <name> <type>');\r\n        }\r\n        \r\n        const modelName = tokens[1];\r\n        const modelType = tokens[2];\r\n        const modelParams = this.parseParameters(tokens.slice(3));\r\n        \r\n        this.models.set(modelName, {\r\n            type: modelType,\r\n            parameters: modelParams\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 解析 .OPTIONS 指令\r\n     */\r\n    parseOptionsDirective(tokens) {\r\n        for (let i = 1; i < tokens.length; i++) {\r\n            const option = tokens[i];\r\n            const equalIndex = option.indexOf('=');\r\n            if (equalIndex > 0) {\r\n                const name = option.substring(0, equalIndex);\r\n                const value = option.substring(equalIndex + 1);\r\n                this.options.set(name.toLowerCase(), value);\r\n            } else {\r\n                this.options.set(option.toLowerCase(), true);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 解析參數列表 (key=value 格式)\r\n     * @param {string[]} tokens 參數標記\r\n     * @returns {Object} 參數對象\r\n     */\r\n    parseParameters(tokens) {\r\n        const params = {};\r\n        \r\n        for (const token of tokens) {\r\n            const equalIndex = token.indexOf('=');\r\n            if (equalIndex > 0) {\r\n                const key = token.substring(0, equalIndex).toLowerCase();\r\n                const value = token.substring(equalIndex + 1);\r\n                \r\n                // 保持字符串格式，讓各個組件自己處理工程記號\r\n                // 只有明確的純數字才轉換為數字類型\r\n                const trimmedValue = value.trim();\r\n                if (/^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$/.test(trimmedValue)) {\r\n                    // 純數字（包括科學記號）\r\n                    const numValue = parseFloat(trimmedValue);\r\n                    params[key] = isNaN(numValue) ? value : numValue;\r\n                } else {\r\n                    // 包含單位後綴或其他文本，保持字符串\r\n                    params[key] = value;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return params;\r\n    }\r\n\r\n    /**\r\n     * 獲取解析統計信息\r\n     * @returns {Object} 統計信息\r\n     */\r\n    getStats() {\r\n        return {\r\n            ...this.stats,\r\n            componentCount: this.components.length,\r\n            modelCount: this.models.size,\r\n            parameterCount: this.parameters.size,\r\n            analysisCount: this.analyses.length\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 解析工程記號值的助手方法\r\n     * @param {string|number} value 要解析的值\r\n     * @returns {number} 解析後的數值\r\n     */\r\n    parseValue(value) {\r\n        if (typeof value === 'number') return value;\r\n        if (typeof value !== 'string') return null;\r\n        \r\n        const str = value.toString().trim().toLowerCase();\r\n        const numberPart = parseFloat(str);\r\n        if (isNaN(numberPart)) return null;\r\n        \r\n        // 檢查工程記號後綴\r\n        const suffix = str.slice(numberPart.toString().length);\r\n        switch (suffix) {\r\n            case 'p': case 'pico': return numberPart * 1e-12;\r\n            case 'n': case 'nano': return numberPart * 1e-9;\r\n            case 'u': case 'μ': case 'micro': return numberPart * 1e-6;\r\n            case 'm': case 'milli': return numberPart * 1e-3;\r\n            case 'k': case 'kilo': return numberPart * 1e3;\r\n            case 'meg': case 'mega': return numberPart * 1e6;\r\n            case 'g': case 'giga': return numberPart * 1e9;\r\n            case 't': case 'tera': return numberPart * 1e12;\r\n            case '': return numberPart;\r\n            default: return numberPart; // 未知後綴，返回數字部分\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 打印解析報告\r\n     */\r\n    printReport() {\r\n        console.log('\\\\n=== Netlist Parsing Report ===');\r\n        console.log(`Total lines: ${this.stats.totalLines}`);\r\n        console.log(`Parsed lines: ${this.stats.parsedLines}`);\r\n        console.log(`Skipped lines: ${this.stats.skippedLines}`);\r\n        console.log(`Errors: ${this.stats.errors.length}`);\r\n        \r\n        console.log(`\\\\nComponents: ${this.components.length}`);\r\n        const componentTypes = {};\r\n        for (const comp of this.components) {\r\n            componentTypes[comp.type] = (componentTypes[comp.type] || 0) + 1;\r\n        }\r\n        for (const [type, count] of Object.entries(componentTypes)) {\r\n            console.log(`  ${type}: ${count}`);\r\n        }\r\n        \r\n        if (this.analyses.length > 0) {\r\n            console.log(`\\\\nAnalyses: ${this.analyses.length}`);\r\n            for (const analysis of this.analyses) {\r\n                console.log(`  ${analysis.type}`);\r\n            }\r\n        }\r\n        \r\n        if (this.stats.errors.length > 0) {\r\n            console.log('\\\\nErrors:');\r\n            for (const error of this.stats.errors) {\r\n                console.log(`  Line ${error.line}: ${error.error}`);\r\n                console.log(`    \"${error.content}\"`);\r\n            }\r\n        }\r\n        \r\n        console.log('==============================\\\\n');\r\n    }\r\n}","/**\r\n * 線性代數核心 - LU分解求解器\r\n * \r\n * 這是AkingSPICE的數值計算核心，負責求解 Ax = z 形式的線性方程組。\r\n * 使用LU分解方法，這是求解中等規模稠密或稀疏矩陣的標準高效方法。\r\n */\r\n\r\n/**\r\n * 矩陣類 - 提供基本的矩陣操作\r\n */\r\nexport class Matrix {\r\n    /**\r\n     * @param {number} rows 矩陣行數\r\n     * @param {number} cols 矩陣列數\r\n     * @param {number[][]} data 可選的初始數據\r\n     */\r\n    constructor(rows, cols, data = null) {\r\n        this.rows = rows;\r\n        this.cols = cols;\r\n        \r\n        if (data) {\r\n            this.data = data;\r\n        } else {\r\n            this.data = Array(rows).fill().map(() => Array(cols).fill(0));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 獲取元素值\r\n     * @param {number} i 行索引 (0-based)\r\n     * @param {number} j 列索引 (0-based)\r\n     * @returns {number}\r\n     */\r\n    get(i, j) {\r\n        if (i < 0 || i >= this.rows || j < 0 || j >= this.cols) {\r\n            throw new Error(`Matrix index out of bounds: (${i}, ${j})`);\r\n        }\r\n        return this.data[i][j];\r\n    }\r\n\r\n    /**\r\n     * 設置元素值\r\n     * @param {number} i 行索引\r\n     * @param {number} j 列索引\r\n     * @param {number} value 要設置的值\r\n     */\r\n    set(i, j, value) {\r\n        if (i < 0 || i >= this.rows || j < 0 || j >= this.cols) {\r\n            throw new Error(`Matrix index out of bounds: (${i}, ${j})`);\r\n        }\r\n        this.data[i][j] = value;\r\n    }\r\n\r\n    /**\r\n     * 累加元素值 (常用於組裝MNA矩陣)\r\n     * @param {number} i 行索引\r\n     * @param {number} j 列索引\r\n     * @param {number} value 要累加的值\r\n     */\r\n    addAt(i, j, value) {\r\n        this.data[i][j] += value;\r\n    }\r\n\r\n    /**\r\n     * 創建單位矩陣\r\n     * @param {number} size 矩陣大小\r\n     * @returns {Matrix}\r\n     */\r\n    static identity(size) {\r\n        const matrix = new Matrix(size, size);\r\n        for (let i = 0; i < size; i++) {\r\n            matrix.set(i, i, 1);\r\n        }\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * 創建零矩陣\r\n     * @param {number} rows 行數\r\n     * @param {number} cols 列數\r\n     * @returns {Matrix}\r\n     */\r\n    static zeros(rows, cols = rows) {\r\n        return new Matrix(rows, cols);\r\n    }\r\n\r\n    /**\r\n     * 矩陣複製\r\n     * @returns {Matrix}\r\n     */\r\n    clone() {\r\n        const newData = this.data.map(row => [...row]);\r\n        return new Matrix(this.rows, this.cols, newData);\r\n    }\r\n\r\n    /**\r\n     * 檢查矩陣是否為方陣\r\n     * @returns {boolean}\r\n     */\r\n    isSquare() {\r\n        return this.rows === this.cols;\r\n    }\r\n\r\n    /**\r\n     * 打印矩陣 (調試用)\r\n     * @param {number} precision 小數點後位數\r\n     */\r\n    print(precision = 6) {\r\n        console.log('Matrix:');\r\n        for (let i = 0; i < this.rows; i++) {\r\n            const row = this.data[i].map(val => val.toFixed(precision)).join('  ');\r\n            console.log(`[${row}]`);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * 向量類 - 本質上是單列矩陣的特殊形式\r\n */\r\nexport class Vector {\r\n    /**\r\n     * @param {number} size 向量大小\r\n     * @param {number[]} data 可選的初始數據\r\n     */\r\n    constructor(size, data = null) {\r\n        this.size = size;\r\n        this.data = data ? [...data] : Array(size).fill(0);\r\n    }\r\n\r\n    /**\r\n     * 獲取元素值\r\n     * @param {number} i 索引\r\n     * @returns {number}\r\n     */\r\n    get(i) {\r\n        if (i < 0 || i >= this.size) {\r\n            throw new Error(`Vector index out of bounds: ${i}`);\r\n        }\r\n        return this.data[i];\r\n    }\r\n\r\n    /**\r\n     * 設置元素值\r\n     * @param {number} i 索引\r\n     * @param {number} value 值\r\n     */\r\n    set(i, value) {\r\n        if (i < 0 || i >= this.size) {\r\n            throw new Error(`Vector index out of bounds: ${i}`);\r\n        }\r\n        this.data[i] = value;\r\n    }\r\n\r\n    /**\r\n     * 累加元素值\r\n     * @param {number} i 索引\r\n     * @param {number} value 要累加的值\r\n     */\r\n    addAt(i, value) {\r\n        this.data[i] += value;\r\n    }\r\n\r\n    /**\r\n     * 創建零向量\r\n     * @param {number} size 大小\r\n     * @returns {Vector}\r\n     */\r\n    static zeros(size) {\r\n        return new Vector(size);\r\n    }\r\n\r\n    /**\r\n     * 向量複製\r\n     * @returns {Vector}\r\n     */\r\n    clone() {\r\n        return new Vector(this.size, this.data);\r\n    }\r\n\r\n    /**\r\n     * 打印向量 (調試用)\r\n     * @param {number} precision 小數點後位數\r\n     */\r\n    print(precision = 6) {\r\n        const values = this.data.map(val => val.toFixed(precision)).join(', ');\r\n        console.log(`Vector: [${values}]`);\r\n    }\r\n}\r\n\r\n/**\r\n * LU分解求解器\r\n * \r\n * 實現帶部分主元選擇的LU分解算法，用於求解線性方程組 Ax = b\r\n * 這是電路模擬器的數值核心，所有MNA矩陣最終都通過這裡求解。\r\n */\r\nexport class LUSolver {\r\n    /**\r\n     * 求解線性方程組 Ax = b\r\n     * @param {Matrix} A 係數矩陣 (將被修改)\r\n     * @param {Vector} b 右手邊向量 (將被修改)\r\n     * @returns {Vector} 解向量 x\r\n     */\r\n    static solve(A, b) {\r\n        if (!A.isSquare()) {\r\n            throw new Error('Matrix A must be square');\r\n        }\r\n        \r\n        if (A.rows !== b.size) {\r\n            throw new Error('Matrix A and vector b dimensions do not match');\r\n        }\r\n\r\n        const n = A.rows;\r\n        const x = b.clone();\r\n        \r\n        // Step 1: LU分解 (帶部分主元選擇)\r\n        const permutation = this.luDecomposition(A);\r\n        \r\n        // Step 2: 應用置換到右手邊向量\r\n        this.applyPermutation(x, permutation);\r\n        \r\n        // Step 3: 前向替代 (Forward Substitution) - 求解 Ly = b\r\n        this.forwardSubstitution(A, x);\r\n        \r\n        // Step 4: 後向替代 (Backward Substitution) - 求解 Ux = y\r\n        this.backwardSubstitution(A, x);\r\n        \r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * LU分解 (帶部分主元選擇)\r\n     * 在原矩陣上進行分解，L存儲在下三角部分，U存儲在上三角部分\r\n     * @param {Matrix} A 要分解的矩陣 (會被修改)\r\n     * @returns {number[]} 置換向量\r\n     */\r\n    static luDecomposition(A) {\r\n        const n = A.rows;\r\n        const permutation = Array.from({length: n}, (_, i) => i);\r\n\r\n        for (let k = 0; k < n - 1; k++) {\r\n            // 部分主元選擇 - 找到第k列中絕對值最大的元素\r\n            let maxRow = k;\r\n            let maxVal = Math.abs(A.get(k, k));\r\n            \r\n            for (let i = k + 1; i < n; i++) {\r\n                const val = Math.abs(A.get(i, k));\r\n                if (val > maxVal) {\r\n                    maxVal = val;\r\n                    maxRow = i;\r\n                }\r\n            }\r\n\r\n            // 檢查奇異性\r\n            if (maxVal < 1e-14) {\r\n                throw new Error(`Matrix is singular or nearly singular at column ${k}`);\r\n            }\r\n\r\n            // 交換行\r\n            if (maxRow !== k) {\r\n                this.swapRows(A, k, maxRow);\r\n                [permutation[k], permutation[maxRow]] = [permutation[maxRow], permutation[k]];\r\n            }\r\n\r\n            // 高斯消元\r\n            const pivot = A.get(k, k);\r\n            for (let i = k + 1; i < n; i++) {\r\n                const factor = A.get(i, k) / pivot;\r\n                A.set(i, k, factor); // 存儲L矩陣的元素\r\n                \r\n                for (let j = k + 1; j < n; j++) {\r\n                    const newVal = A.get(i, j) - factor * A.get(k, j);\r\n                    A.set(i, j, newVal);\r\n                }\r\n            }\r\n        }\r\n\r\n        // 檢查最後一個對角元素\r\n        if (Math.abs(A.get(n-1, n-1)) < 1e-14) {\r\n            throw new Error('Matrix is singular or nearly singular');\r\n        }\r\n\r\n        return permutation;\r\n    }\r\n\r\n    /**\r\n     * 交換矩陣的兩行\r\n     * @param {Matrix} A 矩陣\r\n     * @param {number} row1 行1\r\n     * @param {number} row2 行2\r\n     */\r\n    static swapRows(A, row1, row2) {\r\n        if (row1 === row2) return;\r\n        \r\n        for (let j = 0; j < A.cols; j++) {\r\n            const temp = A.get(row1, j);\r\n            A.set(row1, j, A.get(row2, j));\r\n            A.set(row2, j, temp);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 應用置換到向量\r\n     * @param {Vector} x 向量 (會被修改)\r\n     * @param {number[]} permutation 置換向量\r\n     */\r\n    static applyPermutation(x, permutation) {\r\n        const temp = Array(x.size);\r\n        for (let i = 0; i < x.size; i++) {\r\n            temp[i] = x.get(permutation[i]);\r\n        }\r\n        for (let i = 0; i < x.size; i++) {\r\n            x.set(i, temp[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 前向替代 - 求解 Ly = b (其中L的對角元素為1)\r\n     * @param {Matrix} LU LU分解後的矩陣\r\n     * @param {Vector} x 向量 (會被修改)\r\n     */\r\n    static forwardSubstitution(LU, x) {\r\n        const n = x.size;\r\n        \r\n        for (let i = 0; i < n; i++) {\r\n            let sum = 0;\r\n            for (let j = 0; j < i; j++) {\r\n                sum += LU.get(i, j) * x.get(j);\r\n            }\r\n            x.set(i, x.get(i) - sum);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 後向替代 - 求解 Ux = y\r\n     * @param {Matrix} LU LU分解後的矩陣\r\n     * @param {Vector} x 向量 (會被修改)\r\n     */\r\n    static backwardSubstitution(LU, x) {\r\n        const n = x.size;\r\n        \r\n        for (let i = n - 1; i >= 0; i--) {\r\n            let sum = 0;\r\n            for (let j = i + 1; j < n; j++) {\r\n                sum += LU.get(i, j) * x.get(j);\r\n            }\r\n            x.set(i, (x.get(i) - sum) / LU.get(i, i));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 矩陣條件數估算 (用於數值穩定性檢查)\r\n     * @param {Matrix} A 原矩陣\r\n     * @returns {number} 估算的條件數\r\n     */\r\n    static estimateConditionNumber(A) {\r\n        // 簡單的條件數估算：最大對角元素 / 最小對角元素\r\n        let maxDiag = 0;\r\n        let minDiag = Infinity;\r\n        \r\n        for (let i = 0; i < A.rows; i++) {\r\n            const val = Math.abs(A.get(i, i));\r\n            maxDiag = Math.max(maxDiag, val);\r\n            minDiag = Math.min(minDiag, val);\r\n        }\r\n        \r\n        return minDiag > 1e-14 ? maxDiag / minDiag : Infinity;\r\n    }\r\n}\r\n\r\n/**\r\n * 數值工具函數\r\n */\r\nexport class NumericalUtils {\r\n    /**\r\n     * 檢查兩個數值是否在容差範圍內相等\r\n     * @param {number} a 數值a\r\n     * @param {number} b 數值b\r\n     * @param {number} tolerance 容差\r\n     * @returns {boolean}\r\n     */\r\n    static isClose(a, b, tolerance = 1e-12) {\r\n        return Math.abs(a - b) <= tolerance;\r\n    }\r\n\r\n    /**\r\n     * 檢查向量的收斂性 (用於Newton-Raphson迭代)\r\n     * @param {Vector} x1 舊解\r\n     * @param {Vector} x2 新解\r\n     * @param {number} tolerance 收斂容差\r\n     * @returns {boolean}\r\n     */\r\n    static hasConverged(x1, x2, tolerance = 1e-9) {\r\n        for (let i = 0; i < x1.size; i++) {\r\n            const relError = Math.abs(x2.get(i) - x1.get(i)) / (Math.abs(x2.get(i)) + 1e-12);\r\n            if (relError > tolerance) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * 計算向量的無窮範數 (最大絕對值)\r\n     * @param {Vector} x 向量\r\n     * @returns {number}\r\n     */\r\n    static infinityNorm(x) {\r\n        let maxVal = 0;\r\n        for (let i = 0; i < x.size; i++) {\r\n            maxVal = Math.max(maxVal, Math.abs(x.get(i)));\r\n        }\r\n        return maxVal;\r\n    }\r\n}","/**\r\n * 修正節點分析法 (Modified Nodal Analysis, MNA) 核心\r\n * \r\n * MNA是建立電路方程式的標準工業方法，能夠同時處理：\r\n * - 電阻、電容、電感等雙端元件\r\n * - 電壓源、電流源\r\n * - 受控源等複雜元件\r\n * \r\n * 基本概念：\r\n * - 對每個節點寫KCL方程式\r\n * - 對每個電壓源寫額外的約束方程式\r\n * - 形成 [G C; B D] * [v; j] = [i; e] 的線性方程組\r\n */\r\n\r\nimport { Matrix, Vector } from './linalg.js';\r\n\r\n/**\r\n * MNA矩陣生成器\r\n * 負責從電路元件列表生成MNA矩陣和右手邊向量\r\n */\r\nexport class MNABuilder {\r\n    constructor() {\r\n        // 節點映射：節點名稱 -> 矩陣索引\r\n        this.nodeMap = new Map();\r\n        this.nodeCount = 0;\r\n        \r\n        // 電壓源映射：電壓源名稱 -> 電流變數索引\r\n        this.voltageSourceMap = new Map();\r\n        this.voltageSourceCount = 0;\r\n        \r\n        // 矩陣維度\r\n        this.matrixSize = 0;\r\n        \r\n        // MNA矩陣和向量\r\n        this.matrix = null;\r\n        this.rhs = null;\r\n        \r\n        // 調試信息\r\n        this.debugInfo = {\r\n            nodeNames: [],\r\n            voltageSourceNames: [],\r\n            matrixLabels: []\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 重置建構器，準備處理新電路\r\n     */\r\n    reset() {\r\n        this.nodeMap.clear();\r\n        this.nodeCount = 0;\r\n        this.voltageSourceMap.clear();\r\n        this.voltageSourceCount = 0;\r\n        this.matrixSize = 0;\r\n        this.matrix = null;\r\n        this.rhs = null;\r\n        this.debugInfo = {\r\n            nodeNames: [],\r\n            voltageSourceNames: [],\r\n            matrixLabels: []\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 分析電路並建立節點映射\r\n     * @param {BaseComponent[]} components 電路元件列表\r\n     */\r\n    analyzeCircuit(components) {\r\n        this.reset();\r\n        \r\n        // 首先收集所有節點\r\n        const nodeSet = new Set();\r\n        const voltageSourceSet = new Set();\r\n        \r\n        for (const component of components) {\r\n            // 收集節點\r\n            if (component.nodes) {\r\n                for (const node of component.nodes) {\r\n                    if (node !== '0' && node !== 'gnd') { // 排除接地節點\r\n                        nodeSet.add(node);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // 收集電壓源 (需要額外的電流變數)\r\n            if (component.type === 'V' || component.needsCurrentVariable()) {\r\n                voltageSourceSet.add(component.name);\r\n            }\r\n        }\r\n\r\n        // 建立節點映射 (接地節點不包含在矩陣中)\r\n        let nodeIndex = 0;\r\n        for (const node of Array.from(nodeSet).sort()) {\r\n            this.nodeMap.set(node, nodeIndex);\r\n            this.debugInfo.nodeNames.push(node);\r\n            nodeIndex++;\r\n        }\r\n        this.nodeCount = nodeIndex;\r\n\r\n        // 建立電壓源映射\r\n        let vsIndex = 0;\r\n        for (const vsName of Array.from(voltageSourceSet).sort()) {\r\n            this.voltageSourceMap.set(vsName, this.nodeCount + vsIndex);\r\n            this.debugInfo.voltageSourceNames.push(vsName);\r\n            vsIndex++;\r\n        }\r\n        this.voltageSourceCount = vsIndex;\r\n\r\n        // 計算總矩陣大小\r\n        this.matrixSize = this.nodeCount + this.voltageSourceCount;\r\n        \r\n        // 建立調試標籤\r\n        this.debugInfo.matrixLabels = [\r\n            ...this.debugInfo.nodeNames.map(name => `V(${name})`),\r\n            ...this.debugInfo.voltageSourceNames.map(name => `I(${name})`)\r\n        ];\r\n\r\n        console.log(`MNA Analysis: ${this.nodeCount} nodes, ${this.voltageSourceCount} voltage sources, matrix size: ${this.matrixSize}x${this.matrixSize}`);\r\n    }\r\n\r\n    /**\r\n     * 建立MNA矩陣\r\n     * @param {BaseComponent[]} components 電路元件列表\r\n     * @param {number} time 當前時間 (用於時變元件)\r\n     * @returns {{matrix: Matrix, rhs: Vector}}\r\n     */\r\n    buildMNAMatrix(components, time = 0) {\r\n        if (this.matrixSize === 0) {\r\n            throw new Error('Circuit not analyzed. Call analyzeCircuit() first.');\r\n        }\r\n\r\n        // 初始化矩陣和右手邊向量\r\n        this.matrix = Matrix.zeros(this.matrixSize, this.matrixSize);\r\n        this.rhs = Vector.zeros(this.matrixSize);\r\n\r\n        // 逐個添加元件的貢獻\r\n        for (const component of components) {\r\n            try {\r\n                this.stampComponent(component, time);\r\n            } catch (error) {\r\n                throw new Error(`Failed to stamp component ${component.name}: ${error.message}`);\r\n            }\r\n        }\r\n\r\n        return {\r\n            matrix: this.matrix,\r\n            rhs: this.rhs\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 將元件的貢獻添加到MNA矩陣中 (Stamping)\r\n     * @param {BaseComponent} component 電路元件\r\n     * @param {number} time 當前時間\r\n     */\r\n    stampComponent(component, time) {\r\n        switch (component.type) {\r\n            case 'R':\r\n                this.stampResistor(component);\r\n                break;\r\n            case 'C':\r\n                this.stampCapacitor(component);\r\n                break;\r\n            case 'L':\r\n                this.stampInductor(component);\r\n                break;\r\n            case 'V':\r\n                this.stampVoltageSource(component, time);\r\n                break;\r\n            case 'I':\r\n                this.stampCurrentSource(component, time);\r\n                break;\r\n            case 'VCVS': // 壓控電壓源\r\n                this.stampVCVS(component);\r\n                break;\r\n            case 'VCCS': // 壓控電流源\r\n                this.stampVCCS(component);\r\n                break;\r\n            default:\r\n                if (typeof component.stamp === 'function') {\r\n                    // 允許自定義元件實現自己的stamp方法\r\n                    component.stamp(this.matrix, this.rhs, this.nodeMap, this.voltageSourceMap, time);\r\n                } else {\r\n                    console.warn(`Unknown component type: ${component.type} (${component.name})`);\r\n                }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 電阻的MNA印記\r\n     * 在節點i和j之間添加電導 G = 1/R\r\n     */\r\n    stampResistor(resistor) {\r\n        const nodes = resistor.nodes;\r\n        const conductance = 1 / resistor.value;\r\n        \r\n        const n1 = this.getNodeIndex(nodes[0]);\r\n        const n2 = this.getNodeIndex(nodes[1]);\r\n\r\n        // G矩陣的印記: G[i,i] += G, G[j,j] += G, G[i,j] -= G, G[j,i] -= G\r\n        if (n1 >= 0) {\r\n            this.matrix.addAt(n1, n1, conductance);\r\n            if (n2 >= 0) {\r\n                this.matrix.addAt(n1, n2, -conductance);\r\n            }\r\n        }\r\n        \r\n        if (n2 >= 0) {\r\n            this.matrix.addAt(n2, n2, conductance);\r\n            if (n1 >= 0) {\r\n                this.matrix.addAt(n2, n1, -conductance);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 電容的MNA印記 (用於暫態分析)\r\n     * 使用伴隨模型: i_c(t) = C * dv/dt ≈ C/h * (v(t) - v(t-h)) + i_hist\r\n     * 其中 h 是時間步長\r\n     */\r\n    stampCapacitor(capacitor) {\r\n        if (!capacitor.timeStep) {\r\n            // 在DC分析中，電容視為開路\r\n            return;\r\n        }\r\n\r\n        const nodes = capacitor.nodes;\r\n        const C = capacitor.value;\r\n        const h = capacitor.timeStep;\r\n        const Geq = C / h; // 等效電導\r\n\r\n        const n1 = this.getNodeIndex(nodes[0]);\r\n        const n2 = this.getNodeIndex(nodes[1]);\r\n\r\n        // 等效電導的印記\r\n        if (n1 >= 0) {\r\n            this.matrix.addAt(n1, n1, Geq);\r\n            if (n2 >= 0) {\r\n                this.matrix.addAt(n1, n2, -Geq);\r\n            }\r\n        }\r\n        \r\n        if (n2 >= 0) {\r\n            this.matrix.addAt(n2, n2, Geq);\r\n            if (n1 >= 0) {\r\n                this.matrix.addAt(n2, n1, -Geq);\r\n            }\r\n        }\r\n\r\n        // 歷史電流項 (右手邊)\r\n        if (capacitor.historyTerm !== undefined) {\r\n            if (n1 >= 0) {\r\n                this.rhs.addAt(n1, -capacitor.historyTerm);\r\n            }\r\n            if (n2 >= 0) {\r\n                this.rhs.addAt(n2, capacitor.historyTerm);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 電感的MNA印記 (需要電流變數)\r\n     * 使用伴隨模型: v_L(t) = L * di/dt ≈ L/h * (i(t) - i(t-h))\r\n     */\r\n    /**\r\n     * 電感的MNA印記 (需要電流變數)\r\n     * 🔥 修正版：支援耦合電感（互感）\r\n     */\r\n    stampInductor(inductor) {\r\n        const nodes = inductor.nodes;\r\n        const L = inductor.getInductance(); // 使用 getInductance()\r\n        \r\n        const n1 = this.getNodeIndex(nodes[0]);\r\n        const n2 = this.getNodeIndex(nodes[1]);\r\n        const currIndex = this.voltageSourceMap.get(inductor.name);\r\n        \r\n        if (currIndex === undefined) {\r\n            throw new Error(`Inductor ${inductor.name} current variable not found`);\r\n        }\r\n\r\n        // B矩陣和C矩陣：電流從節點流出的關係\r\n        // V_n1 - V_n2 - V_L = 0  =>  V_n1 - V_n2 = V_L\r\n        if (n1 >= 0) {\r\n            this.matrix.addAt(n1, currIndex, 1);\r\n            this.matrix.addAt(currIndex, n1, 1);\r\n        }\r\n        if (n2 >= 0) {\r\n            this.matrix.addAt(n2, currIndex, -1);\r\n            this.matrix.addAt(currIndex, n2, -1);\r\n        }\r\n\r\n        // D矩陣：電感的電壓-電流關係\r\n        if (inductor.timeStep) {\r\n            // 瞬時分析：V_L = L * di/dt\r\n            const h = inductor.timeStep;\r\n            \r\n            // 1. 印花自感項\r\n            this.matrix.addAt(currIndex, currIndex, -L / h);\r\n            \r\n            // 2. 印花歷史項（來自自感）\r\n            if (inductor.historyTerm !== undefined) {\r\n                this.rhs.addAt(currIndex, -L / h * inductor.historyTerm);\r\n            }\r\n\r\n            // 🔥 3. 印花互感項\r\n            if (inductor.couplings) {\r\n                for (const coupling of inductor.couplings) {\r\n                    const otherInductor = coupling.inductor;\r\n                    const M = coupling.mutualInductance;\r\n                    \r\n                    // 獲取另一個電感的電流變數索引\r\n                    const otherCurrIndex = this.voltageSourceMap.get(otherInductor.name);\r\n                    if (otherCurrIndex === undefined) {\r\n                        throw new Error(`Coupled inductor ${otherInductor.name} not found for ${inductor.name}`);\r\n                    }\r\n\r\n                    // 添加互感對矩陣的貢獻 (V_L += M * dI_other/dt)\r\n                    this.matrix.addAt(currIndex, otherCurrIndex, -M / h);\r\n                    \r\n                    // 添加互感對歷史項的貢獻\r\n                    if (otherInductor.historyTerm !== undefined) {\r\n                        this.rhs.addAt(currIndex, -M / h * otherInductor.historyTerm);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            // DC 分析：電感表現為短路，V_L = 0\r\n            // 直接設置電壓約束 V_n1 - V_n2 = 0\r\n            // 這已經在上面的 B 和 C 矩陣中處理了\r\n            \r\n            // 添加電感的寄生電阻（如果有的話）\r\n            const R = inductor.resistance || 1e-9; // 添加極小電阻避免數值問題\r\n            this.matrix.addAt(currIndex, currIndex, -R);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 電壓源的MNA印記\r\n     */\r\n    stampVoltageSource(voltageSource, time) {\r\n        const nodes = voltageSource.nodes;\r\n        const n1 = this.getNodeIndex(nodes[0]); // 正端\r\n        const n2 = this.getNodeIndex(nodes[1]); // 負端\r\n        const currIndex = this.voltageSourceMap.get(voltageSource.name);\r\n        \r\n        if (currIndex === undefined) {\r\n            throw new Error(`Voltage source ${voltageSource.name} current variable not found`);\r\n        }\r\n\r\n        // B矩陣和C矩陣: 電流約束\r\n        if (n1 >= 0) {\r\n            this.matrix.addAt(n1, currIndex, 1);\r\n            this.matrix.addAt(currIndex, n1, 1);\r\n        }\r\n        if (n2 >= 0) {\r\n            this.matrix.addAt(n2, currIndex, -1);\r\n            this.matrix.addAt(currIndex, n2, -1);\r\n        }\r\n\r\n        // E向量: 電壓約束\r\n        const voltage = voltageSource.getValue(time);\r\n        this.rhs.addAt(currIndex, voltage);\r\n    }\r\n\r\n    /**\r\n     * 電流源的MNA印記\r\n     */\r\n    stampCurrentSource(currentSource, time) {\r\n        const nodes = currentSource.nodes;\r\n        const n1 = this.getNodeIndex(nodes[0]); // 電流流出的節點\r\n        const n2 = this.getNodeIndex(nodes[1]); // 電流流入的節點\r\n        \r\n        const current = currentSource.getValue(time);\r\n        \r\n        // I向量: 注入電流\r\n        if (n1 >= 0) {\r\n            this.rhs.addAt(n1, -current);\r\n        }\r\n        if (n2 >= 0) {\r\n            this.rhs.addAt(n2, current);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 壓控電壓源 (VCVS) 的印記\r\n     * E * V_control = V_output\r\n     */\r\n    stampVCVS(vcvs) {\r\n        const outputNodes = [vcvs.nodes[0], vcvs.nodes[1]]; // 輸出節點\r\n        const controlNodes = [vcvs.nodes[2], vcvs.nodes[3]]; // 控制節點\r\n        const gain = vcvs.value;\r\n        \r\n        const no1 = this.getNodeIndex(outputNodes[0]);\r\n        const no2 = this.getNodeIndex(outputNodes[1]);\r\n        const nc1 = this.getNodeIndex(controlNodes[0]);\r\n        const nc2 = this.getNodeIndex(controlNodes[1]);\r\n        const currIndex = this.voltageSourceMap.get(vcvs.name);\r\n\r\n        // 類似電壓源的處理，但右手邊是控制電壓的函數\r\n        if (no1 >= 0) {\r\n            this.matrix.addAt(no1, currIndex, 1);\r\n            this.matrix.addAt(currIndex, no1, 1);\r\n        }\r\n        if (no2 >= 0) {\r\n            this.matrix.addAt(no2, currIndex, -1);\r\n            this.matrix.addAt(currIndex, no2, -1);\r\n        }\r\n\r\n        // 控制關係: V_out = gain * (V_c1 - V_c2)\r\n        if (nc1 >= 0) {\r\n            this.matrix.addAt(currIndex, nc1, -gain);\r\n        }\r\n        if (nc2 >= 0) {\r\n            this.matrix.addAt(currIndex, nc2, gain);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 壓控電流源 (VCCS) 的印記  \r\n     * I_output = gm * V_control\r\n     */\r\n    stampVCCS(vccs) {\r\n        const outputNodes = [vccs.nodes[0], vccs.nodes[1]]; // 輸出節點\r\n        const controlNodes = [vccs.nodes[2], vccs.nodes[3]]; // 控制節點\r\n        const transconductance = vccs.value; // gm\r\n        \r\n        const no1 = this.getNodeIndex(outputNodes[0]);\r\n        const no2 = this.getNodeIndex(outputNodes[1]);\r\n        const nc1 = this.getNodeIndex(controlNodes[0]);\r\n        const nc2 = this.getNodeIndex(controlNodes[1]);\r\n\r\n        // G矩陣的修改: 添加跨導項\r\n        if (no1 >= 0 && nc1 >= 0) {\r\n            this.matrix.addAt(no1, nc1, transconductance);\r\n        }\r\n        if (no1 >= 0 && nc2 >= 0) {\r\n            this.matrix.addAt(no1, nc2, -transconductance);\r\n        }\r\n        if (no2 >= 0 && nc1 >= 0) {\r\n            this.matrix.addAt(no2, nc1, -transconductance);\r\n        }\r\n        if (no2 >= 0 && nc2 >= 0) {\r\n            this.matrix.addAt(no2, nc2, transconductance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 獲取節點在矩陣中的索引\r\n     * @param {string} nodeName 節點名稱\r\n     * @returns {number} 矩陣索引，如果是接地節點則返回-1\r\n     */\r\n    getNodeIndex(nodeName) {\r\n        if (nodeName === '0' || nodeName === 'gnd') {\r\n            return -1; // 接地節點\r\n        }\r\n        \r\n        const index = this.nodeMap.get(nodeName);\r\n        if (index === undefined) {\r\n            throw new Error(`Node ${nodeName} not found in circuit`);\r\n        }\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * 從解向量中提取節點電壓\r\n     * @param {Vector} solution MNA求解結果\r\n     * @returns {Map<string, number>} 節點名稱 -> 電壓值的映射\r\n     */\r\n    extractNodeVoltages(solution) {\r\n        const voltages = new Map();\r\n        \r\n        // 接地節點電壓為0\r\n        voltages.set('0', 0);\r\n        voltages.set('gnd', 0);\r\n        \r\n        // 其他節點電壓\r\n        for (const [nodeName, index] of this.nodeMap) {\r\n            voltages.set(nodeName, solution.get(index));\r\n        }\r\n        \r\n        return voltages;\r\n    }\r\n\r\n    /**\r\n     * 從解向量中提取電壓源電流\r\n     * @param {Vector} solution MNA求解結果\r\n     * @returns {Map<string, number>} 電壓源名稱 -> 電流值的映射\r\n     */\r\n    extractVoltageSourceCurrents(solution) {\r\n        const currents = new Map();\r\n        \r\n        for (const [vsName, index] of this.voltageSourceMap) {\r\n            currents.set(vsName, solution.get(index));\r\n        }\r\n        \r\n        return currents;\r\n    }\r\n\r\n    /**\r\n     * 打印MNA矩陣 (調試用)\r\n     * @param {number} precision 小數點位數\r\n     */\r\n    printMNAMatrix(precision = 4) {\r\n        console.log('\\n=== MNA Matrix ===');\r\n        \r\n        // 打印標題行\r\n        const header = '     ' + this.debugInfo.matrixLabels.map(label => \r\n            label.padStart(12)).join('');\r\n        console.log(header + '     RHS');\r\n        \r\n        // 打印矩陣行\r\n        for (let i = 0; i < this.matrixSize; i++) {\r\n            const rowLabel = this.debugInfo.matrixLabels[i].padStart(4);\r\n            let row = rowLabel + ' ';\r\n            \r\n            for (let j = 0; j < this.matrixSize; j++) {\r\n                const val = this.matrix.get(i, j);\r\n                row += val.toFixed(precision).padStart(12);\r\n            }\r\n            \r\n            row += ' | ' + this.rhs.get(i).toFixed(precision).padStart(10);\r\n            console.log(row);\r\n        }\r\n        console.log('==================\\n');\r\n    }\r\n\r\n    /**\r\n     * 獲取矩陣信息 (用於調試和分析)\r\n     * @returns {Object} 包含矩陣信息的對象\r\n     */\r\n    getMatrixInfo() {\r\n        return {\r\n            nodeCount: this.nodeCount,\r\n            voltageSourceCount: this.voltageSourceCount,\r\n            matrixSize: this.matrixSize,\r\n            nodeNames: [...this.debugInfo.nodeNames],\r\n            voltageSourceNames: [...this.debugInfo.voltageSourceNames],\r\n            matrixLabels: [...this.debugInfo.matrixLabels]\r\n        };\r\n    }\r\n}","/**\r\n * 暫態分析 (Transient Analysis) 實現\r\n * \r\n * 基於後向歐拉法的固定步長時域分析算法\r\n * 這是AkingSPICE v0.1的核心分析引擎\r\n */\r\n\r\nimport { Matrix, Vector, LUSolver } from '../core/linalg.js';\r\nimport { MNABuilder } from '../core/mna.js';\r\n\r\n/**\r\n * 暫態分析結果類\r\n * 存儲和管理時域分析的結果數據\r\n */\r\nexport class TransientResult {\r\n    constructor() {\r\n        this.timeVector = [];\r\n        this.nodeVoltages = new Map(); // nodeName -> voltage array\r\n        this.branchCurrents = new Map(); // branchName -> current array\r\n        this.componentData = new Map(); // componentName -> data array\r\n        this.analysisInfo = {};\r\n    }\r\n\r\n    /**\r\n     * 添加一個時間點的結果\r\n     * @param {number} time 時間點\r\n     * @param {Map<string, number>} voltages 節點電壓\r\n     * @param {Map<string, number>} currents 支路電流\r\n     */\r\n    addTimePoint(time, voltages, currents) {\r\n        this.timeVector.push(time);\r\n        \r\n        // 添加節點電壓\r\n        for (const [nodeName, voltage] of voltages) {\r\n            if (!this.nodeVoltages.has(nodeName)) {\r\n                this.nodeVoltages.set(nodeName, []);\r\n            }\r\n            this.nodeVoltages.get(nodeName).push(voltage);\r\n        }\r\n        \r\n        // 添加支路電流\r\n        for (const [branchName, current] of currents) {\r\n            if (!this.branchCurrents.has(branchName)) {\r\n                this.branchCurrents.set(branchName, []);\r\n            }\r\n            this.branchCurrents.get(branchName).push(current);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 獲取時間向量\r\n     * @returns {number[]} 時間點陣列\r\n     */\r\n    getTimeVector() {\r\n        return [...this.timeVector];\r\n    }\r\n\r\n    /**\r\n     * 獲取節點電壓向量\r\n     * @param {string} nodeName 節點名稱 (如 'V(1)', '1')\r\n     * @returns {number[]} 電壓值陣列\r\n     */\r\n    getVoltageVector(nodeName) {\r\n        // 處理SPICE格式的節點名稱 V(nodeName)\r\n        let actualNodeName = nodeName;\r\n        const voltageMatch = nodeName.match(/^V\\((.+)\\)$/);\r\n        if (voltageMatch) {\r\n            actualNodeName = voltageMatch[1];\r\n        }\r\n        \r\n        return this.nodeVoltages.get(actualNodeName) || [];\r\n    }\r\n\r\n    /**\r\n     * 獲取支路電流向量\r\n     * @param {string} branchName 支路名稱 (如 'I(V1)', 'V1')\r\n     * @returns {number[]} 電流值陣列\r\n     */\r\n    getCurrentVector(branchName) {\r\n        // 處理SPICE格式的電流名稱 I(componentName)\r\n        let actualBranchName = branchName;\r\n        const currentMatch = branchName.match(/^I\\((.+)\\)$/);\r\n        if (currentMatch) {\r\n            actualBranchName = currentMatch[1];\r\n        }\r\n        \r\n        return this.branchCurrents.get(actualBranchName) || [];\r\n    }\r\n\r\n    /**\r\n     * 獲取通用向量 (時間、電壓或電流)\r\n     * @param {string} vectorName 向量名稱\r\n     * @returns {number[]} 數值陣列\r\n     */\r\n    getVector(vectorName) {\r\n        if (vectorName.toLowerCase() === 'time') {\r\n            return this.getTimeVector();\r\n        }\r\n        \r\n        // 嘗試作為電壓獲取\r\n        const voltageVector = this.getVoltageVector(vectorName);\r\n        if (voltageVector.length > 0) {\r\n            return voltageVector;\r\n        }\r\n        \r\n        // 嘗試作為電流獲取\r\n        const currentVector = this.getCurrentVector(vectorName);\r\n        if (currentVector.length > 0) {\r\n            return currentVector;\r\n        }\r\n        \r\n        console.warn(`Vector ${vectorName} not found`);\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * 獲取所有可用的向量名稱\r\n     * @returns {string[]} 向量名稱列表\r\n     */\r\n    getAvailableVectors() {\r\n        const vectors = ['time'];\r\n        \r\n        // 添加電壓向量\r\n        for (const nodeName of this.nodeVoltages.keys()) {\r\n            vectors.push(`V(${nodeName})`);\r\n        }\r\n        \r\n        // 添加電流向量\r\n        for (const branchName of this.branchCurrents.keys()) {\r\n            vectors.push(`I(${branchName})`);\r\n        }\r\n        \r\n        return vectors;\r\n    }\r\n\r\n    /**\r\n     * 獲取分析統計信息\r\n     * @returns {Object} 統計信息\r\n     */\r\n    getAnalysisInfo() {\r\n        const info = {\r\n            ...this.analysisInfo,\r\n            totalTimePoints: this.timeVector.length,\r\n            startTime: this.timeVector[0] || 0,\r\n            stopTime: this.timeVector[this.timeVector.length - 1] || 0,\r\n            availableVectors: this.getAvailableVectors()\r\n        };\r\n        \r\n        if (this.timeVector.length > 1) {\r\n            const timeSteps = [];\r\n            for (let i = 1; i < this.timeVector.length; i++) {\r\n                timeSteps.push(this.timeVector[i] - this.timeVector[i-1]);\r\n            }\r\n            info.averageTimeStep = timeSteps.reduce((sum, step) => sum + step, 0) / timeSteps.length;\r\n            info.minTimeStep = Math.min(...timeSteps);\r\n            info.maxTimeStep = Math.max(...timeSteps);\r\n        }\r\n        \r\n        return info;\r\n    }\r\n}\r\n\r\n/**\r\n * 暫態分析引擎\r\n */\r\nexport class TransientAnalysis {\r\n    constructor() {\r\n        this.mnaBuilder = new MNABuilder();\r\n        this.components = [];\r\n        this.result = null;\r\n        \r\n        // 分析參數\r\n        this.timeStep = 1e-6;     // 預設時間步長: 1µs\r\n        this.startTime = 0;       // 開始時間\r\n        this.stopTime = 1e-3;     // 結束時間: 1ms\r\n        this.maxTimeStep = 1e-6;  // 最大時間步長\r\n        this.minTimeStep = 1e-12; // 最小時間步長\r\n        \r\n        // 數值參數\r\n        this.maxIterations = 50;  // 最大Newton-Raphson迭代次數\r\n        this.convergenceTol = 1e-9; // 收斂容差\r\n        \r\n        // 調試和監控\r\n        this.debug = false;\r\n        this.saveHistory = true;\r\n        this.progressCallback = null;\r\n    }\r\n\r\n    /**\r\n     * 設置分析參數\r\n     * @param {Object} params 參數對象\r\n     */\r\n    setParameters(params) {\r\n        if (params.timeStep !== undefined) this.timeStep = params.timeStep;\r\n        if (params.startTime !== undefined) this.startTime = params.startTime;\r\n        if (params.stopTime !== undefined) this.stopTime = params.stopTime;\r\n        if (params.maxTimeStep !== undefined) this.maxTimeStep = params.maxTimeStep;\r\n        if (params.minTimeStep !== undefined) this.minTimeStep = params.minTimeStep;\r\n        if (params.maxIterations !== undefined) this.maxIterations = params.maxIterations;\r\n        if (params.convergenceTol !== undefined) this.convergenceTol = params.convergenceTol;\r\n        if (params.debug !== undefined) this.debug = params.debug;\r\n        if (params.progressCallback !== undefined) this.progressCallback = params.progressCallback;\r\n    }\r\n\r\n    /**\r\n     * 執行暫態分析\r\n     * @param {BaseComponent[]} components 電路元件列表\r\n     * @param {Object} params 分析參數\r\n     * @returns {TransientResult} 分析結果\r\n     */\r\n    async run(components, params = {}) {\r\n        this.setParameters(params);\r\n        this.components = [...components];\r\n        this.result = new TransientResult();\r\n        \r\n        console.log(`Starting transient analysis: ${this.startTime}s to ${this.stopTime}s, step=${this.timeStep}s`);\r\n        \r\n        try {\r\n            // 初始化\r\n            await this.initialize();\r\n            \r\n            // 主時域迴圈\r\n            await this.timeLoop();\r\n            \r\n            // 完成分析\r\n            this.finalize();\r\n            \r\n            console.log(`Transient analysis completed: ${this.result.timeVector.length} time points`);\r\n            return this.result;\r\n            \r\n        } catch (error) {\r\n            console.error('Transient analysis failed:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 初始化分析\r\n     */\r\n    /**\r\n     * 初始化暫態分析\r\n     * @param {BaseComponent[]} components 元件列表\r\n     * @param {number} timeStep 時間步長\r\n     */\r\n    async initialize(components = null, timeStep = null) {\r\n        // 如果提供了元件列表，使用它\r\n        if (components) {\r\n            this.components = [...components];\r\n        }\r\n        \r\n        // 如果提供了時間步長，使用它\r\n        if (timeStep !== null) {\r\n            this.timeStep = timeStep;\r\n        }\r\n        \r\n        // 分析電路拓撲\r\n        this.mnaBuilder.analyzeCircuit(this.components);\r\n        \r\n        // 初始化所有元件的暫態狀態\r\n        for (const component of this.components) {\r\n            component.initTransient(this.timeStep);\r\n        }\r\n        \r\n        // 設置初始條件 (DC工作點)\r\n        await this.setInitialConditions();\r\n        \r\n        // 儲存分析信息\r\n        this.result.analysisInfo = {\r\n            timeStep: this.timeStep,\r\n            startTime: this.startTime,\r\n            stopTime: this.stopTime,\r\n            method: 'Backward Euler',\r\n            matrixSize: this.mnaBuilder.matrixSize,\r\n            nodeCount: this.mnaBuilder.nodeCount,\r\n            voltageSourceCount: this.mnaBuilder.voltageSourceCount\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 設置初始條件 (執行DC分析)\r\n     */\r\n    async setInitialConditions() {\r\n        if (this.debug) {\r\n            console.log('Setting initial conditions...');\r\n        }\r\n        \r\n        // 建立t=0時的MNA矩陣\r\n        const { matrix, rhs } = this.mnaBuilder.buildMNAMatrix(this.components, 0);\r\n        \r\n        if (this.debug) {\r\n            this.mnaBuilder.printMNAMatrix();\r\n        }\r\n        \r\n        // 求解初始工作點\r\n        const solution = LUSolver.solve(matrix, rhs);\r\n        \r\n        // 提取初始狀態\r\n        const nodeVoltages = this.mnaBuilder.extractNodeVoltages(solution);\r\n        const branchCurrents = this.mnaBuilder.extractVoltageSourceCurrents(solution);\r\n        \r\n        // 更新元件歷史狀態\r\n        for (const component of this.components) {\r\n            component.updateHistory(nodeVoltages, branchCurrents);\r\n        }\r\n        \r\n        // 保存初始點\r\n        this.result.addTimePoint(this.startTime, nodeVoltages, branchCurrents);\r\n        \r\n        if (this.debug) {\r\n            console.log('Initial conditions set');\r\n            this.printSolutionSummary(nodeVoltages, branchCurrents);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 主時域迴圈\r\n     */\r\n    async timeLoop() {\r\n        let currentTime = this.startTime + this.timeStep;\r\n        let stepCount = 0;\r\n        const totalSteps = Math.ceil((this.stopTime - this.startTime) / this.timeStep);\r\n        \r\n        while (currentTime <= this.stopTime) {\r\n            stepCount++;\r\n            \r\n            try {\r\n                // 執行一個時間步\r\n                await this.singleTimeStep(currentTime);\r\n                \r\n                // 進度回調\r\n                if (this.progressCallback) {\r\n                    const progress = stepCount / totalSteps;\r\n                    this.progressCallback(progress, currentTime, stepCount);\r\n                }\r\n                \r\n                // 調試輸出\r\n                if (this.debug && stepCount % 100 === 0) {\r\n                    console.log(`Step ${stepCount}/${totalSteps}, time=${(currentTime * 1e6).toFixed(2)}µs`);\r\n                }\r\n                \r\n                currentTime += this.timeStep;\r\n                \r\n            } catch (error) {\r\n                console.error(`Time step failed at t=${currentTime}s:`, error);\r\n                throw error;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 執行單個時間步\r\n     * @param {number} time 當前時間\r\n     */\r\n    async singleTimeStep(time) {\r\n        // 更新所有元件的伴隨模型\r\n        for (const component of this.components) {\r\n            if (typeof component.updateCompanionModel === 'function') {\r\n                component.updateCompanionModel();\r\n            }\r\n        }\r\n        \r\n        // 建立當前時間點的MNA矩陣\r\n        const { matrix, rhs } = this.mnaBuilder.buildMNAMatrix(this.components, time);\r\n        \r\n        // 求解線性方程組\r\n        const solution = LUSolver.solve(matrix, rhs);\r\n        \r\n        // 提取節點電壓和支路電流\r\n        const nodeVoltages = this.mnaBuilder.extractNodeVoltages(solution);\r\n        const branchCurrents = this.mnaBuilder.extractVoltageSourceCurrents(solution);\r\n        \r\n        // 更新所有元件的歷史狀態\r\n        for (const component of this.components) {\r\n            component.updateHistory(nodeVoltages, branchCurrents);\r\n        }\r\n        \r\n        // 保存結果\r\n        this.result.addTimePoint(time, nodeVoltages, branchCurrents);\r\n    }\r\n\r\n    /**\r\n     * 完成分析\r\n     */\r\n    finalize() {\r\n        // 計算最終統計信息\r\n        const info = this.result.getAnalysisInfo();\r\n        console.log(`Analysis summary: ${info.totalTimePoints} points, avg step=${(info.averageTimeStep * 1e6).toFixed(2)}µs`);\r\n        \r\n        // 清理資源\r\n        this.mnaBuilder.reset();\r\n    }\r\n\r\n    /**\r\n     * 打印解的摘要 (調試用)\r\n     * @param {Map<string, number>} nodeVoltages 節點電壓\r\n     * @param {Map<string, number>} branchCurrents 支路電流\r\n     */\r\n    printSolutionSummary(nodeVoltages, branchCurrents) {\r\n        console.log('\\\\nSolution Summary:');\r\n        console.log('Node Voltages:');\r\n        for (const [node, voltage] of nodeVoltages) {\r\n            console.log(`  V(${node}) = ${voltage.toFixed(6)}V`);\r\n        }\r\n        \r\n        console.log('Branch Currents:');\r\n        for (const [branch, current] of branchCurrents) {\r\n            console.log(`  I(${branch}) = ${(current * 1000).toFixed(3)}mA`);\r\n        }\r\n        console.log('');\r\n    }\r\n\r\n    /**\r\n     * 設置調試模式\r\n     * @param {boolean} enabled 是否啟用調試\r\n     */\r\n    setDebug(enabled) {\r\n        this.debug = enabled;\r\n    }\r\n\r\n    /**\r\n     * 獲取當前分析狀態\r\n     * @returns {Object} 狀態信息\r\n     */\r\n    getStatus() {\r\n        return {\r\n            isRunning: this.result !== null,\r\n            currentTime: this.result ? this.result.timeVector[this.result.timeVector.length - 1] : 0,\r\n            progress: this.result ? this.result.timeVector.length / Math.ceil((this.stopTime - this.startTime) / this.timeStep) : 0,\r\n            timePoints: this.result ? this.result.timeVector.length : 0\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 執行單一時間步求解 (用於步進式控制)\r\n     * @param {number} currentTime 當前時間\r\n     * @param {number} maxIterations 最大迭代次數\r\n     * @returns {Object} 求解結果\r\n     */\r\n    solveTimeStep(currentTime, maxIterations = this.maxIterations) {\r\n        try {\r\n            // 建立當前時間步的 MNA 矩陣 (考慮歷史項)\r\n            const { matrix, rhs } = this.mnaBuilder.buildMNAMatrix(this.components, currentTime);\r\n            \r\n            // 求解線性系統\r\n            const solution = LUSolver.solve(matrix, rhs);\r\n            \r\n            // 提取結果\r\n            const nodeVoltages = this.mnaBuilder.extractNodeVoltages(solution);\r\n            const branchCurrents = this.mnaBuilder.extractVoltageSourceCurrents(solution);\r\n            \r\n            // 檢查收斂性 (簡化檢查)\r\n            const converged = true; // 在線性分析中總是收斂\r\n            \r\n            // 更新元件歷史狀態\r\n            for (const component of this.components) {\r\n                component.updateHistory(nodeVoltages, branchCurrents);\r\n            }\r\n            \r\n            return {\r\n                converged: converged,\r\n                nodeVoltages: nodeVoltages,\r\n                branchCurrents: branchCurrents,\r\n                time: currentTime\r\n            };\r\n            \r\n        } catch (error) {\r\n            throw new Error(`Time step solution failed at t=${currentTime}s: ${error.message}`);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * 暫態分析工具函數\r\n */\r\nexport class TransientUtils {\r\n    /**\r\n     * 解析SPICE風格的暫態分析指令\r\n     * @param {string} command 指令字符串 (如 '.tran 1us 1ms')\r\n     * @returns {Object} 解析後的參數\r\n     */\r\n    static parseTranCommand(command) {\r\n        const cmd = command.trim().toLowerCase();\r\n        \r\n        // 匹配 .tran [step] [stop] [start] [max_step]\r\n        // 使用正規表示式字面量，並用單反斜線進行轉義\r\n        const match = cmd.match(/^\\.tran\\s+([0-9.]+[a-z]*)\\s+([0-9.]+[a-z]*)(?:\\s+([0-9.]+[a-z]*))?(?:\\s+([0-9.]+[a-z]*))?/);\r\n        \r\n        if (!match) {\r\n            throw new Error(`Invalid .tran command: ${command}`);\r\n        }\r\n        \r\n        const params = {\r\n            timeStep: this.parseTimeValue(match[1]),\r\n            stopTime: this.parseTimeValue(match[2]),\r\n            startTime: match[3] ? this.parseTimeValue(match[3]) : 0,\r\n            maxTimeStep: match[4] ? this.parseTimeValue(match[4]) : undefined\r\n        };\r\n        \r\n        return params;\r\n    }\r\n\r\n    /**\r\n     * 解析時間值 (支援工程記號)\r\n     * @param {string} timeStr 時間字符串 (如 '1us', '2.5ms')\r\n     * @returns {number} 時間值 (秒)\r\n     */\r\n    static parseTimeValue(timeStr) {\r\n        const str = timeStr.trim().toLowerCase();\r\n        \r\n        // 按照長度降序排列，確保最長的後綴先被匹配，避免 's' 匹配 'us' 的問題\r\n        const suffixes = {\r\n            'fs': 1e-15,\r\n            'ps': 1e-12,\r\n            'ns': 1e-9,\r\n            'us': 1e-6,\r\n            'µs': 1e-6,\r\n            'ms': 1e-3,\r\n            's': 1\r\n        };\r\n        \r\n        for (const [suffix, multiplier] of Object.entries(suffixes)) {\r\n            if (str.endsWith(suffix)) {\r\n                const numPart = parseFloat(str.slice(0, -suffix.length));\r\n                if (!isNaN(numPart)) {\r\n                    return numPart * multiplier;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // 如果沒有後綴，假設是秒\r\n        const numValue = parseFloat(str);\r\n        if (!isNaN(numValue)) {\r\n            return numValue;\r\n        }\r\n        \r\n        throw new Error(`Cannot parse time value: ${timeStr}`);\r\n    }\r\n\r\n    /**\r\n     * 格式化時間值為可讀字符串\r\n     * @param {number} time 時間值 (秒)\r\n     * @returns {string} 格式化的字符串\r\n     */\r\n    static formatTime(time) {\r\n        const abs = Math.abs(time);\r\n        \r\n        if (abs >= 1) {\r\n            return `${time.toFixed(3)}s`;\r\n        } else if (abs >= 1e-3) {\r\n            return `${(time * 1e3).toFixed(3)}ms`;\r\n        } else if (abs >= 1e-6) {\r\n            return `${(time * 1e6).toFixed(3)}µs`;\r\n        } else if (abs >= 1e-9) {\r\n            return `${(time * 1e9).toFixed(3)}ns`;\r\n        } else {\r\n            return `${(time * 1e12).toFixed(3)}ps`;\r\n        }\r\n    }\r\n}","/**\r\n * 直流分析 (DC Analysis) 實現\r\n * \r\n * 用於求解電路的直流工作點，是暫態分析的初始條件\r\n */\r\n\r\nimport { Matrix, Vector, LUSolver } from '../core/linalg.js';\r\nimport { MNABuilder } from '../core/mna.js';\r\n\r\n/**\r\n * DC分析結果類\r\n */\r\nexport class DCResult {\r\n    constructor() {\r\n        this.nodeVoltages = new Map();\r\n        this.branchCurrents = new Map();\r\n        this.componentPower = new Map();\r\n        this.totalPower = 0;\r\n        this.analysisInfo = {};\r\n        this.converged = false;\r\n    }\r\n\r\n    /**\r\n     * 獲取節點電壓\r\n     * @param {string} nodeName 節點名稱\r\n     * @returns {number} 電壓值\r\n     */\r\n    getNodeVoltage(nodeName) {\r\n        return this.nodeVoltages.get(nodeName) || 0;\r\n    }\r\n\r\n    /**\r\n     * 獲取支路電流\r\n     * @param {string} branchName 支路名稱\r\n     * @returns {number} 電流值\r\n     */\r\n    getBranchCurrent(branchName) {\r\n        return this.branchCurrents.get(branchName) || 0;\r\n    }\r\n\r\n    /**\r\n     * 計算元件功耗\r\n     * @param {BaseComponent[]} components 元件列表\r\n     */\r\n    calculatePower(components) {\r\n        this.totalPower = 0;\r\n        \r\n        for (const component of components) {\r\n            let power = 0;\r\n            \r\n            if (component.type === 'R') {\r\n                // 電阻功耗: P = V² / R\r\n                const voltage = component.getVoltage(this.nodeVoltages);\r\n                power = voltage * voltage / component.getResistance();\r\n                \r\n            } else if (component.type === 'V') {\r\n                // 電壓源功耗: P = V * I\r\n                const voltage = component.getValue();\r\n                const current = this.getBranchCurrent(component.name);\r\n                power = -voltage * current; // 負號表示電壓源提供功率\r\n                \r\n            } else if (component.type === 'I') {\r\n                // 電流源功耗: P = V * I\r\n                const voltage = component.getVoltage(this.nodeVoltages);\r\n                const current = component.getValue();\r\n                power = -voltage * current; // 負號表示電流源提供功率\r\n            }\r\n            \r\n            this.componentPower.set(component.name, power);\r\n            this.totalPower += Math.abs(power);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 獲取分析摘要\r\n     * @returns {Object} 摘要信息\r\n     */\r\n    getSummary() {\r\n        const nodeCount = this.nodeVoltages.size;\r\n        const branchCount = this.branchCurrents.size;\r\n        \r\n        return {\r\n            ...this.analysisInfo,\r\n            converged: this.converged,\r\n            nodeCount,\r\n            branchCount,\r\n            totalPower: this.totalPower,\r\n            nodes: Array.from(this.nodeVoltages.keys()),\r\n            branches: Array.from(this.branchCurrents.keys())\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * DC分析引擎\r\n */\r\nexport class DCAnalysis {\r\n    constructor() {\r\n        this.mnaBuilder = new MNABuilder();\r\n        this.debug = false;\r\n    }\r\n\r\n    /**\r\n     * 執行DC分析\r\n     * @param {BaseComponent[]} components 電路元件列表\r\n     * @param {Object} options 分析選項\r\n     * @returns {DCResult} DC分析結果\r\n     */\r\n    async run(components, options = {}) {\r\n        this.debug = options.debug || false;\r\n        const result = new DCResult();\r\n        \r\n        try {\r\n            if (this.debug) {\r\n                console.log('Starting DC analysis...');\r\n            }\r\n            \r\n            // 分析電路拓撲\r\n            this.mnaBuilder.analyzeCircuit(components);\r\n            \r\n            // 非線性求解迭代\r\n            const maxIterations = 20;\r\n            const tolerance = 1e-9;\r\n            let iteration = 0;\r\n            let converged = false;\r\n            let solution;\r\n            \r\n            while (iteration < maxIterations && !converged) {\r\n                iteration++;\r\n                \r\n                // 建立MNA矩陣 (t=0，所有動態元件使用DC行為)\r\n                const { matrix, rhs } = this.mnaBuilder.buildMNAMatrix(components, 0);\r\n                \r\n                if (this.debug && iteration === 1) {\r\n                    console.log('MNA Matrix built');\r\n                    this.mnaBuilder.printMNAMatrix();\r\n                }\r\n                \r\n                // 求解線性方程組\r\n                const newSolution = LUSolver.solve(matrix, rhs);\r\n                \r\n                // 檢查收斂性\r\n                if (iteration > 1) {\r\n                    let maxChange = 0;\r\n                    for (let i = 0; i < newSolution.size; i++) {\r\n                        const change = Math.abs(newSolution.get(i) - solution.get(i));\r\n                        maxChange = Math.max(maxChange, change);\r\n                    }\r\n                    \r\n                    if (maxChange < tolerance) {\r\n                        converged = true;\r\n                        if (this.debug) {\r\n                            console.log(`DC analysis converged after ${iteration} iterations (max change: ${maxChange.toExponential(2)})`);\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                solution = newSolution;\r\n                \r\n                // 提取結果並更新組件狀態\r\n                const tempNodeVoltages = this.mnaBuilder.extractNodeVoltages(solution);\r\n                const tempBranchCurrents = this.mnaBuilder.extractVoltageSourceCurrents(solution);\r\n                \r\n                // 更新所有組件的電壓狀態\r\n                for (const component of components) {\r\n                    if (typeof component.updateHistory === 'function') {\r\n                        component.updateHistory(tempNodeVoltages, tempBranchCurrents);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            if (!converged) {\r\n                console.warn(`DC analysis did not converge after ${maxIterations} iterations`);\r\n            }\r\n            \r\n            // 設置最終結果\r\n            result.nodeVoltages = this.mnaBuilder.extractNodeVoltages(solution);\r\n            result.branchCurrents = this.mnaBuilder.extractVoltageSourceCurrents(solution);\r\n            result.converged = converged;\r\n            \r\n            // 計算功耗\r\n            result.calculatePower(components);\r\n            \r\n            // 設置分析信息\r\n            result.analysisInfo = {\r\n                method: 'Modified Nodal Analysis',\r\n                matrixSize: this.mnaBuilder.matrixSize,\r\n                nodeCount: this.mnaBuilder.nodeCount,\r\n                voltageSourceCount: this.mnaBuilder.voltageSourceCount,\r\n                iterations: iteration,\r\n                convergence: converged ? 'converged' : 'max iterations reached'\r\n            };\r\n            \r\n            if (this.debug) {\r\n                this.printResults(result);\r\n            }\r\n            \r\n            return result;\r\n            \r\n        } catch (error) {\r\n            console.error('DC analysis failed:', error);\r\n            result.converged = false;\r\n            result.analysisInfo.error = error.message;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 估算矩陣條件數\r\n     * @param {Matrix} matrix MNA矩陣\r\n     * @returns {number} 條件數估計值\r\n     */\r\n    estimateCondition(matrix) {\r\n        try {\r\n            return LUSolver.estimateConditionNumber(matrix);\r\n        } catch (error) {\r\n            return Infinity;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 打印DC分析結果\r\n     * @param {DCResult} result DC分析結果\r\n     */\r\n    printResults(result) {\r\n        console.log('\\\\n=== DC Analysis Results ===');\r\n        \r\n        console.log('\\\\nNode Voltages:');\r\n        for (const [node, voltage] of result.nodeVoltages) {\r\n            if (Math.abs(voltage) < 1e-12) {\r\n                console.log(`  V(${node}) = 0V`);\r\n            } else if (Math.abs(voltage) >= 1000) {\r\n                console.log(`  V(${node}) = ${(voltage / 1000).toFixed(3)}kV`);\r\n            } else if (Math.abs(voltage) >= 1) {\r\n                console.log(`  V(${node}) = ${voltage.toFixed(6)}V`);\r\n            } else if (Math.abs(voltage) >= 1e-3) {\r\n                console.log(`  V(${node}) = ${(voltage * 1000).toFixed(3)}mV`);\r\n            } else if (Math.abs(voltage) >= 1e-6) {\r\n                console.log(`  V(${node}) = ${(voltage * 1e6).toFixed(3)}µV`);\r\n            } else {\r\n                console.log(`  V(${node}) = ${voltage.toExponential(3)}V`);\r\n            }\r\n        }\r\n        \r\n        console.log('\\\\nBranch Currents:');\r\n        for (const [branch, current] of result.branchCurrents) {\r\n            if (Math.abs(current) < 1e-12) {\r\n                console.log(`  I(${branch}) = 0A`);\r\n            } else if (Math.abs(current) >= 1) {\r\n                console.log(`  I(${branch}) = ${current.toFixed(6)}A`);\r\n            } else if (Math.abs(current) >= 1e-3) {\r\n                console.log(`  I(${branch}) = ${(current * 1000).toFixed(3)}mA`);\r\n            } else if (Math.abs(current) >= 1e-6) {\r\n                console.log(`  I(${branch}) = ${(current * 1e6).toFixed(3)}µA`);\r\n            } else if (Math.abs(current) >= 1e-9) {\r\n                console.log(`  I(${branch}) = ${(current * 1e9).toFixed(3)}nA`);\r\n            } else {\r\n                console.log(`  I(${branch}) = ${current.toExponential(3)}A`);\r\n            }\r\n        }\r\n        \r\n        console.log('\\\\nComponent Power:');\r\n        let totalSupplied = 0;\r\n        let totalDissipated = 0;\r\n        \r\n        for (const [component, power] of result.componentPower) {\r\n            if (power < 0) {\r\n                totalSupplied += Math.abs(power);\r\n                console.log(`  P(${component}) = ${Math.abs(power).toFixed(6)}W (supplied)`);\r\n            } else if (power > 1e-12) {\r\n                totalDissipated += power;\r\n                console.log(`  P(${component}) = ${power.toFixed(6)}W (dissipated)`);\r\n            }\r\n        }\r\n        \r\n        console.log(`\\\\nPower Balance:`);\r\n        console.log(`  Total Supplied: ${totalSupplied.toFixed(6)}W`);\r\n        console.log(`  Total Dissipated: ${totalDissipated.toFixed(6)}W`);\r\n        console.log(`  Balance Error: ${Math.abs(totalSupplied - totalDissipated).toFixed(9)}W`);\r\n        \r\n        const info = result.getSummary();\r\n        console.log(`\\\\nMatrix Info: ${info.matrixSize}×${info.matrixSize}, iterations: ${info.iterations}`);\r\n        console.log('===========================\\\\n');\r\n    }\r\n\r\n    /**\r\n     * 設置調試模式\r\n     * @param {boolean} enabled 是否啟用調試\r\n     */\r\n    setDebug(enabled) {\r\n        this.debug = enabled;\r\n    }\r\n}","/**\r\n * AkingSPICE 主求解器類別\r\n * \r\n * 這是使用者的主要介面，整合了網表解析、電路分析和結果管理\r\n */\r\n\r\nimport { NetlistParser } from '../parser/netlist.js';\r\nimport { TransientAnalysis, TransientUtils, TransientResult } from '../analysis/transient.js';\r\nimport { DCAnalysis } from '../analysis/dc.js';\r\n\r\n/**\r\n * AkingSPICE 主求解器\r\n */\r\nexport class AkingSPICE {\r\n    constructor(netlist = null) {\r\n        this.parser = new NetlistParser();\r\n        this.transientAnalysis = new TransientAnalysis();\r\n        this.dcAnalysis = new DCAnalysis();\r\n        \r\n        // 電路數據\r\n        this._components = []; // 使用內部變數儲存\r\n        this.models = new Map();\r\n        this.parameters = new Map();\r\n        this.analyses = [];\r\n        this.options = new Map();\r\n        \r\n        // 分析結果\r\n        this.results = new Map();\r\n        this.lastResult = null;\r\n        \r\n        // 狀態信息\r\n        this.isInitialized = false;\r\n        this.debug = false;\r\n        \r\n        // 如果提供了網表，立即解析\r\n        if (netlist) {\r\n            this.loadNetlist(netlist);\r\n        }\r\n    }\r\n\r\n    // 🔥 新增：Component Setter，自動處理元元件\r\n    set components(componentArray) {\r\n        this._components = []; // 清空現有組件\r\n        this.addComponents(componentArray);\r\n    }\r\n\r\n    // 🔥 新增：Component Getter\r\n    get components() {\r\n        return this._components || [];\r\n    }\r\n    \r\n    // 🔥 新增：addComponent 方法，用於單個元件\r\n    addComponent(component) {\r\n        if (!this._components) {\r\n            this._components = [];\r\n        }\r\n        if (component.type === 'T_META' && typeof component.getComponents === 'function') {\r\n            // 如果是元元件，添加其子元件\r\n            this._components.push(...component.getComponents());\r\n        } else {\r\n            this._components.push(component);\r\n        }\r\n    }\r\n\r\n    // 🔥 新增：addComponents 方法，用於陣列\r\n    addComponents(componentArray) {\r\n        for (const comp of componentArray) {\r\n            this.addComponent(comp);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 載入並解析網表\r\n     * @param {string} netlistText 網表文本\r\n     * @returns {Object} 解析結果統計\r\n     */\r\n    loadNetlist(netlistText) {\r\n        console.log('Loading netlist...');\r\n        \r\n        try {\r\n            const parseResult = this.parser.parse(netlistText);\r\n            \r\n            this.components = parseResult.components;\r\n            this.models = parseResult.models;\r\n            this.parameters = parseResult.parameters;\r\n            this.analyses = parseResult.analyses;\r\n            this.options = parseResult.options;\r\n            \r\n            this.isInitialized = true;\r\n            \r\n            if (this.debug) {\r\n                this.parser.printReport();\r\n            }\r\n            \r\n            console.log(`Netlist loaded: ${this.components.length} components`);\r\n            return parseResult.stats;\r\n            \r\n        } catch (error) {\r\n            console.error('Failed to load netlist:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 執行分析 (批次模式 API)\r\n     * @param {string} analysisCommand 分析指令 (如 '.tran 1us 1ms')\r\n     * @returns {Object} 分析結果\r\n     */\r\n    async runAnalysis(analysisCommand = null) {\r\n        if (!this.isInitialized) {\r\n            throw new Error('No netlist loaded. Call loadNetlist() first.');\r\n        }\r\n\r\n        // 如果提供了分析指令，解析它\r\n        if (analysisCommand) {\r\n            const cmd = analysisCommand.trim().toLowerCase();\r\n            \r\n            if (cmd.startsWith('.tran')) {\r\n                return await this.runTransientAnalysis(analysisCommand);\r\n            } else if (cmd.startsWith('.dc') || cmd.startsWith('.op')) {\r\n                return await this.runDCAnalysis();\r\n            } else {\r\n                throw new Error(`Unsupported analysis command: ${analysisCommand}`);\r\n            }\r\n        }\r\n\r\n        // 如果沒有提供指令，查看網表中是否有分析指令\r\n        if (this.analyses.length > 0) {\r\n            const analysis = this.analyses[0]; // 使用第一個分析指令\r\n            \r\n            if (analysis.type === 'TRAN') {\r\n                const tranCommand = `.tran ${analysis.tstep} ${analysis.tstop} ${analysis.tstart || '0'} ${analysis.tmax || analysis.tstep}`;\r\n                return await this.runTransientAnalysis(tranCommand);\r\n            } else if (analysis.type === 'DC') {\r\n                return await this.runDCAnalysis();\r\n            }\r\n        }\r\n\r\n        // 預設執行DC分析\r\n        console.log('No analysis specified, running DC analysis');\r\n        return await this.runDCAnalysis();\r\n    }\r\n\r\n    /**\r\n     * 執行暫態分析\r\n     * @param {string} tranCommand 暫態分析指令\r\n     * @returns {Object} 暫態分析結果\r\n     */\r\n    async runTransientAnalysis(tranCommand) {\r\n        console.log(`Running transient analysis: ${tranCommand}`);\r\n        \r\n        try {\r\n            // 解析暫態分析參數\r\n            const params = TransientUtils.parseTranCommand(tranCommand);\r\n            params.debug = this.debug;\r\n            \r\n            // 執行分析\r\n            const result = await this.transientAnalysis.run(this.components, params);\r\n            \r\n            // 保存結果\r\n            this.results.set('tran', result);\r\n            this.lastResult = result;\r\n            \r\n            console.log(`Transient analysis completed: ${result.timeVector.length} time points`);\r\n            return result;\r\n            \r\n        } catch (error) {\r\n            console.error('Transient analysis failed:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 執行DC分析\r\n     * @returns {Object} DC分析結果\r\n     */\r\n    async runDCAnalysis() {\r\n        console.log('Running DC analysis...');\r\n        \r\n        try {\r\n            const options = { debug: this.debug };\r\n            const result = await this.dcAnalysis.run(this.components, options);\r\n            \r\n            // 保存結果\r\n            this.results.set('dc', result);\r\n            this.lastResult = result;\r\n            \r\n            console.log('DC analysis completed');\r\n            return result;\r\n            \r\n        } catch (error) {\r\n            console.error('DC analysis failed:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 獲取分析結果\r\n     * @param {string} analysisType 分析類型 ('tran', 'dc')\r\n     * @returns {Object} 分析結果\r\n     */\r\n    getResult(analysisType = null) {\r\n        if (analysisType) {\r\n            return this.results.get(analysisType);\r\n        }\r\n        return this.lastResult;\r\n    }\r\n\r\n    /**\r\n     * 獲取電路信息\r\n     * @returns {Object} 電路信息\r\n     */\r\n    getCircuitInfo() {\r\n        return {\r\n            componentCount: this.components.length,\r\n            components: this.components.map(comp => ({\r\n                name: comp.name,\r\n                type: comp.type,\r\n                nodes: comp.nodes,\r\n                value: comp.value\r\n            })),\r\n            nodeList: this.getNodeList(),\r\n            modelCount: this.models.size,\r\n            parameterCount: this.parameters.size,\r\n            analysisCount: this.analyses.length,\r\n            isInitialized: this.isInitialized\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 獲取所有節點列表\r\n     * @returns {string[]} 節點名稱列表\r\n     */\r\n    getNodeList() {\r\n        const nodeSet = new Set();\r\n        \r\n        for (const component of this.components) {\r\n            if (component.nodes) {\r\n                for (const node of component.nodes) {\r\n                    nodeSet.add(node);\r\n                }\r\n            }\r\n        }\r\n        \r\n        return Array.from(nodeSet).sort();\r\n    }\r\n\r\n    /**\r\n     * 設置調試模式\r\n     * @param {boolean} enabled 是否啟用調試\r\n     */\r\n    setDebug(enabled) {\r\n        this.debug = enabled;\r\n        this.transientAnalysis.setDebug(enabled);\r\n        this.dcAnalysis.setDebug(enabled);\r\n    }\r\n\r\n    /**\r\n     * 驗證電路\r\n     * @returns {Object} 驗證結果\r\n     */\r\n    validateCircuit() {\r\n        const issues = [];\r\n        const warnings = [];\r\n        \r\n        // 檢查基本問題\r\n        if (this.components.length === 0) {\r\n            issues.push('No components found in circuit');\r\n            return { valid: false, issues, warnings };\r\n        }\r\n        \r\n        // 檢查每個元件\r\n        for (const component of this.components) {\r\n            if (!component.isValid()) {\r\n                issues.push(`Invalid component: ${component.name}`);\r\n            }\r\n            \r\n            // 檢查節點連接\r\n            for (const node of component.nodes) {\r\n                if (!node || typeof node !== 'string') {\r\n                    issues.push(`Invalid node in component ${component.name}: ${node}`);\r\n                }\r\n            }\r\n            \r\n            // 檢查元件值\r\n            if (component.value === 0 && (component.type === 'R' || component.type === 'L' || component.type === 'C')) {\r\n                warnings.push(`Zero value in ${component.name} may cause numerical issues`);\r\n            }\r\n        }\r\n        \r\n        // 檢查接地節點\r\n        const nodes = this.getNodeList();\r\n        const hasGround = nodes.includes('0') || nodes.includes('gnd') || nodes.includes('GND');\r\n        if (!hasGround) {\r\n            warnings.push('No ground node (0 or gnd) found - circuit may be floating');\r\n        }\r\n        \r\n        // 檢查獨立節點\r\n        const nodeConnections = new Map();\r\n        for (const component of this.components) {\r\n            for (const node of component.nodes) {\r\n                nodeConnections.set(node, (nodeConnections.get(node) || 0) + 1);\r\n            }\r\n        }\r\n        \r\n        for (const [node, connectionCount] of nodeConnections) {\r\n            if (connectionCount === 1 && node !== '0' && node !== 'gnd') {\r\n                warnings.push(`Node ${node} has only one connection`);\r\n            }\r\n        }\r\n        \r\n        return {\r\n            valid: issues.length === 0,\r\n            issues,\r\n            warnings,\r\n            componentCount: this.components.length,\r\n            nodeCount: nodes.length\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 打印電路摘要\r\n     */\r\n    printCircuitSummary() {\r\n        console.log('\\\\n=== Circuit Summary ===');\r\n        \r\n        const info = this.getCircuitInfo();\r\n        console.log(`Components: ${info.componentCount}`);\r\n        console.log(`Nodes: ${info.nodeList.length}`);\r\n        console.log(`Models: ${info.modelCount}`);\r\n        console.log(`Parameters: ${info.parameterCount}`);\r\n        \r\n        // 按類型統計元件\r\n        const componentTypes = {};\r\n        for (const comp of this.components) {\r\n            componentTypes[comp.type] = (componentTypes[comp.type] || 0) + 1;\r\n        }\r\n        \r\n        console.log('\\\\nComponent breakdown:');\r\n        for (const [type, count] of Object.entries(componentTypes)) {\r\n            console.log(`  ${type}: ${count}`);\r\n        }\r\n        \r\n        console.log('\\\\nNodes:', info.nodeList.join(', '));\r\n        \r\n        // 驗證電路\r\n        const validation = this.validateCircuit();\r\n        console.log(`\\\\nValidation: ${validation.valid ? 'PASSED' : 'FAILED'}`);\r\n        \r\n        if (validation.issues.length > 0) {\r\n            console.log('Issues:');\r\n            validation.issues.forEach(issue => console.log(`  - ${issue}`));\r\n        }\r\n        \r\n        if (validation.warnings.length > 0) {\r\n            console.log('Warnings:');\r\n            validation.warnings.forEach(warning => console.log(`  - ${warning}`));\r\n        }\r\n        \r\n        console.log('=======================\\\\n');\r\n    }\r\n\r\n    /**\r\n     * 重置求解器\r\n     */\r\n    reset() {\r\n        this.components = [];\r\n        this.models.clear();\r\n        this.parameters.clear();\r\n        this.analyses = [];\r\n        this.options.clear();\r\n        this.results.clear();\r\n        this.lastResult = null;\r\n        this.isInitialized = false;\r\n        this.parser.reset();\r\n    }\r\n\r\n    // ==================== 步進式模擬控制 API ====================\r\n    \r\n    /**\r\n     * 初始化步進式暫態分析\r\n     * @param {Object} params 參數 {startTime, stopTime, timeStep, maxIterations}\r\n     * @returns {boolean} 初始化是否成功\r\n     */\r\n    async initSteppedTransient(params = {}) {\r\n        try {\r\n            if (!this.isInitialized) {\r\n                throw new Error('Circuit not initialized. Load a netlist first.');\r\n            }\r\n\r\n            // 設置默認參數\r\n            this.steppedParams = {\r\n                startTime: params.startTime || 0,\r\n                stopTime: params.stopTime || 1e-3,  // 1ms\r\n                timeStep: params.timeStep || 1e-6,   // 1μs\r\n                maxIterations: params.maxIterations || 10\r\n            };\r\n\r\n            // 先設置參數再初始化\r\n            this.transientAnalysis.setParameters({\r\n                timeStep: this.steppedParams.timeStep,\r\n                startTime: this.steppedParams.startTime,\r\n                stopTime: this.steppedParams.stopTime,\r\n                maxIterations: this.steppedParams.maxIterations\r\n            });\r\n            \r\n            // 創建 result 對象\r\n            this.transientAnalysis.result = new TransientResult();\r\n            \r\n            // 初始化暫態分析\r\n            await this.transientAnalysis.initialize(this.components, this.steppedParams.timeStep);\r\n            \r\n            // 重置狀態\r\n            this.currentTime = this.steppedParams.startTime;\r\n            this.currentIteration = 0;\r\n            this.isSteppedMode = true;\r\n            this.steppedResults = {\r\n                time: [],\r\n                voltages: [],\r\n                currents: [],\r\n                componentStates: []\r\n            };\r\n\r\n            console.log(`步進式暫態分析初始化完成:`);\r\n            console.log(`  時間範圍: ${this.steppedParams.startTime}s 到 ${this.steppedParams.stopTime}s`);\r\n            console.log(`  時間步長: ${this.steppedParams.timeStep}s`);\r\n            console.log(`  最大迭代數: ${this.steppedParams.maxIterations}`);\r\n\r\n            return true;\r\n\r\n        } catch (error) {\r\n            console.error(`步進式暫態分析初始化失敗: ${error.message}`);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 執行一個時間步\r\n     * @param {Object} controlInputs 控制輸入 {gateName: state, ...}\r\n     * @returns {Object} 當前時間步的結果\r\n     */\r\n    step(controlInputs = {}) {\r\n        if (!this.isSteppedMode) {\r\n            throw new Error('Step mode not initialized. Call initSteppedTransient() first.');\r\n        }\r\n\r\n        if (this.isFinished()) {\r\n            console.warn('Simulation already finished');\r\n            return null;\r\n        }\r\n\r\n        try {\r\n            // 更新控制輸入 (如 MOSFET 開關狀態)\r\n            this.updateControlInputs(controlInputs);\r\n            \r\n            // 執行一個時間步\r\n            const stepResult = this.transientAnalysis.solveTimeStep(\r\n                this.currentTime, \r\n                this.steppedParams.maxIterations\r\n            );\r\n\r\n            // 記錄結果 - 將 Map 轉換為普通物件\r\n            const nodeVoltagesObj = Object.fromEntries(stepResult.nodeVoltages);\r\n            const branchCurrentsObj = Object.fromEntries(stepResult.branchCurrents);\r\n            \r\n            this.steppedResults.time.push(this.currentTime);\r\n            this.steppedResults.voltages.push({...nodeVoltagesObj});\r\n            this.steppedResults.currents.push({...branchCurrentsObj});\r\n            \r\n            // 記錄元件狀態 (特別是 MOSFET 等可控元件)\r\n            const componentStates = {};\r\n            for (const component of this.components) {\r\n                if (component.getOperatingStatus) {\r\n                    componentStates[component.name] = component.getOperatingStatus();\r\n                }\r\n            }\r\n            this.steppedResults.componentStates.push(componentStates);\r\n\r\n            // 準備下一步\r\n            this.currentTime += this.steppedParams.timeStep;\r\n            this.currentIteration++;\r\n\r\n            // 返回當前步驟的結果 - 將 Map 轉換為普通物件\r\n            return {\r\n                time: this.currentTime - this.steppedParams.timeStep,\r\n                iteration: this.currentIteration - 1,\r\n                nodeVoltages: Object.fromEntries(stepResult.nodeVoltages),\r\n                branchCurrents: Object.fromEntries(stepResult.branchCurrents),\r\n                componentStates: componentStates,\r\n                converged: stepResult.converged\r\n            };\r\n\r\n        } catch (error) {\r\n            console.error(`Time step ${this.currentIteration} failed: ${error.message}`);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 檢查模擬是否完成\r\n     * @returns {boolean} 是否完成\r\n     */\r\n    isFinished() {\r\n        return this.isSteppedMode && (this.currentTime >= this.steppedParams.stopTime);\r\n    }\r\n\r\n    /**\r\n     * 獲取當前模擬時間\r\n     * @returns {number} 當前時間 (秒)\r\n     */\r\n    getCurrentTime() {\r\n        return this.currentTime || 0;\r\n    }\r\n\r\n    /**\r\n     * 更新控制輸入 (如 MOSFET 閘極狀態)\r\n     * @param {Object} controlInputs 控制輸入映射 {componentName: state, ...}\r\n     */\r\n    updateControlInputs(controlInputs) {\r\n        for (const [componentName, state] of Object.entries(controlInputs)) {\r\n            const component = this.components.find(c => c.name === componentName);\r\n            if (component && component.setGateState) {\r\n                component.setGateState(state);\r\n                if (this.debug) {\r\n                    console.log(`Updated ${componentName} gate state: ${state ? 'ON' : 'OFF'}`);\r\n                }\r\n            } else if (component && component.setValue) {\r\n                // 支援其他類型的控制輸入\r\n                component.setValue(state);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 設置特定元件的閘極狀態 (便捷方法)\r\n     * @param {string} componentName 元件名稱\r\n     * @param {boolean} state 閘極狀態\r\n     */\r\n    setGateState(componentName, state) {\r\n        this.updateControlInputs({[componentName]: state});\r\n    }\r\n\r\n    /**\r\n     * 獲取節點電壓\r\n     * @param {string} nodeName 節點名稱\r\n     * @returns {number} 電壓值 (V)\r\n     */\r\n    getVoltage(nodeName) {\r\n        if (!this.isSteppedMode || this.steppedResults.voltages.length === 0) {\r\n            return 0;\r\n        }\r\n        \r\n        const lastVoltages = this.steppedResults.voltages[this.steppedResults.voltages.length - 1];\r\n        return lastVoltages[nodeName] || 0;\r\n    }\r\n\r\n    /**\r\n     * 獲取支路電流 (通過元件)\r\n     * @param {string} componentName 元件名稱  \r\n     * @returns {number} 電流值 (A)\r\n     */\r\n    getCurrent(componentName) {\r\n        if (!this.isSteppedMode || this.steppedResults.currents.length === 0) {\r\n            return 0;\r\n        }\r\n        \r\n        const lastCurrents = this.steppedResults.currents[this.steppedResults.currents.length - 1];\r\n        return lastCurrents[componentName] || 0;\r\n    }\r\n\r\n    /**\r\n     * 獲取元件工作狀態\r\n     * @param {string} componentName 元件名稱\r\n     * @returns {Object} 元件狀態\r\n     */\r\n    getComponentState(componentName) {\r\n        if (!this.isSteppedMode || this.steppedResults.componentStates.length === 0) {\r\n            return null;\r\n        }\r\n        \r\n        const lastStates = this.steppedResults.componentStates[this.steppedResults.componentStates.length - 1];\r\n        return lastStates[componentName] || null;\r\n    }\r\n\r\n    /**\r\n     * 獲取完整的步進式模擬結果\r\n     * @returns {Object} 完整結果\r\n     */\r\n    getSteppedResults() {\r\n        return this.isSteppedMode ? this.steppedResults : null;\r\n    }\r\n\r\n    /**\r\n     * 運行完整的步進式模擬 (帶控制函數)\r\n     * @param {Function} controlFunction 控制函數 (time) => {componentName: state, ...}\r\n     * @param {Object} params 模擬參數\r\n     * @returns {Object} 完整模擬結果\r\n     */\r\n    async runSteppedSimulation(controlFunction, params = {}) {\r\n        console.log('開始步進式模擬...');\r\n        \r\n        if (!(await this.initSteppedTransient(params))) {\r\n            throw new Error('Failed to initialize stepped simulation');\r\n        }\r\n\r\n        const results = [];\r\n        let stepCount = 0;\r\n\r\n        while (!this.isFinished()) {\r\n            // 獲取當前時間的控制輸入\r\n            const controlInputs = controlFunction ? controlFunction(this.currentTime) : {};\r\n            \r\n            // 執行一步\r\n            const stepResult = this.step(controlInputs);\r\n            if (stepResult) {\r\n                results.push(stepResult);\r\n                stepCount++;\r\n\r\n                // 進度報告\r\n                if (stepCount % 1000 === 0) {\r\n                    const progress = ((this.currentTime - this.steppedParams.startTime) / \r\n                                    (this.steppedParams.stopTime - this.steppedParams.startTime)) * 100;\r\n                    console.log(`模擬進度: ${progress.toFixed(1)}% (${stepCount} steps)`);\r\n                }\r\n            }\r\n        }\r\n\r\n        console.log(`步進式模擬完成: ${stepCount} 個時間步`);\r\n        return {\r\n            steps: results,\r\n            summary: {\r\n                totalSteps: stepCount,\r\n                simulationTime: this.steppedParams.stopTime - this.steppedParams.startTime,\r\n                timeStep: this.steppedParams.timeStep\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 重置步進式模擬狀態\r\n     */\r\n    resetSteppedMode() {\r\n        this.isSteppedMode = false;\r\n        this.currentTime = 0;\r\n        this.currentIteration = 0;\r\n        this.steppedParams = null;\r\n        this.steppedResults = null;\r\n    }\r\n\r\n    /**\r\n     * 獲取求解器版本信息\r\n     * @returns {Object} 版本信息\r\n     */\r\n    static getVersionInfo() {\r\n        return {\r\n            name: 'AkingSPICE',\r\n            version: '0.1.0',\r\n            description: 'JavaScript Solver for Power Electronics',\r\n            features: [\r\n                'Modified Nodal Analysis (MNA)',\r\n                'LU decomposition solver',\r\n                'Backward Euler transient analysis',\r\n                'DC operating point analysis',\r\n                'SPICE-compatible netlist format',\r\n                'Basic passive components (R, L, C)',\r\n                'Independent sources (V, I)',\r\n                'Controlled sources (VCVS, VCCS)',\r\n                'MOSFET with body diode model',\r\n                'Stepped simulation control API'\r\n            ],\r\n            author: 'AkingSPICE Development Team',\r\n            license: 'MIT'\r\n        };\r\n    }\r\n}","/**\r\n * 三相電壓源模型 - 專為 VIENNA PFC、T-type PFC 等三相拓撲設計\r\n * \r\n * 特點：\r\n * - 自動生成 120° 相位差的三相電壓\r\n * - 支援星形 (Wye) 和三角形 (Delta) 連接\r\n * - 可配置相序（ABC 或 ACB）\r\n * - 支援不平衡和諧波分析\r\n */\r\n\r\nimport { VoltageSource } from './sources.js';\r\nimport { BaseComponent } from './base.js';\r\n\r\n/**\r\n * 三相電壓源\r\n * \r\n * 這個模型實現了：\r\n * 1. 三個相位差 120° 的正弦電壓源\r\n * 2. 星形連接（含中性點）或三角形連接\r\n * 3. 相序控制（正序 ABC 或反序 ACB）\r\n * 4. 頻率、幅值、相位偏移控制\r\n */\r\nexport class ThreePhaseSource extends BaseComponent {\r\n    /**\r\n     * @param {string} name 三相源名稱 (如 'V3PH1', 'GRID1')\r\n     * @param {Object} config 三相源配置\r\n     * @param {string[]} config.nodes 節點連接\r\n     * @param {number} config.voltage 線電壓RMS值 (V)\r\n     * @param {number} config.frequency 頻率 (Hz)\r\n     * @param {Object} params 額外參數\r\n     * \r\n     * 節點配置：\r\n     * - 星形連接：['A', 'B', 'C', 'N'] (A相, B相, C相, 中性點)\r\n     * - 三角形連接：['AB', 'BC', 'CA'] (線電壓節點)\r\n     */\r\n    constructor(name, config, params = {}) {\r\n        super(name, 'V3PH', config.nodes, config.voltage, params);\r\n        \r\n        if (!config || !config.nodes) {\r\n            throw new Error(`ThreePhaseSource ${name}: nodes configuration required`);\r\n        }\r\n        \r\n        // 基本參數\r\n        this.voltage = config.voltage || 220;        // 線電壓 RMS (V)\r\n        this.frequency = config.frequency || 50;     // 頻率 (Hz)\r\n        this.phaseOffset = config.phaseOffset || 0;  // 相位偏移 (度)\r\n        this.phaseSequence = config.phaseSequence || 'ABC'; // 相序\r\n        \r\n        // 連接方式\r\n        this.connection = config.connection || 'wye'; // 'wye' 或 'delta'\r\n        this.nodes = config.nodes;\r\n        \r\n        // 驗證節點配置\r\n        this.validateNodeConfiguration();\r\n        \r\n        // 計算相電壓（星形連接時）\r\n        this.phaseVoltage = this.connection === 'wye' ? \r\n            this.voltage / Math.sqrt(3) : this.voltage;\r\n        \r\n        // 創建內部電壓源\r\n        this.createInternalSources();\r\n        \r\n        // 計算相位角\r\n        this.calculatePhaseAngles();\r\n    }\r\n\r\n    /**\r\n     * 驗證節點配置\r\n     */\r\n    validateNodeConfiguration() {\r\n        if (this.connection === 'wye') {\r\n            if (this.nodes.length !== 4) {\r\n                throw new Error(`ThreePhaseSource ${this.name}: Wye connection requires 4 nodes [A, B, C, N]`);\r\n            }\r\n        } else if (this.connection === 'delta') {\r\n            if (this.nodes.length !== 3) {\r\n                throw new Error(`ThreePhaseSource ${this.name}: Delta connection requires 3 nodes [AB, BC, CA]`);\r\n            }\r\n        } else {\r\n            throw new Error(`ThreePhaseSource ${this.name}: Invalid connection type '${this.connection}'. Use 'wye' or 'delta'`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 計算相位角\r\n     */\r\n    calculatePhaseAngles() {\r\n        const basePhase = this.phaseOffset * Math.PI / 180; // 轉換為弧度\r\n        \r\n        if (this.phaseSequence === 'ABC') {\r\n            // 正序\r\n            this.phaseAngles = {\r\n                A: basePhase,\r\n                B: basePhase - 2 * Math.PI / 3,     // -120°\r\n                C: basePhase - 4 * Math.PI / 3      // -240° = +120°\r\n            };\r\n        } else if (this.phaseSequence === 'ACB') {\r\n            // 反序\r\n            this.phaseAngles = {\r\n                A: basePhase,\r\n                B: basePhase + 2 * Math.PI / 3,     // +120°\r\n                C: basePhase + 4 * Math.PI / 3      // +240° = -120°\r\n            };\r\n        } else {\r\n            throw new Error(`ThreePhaseSource ${this.name}: Invalid phase sequence '${this.phaseSequence}'. Use 'ABC' or 'ACB'`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 創建內部電壓源\r\n     */\r\n    createInternalSources() {\r\n        this.internalSources = [];\r\n        \r\n        if (this.connection === 'wye') {\r\n            // 星形連接：創建三個相電壓源\r\n            const neutralNode = this.nodes[3]; // 中性點\r\n            \r\n            const phases = ['A', 'B', 'C'];\r\n            phases.forEach((phase, index) => {\r\n                const phaseNode = this.nodes[index];\r\n                const sourceName = `${this.name}_${phase}`;\r\n                \r\n                // 創建正弦電壓源\r\n                const source = new VoltageSource(sourceName, [phaseNode, neutralNode], {\r\n                    type: 'SINE',\r\n                    amplitude: this.phaseVoltage * Math.sqrt(2), // 峰值\r\n                    frequency: this.frequency,\r\n                    phase: this.phaseAngles[phase] * 180 / Math.PI, // 轉回度數\r\n                    offset: 0\r\n                });\r\n                \r\n                this.internalSources.push(source);\r\n            });\r\n            \r\n        } else if (this.connection === 'delta') {\r\n            // 三角形連接：創建三個線電壓源\r\n            const lineVoltages = [\r\n                { name: 'AB', nodes: [this.nodes[0], this.nodes[1]], phase: 'A' },\r\n                { name: 'BC', nodes: [this.nodes[1], this.nodes[2]], phase: 'B' },  \r\n                { name: 'CA', nodes: [this.nodes[2], this.nodes[0]], phase: 'C' }\r\n            ];\r\n            \r\n            lineVoltages.forEach(line => {\r\n                const sourceName = `${this.name}_${line.name}`;\r\n                \r\n                const source = new VoltageSource(sourceName, line.nodes, {\r\n                    type: 'SINE',\r\n                    amplitude: this.voltage * Math.sqrt(2), // 線電壓峰值\r\n                    frequency: this.frequency,\r\n                    phase: this.phaseAngles[line.phase] * 180 / Math.PI,\r\n                    offset: 0\r\n                });\r\n                \r\n                this.internalSources.push(source);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 獲取特定相的瞬時電壓\r\n     * @param {string} phase 相別 ('A', 'B', 'C')\r\n     * @param {number} time 時間 (秒)\r\n     * @returns {number} 瞬時電壓 (V)\r\n     */\r\n    getPhaseVoltage(phase, time) {\r\n        if (!this.phaseAngles[phase]) {\r\n            throw new Error(`Invalid phase: ${phase}`);\r\n        }\r\n        \r\n        const omega = 2 * Math.PI * this.frequency;\r\n        const amplitude = this.connection === 'wye' ? \r\n            this.phaseVoltage * Math.sqrt(2) : \r\n            this.voltage * Math.sqrt(2);\r\n            \r\n        return amplitude * Math.sin(omega * time + this.phaseAngles[phase]);\r\n    }\r\n\r\n    /**\r\n     * 獲取線電壓\r\n     * @param {string} line 線別 ('AB', 'BC', 'CA')\r\n     * @param {number} time 時間 (秒)\r\n     * @returns {number} 線電壓 (V)\r\n     */\r\n    getLineVoltage(line, time) {\r\n        if (this.connection === 'delta') {\r\n            // 三角形連接：直接是線電壓\r\n            const phaseMap = { 'AB': 'A', 'BC': 'B', 'CA': 'C' };\r\n            return this.getPhaseVoltage(phaseMap[line], time);\r\n        } else {\r\n            // 星形連接：線電壓 = 相電壓差\r\n            switch (line) {\r\n                case 'AB':\r\n                    return this.getPhaseVoltage('A', time) - this.getPhaseVoltage('B', time);\r\n                case 'BC':\r\n                    return this.getPhaseVoltage('B', time) - this.getPhaseVoltage('C', time);\r\n                case 'CA':\r\n                    return this.getPhaseVoltage('C', time) - this.getPhaseVoltage('A', time);\r\n                default:\r\n                    throw new Error(`Invalid line: ${line}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 為 MNA 分析提供印花支援\r\n     * 三相源通過內部電壓源來實現印花\r\n     */\r\n    stamp(matrix, rhs, nodeMap, voltageSourceMap, time) {\r\n        // 委託給內部電壓源進行印花\r\n        this.internalSources.forEach(source => {\r\n            if (source.stamp) {\r\n                source.stamp(matrix, rhs, nodeMap, voltageSourceMap, time);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 檢查是否需要電流變數\r\n     * @returns {boolean}\r\n     */\r\n    needsCurrentVariable() {\r\n        return true; // 三相源包含電壓源，需要電流變數\r\n    }\r\n\r\n    /**\r\n     * 獲取所需的電流變數數量\r\n     * @returns {number}\r\n     */\r\n    getCurrentVariableCount() {\r\n        return this.internalSources.length; // 每個內部電壓源需要一個電流變數\r\n    }\r\n\r\n    /**\r\n     * 獲取三相源資訊\r\n     * @returns {Object}\r\n     */\r\n    getThreePhaseInfo() {\r\n        return {\r\n            name: this.name,\r\n            connection: this.connection,\r\n            voltage: this.voltage,\r\n            phaseVoltage: this.phaseVoltage,\r\n            frequency: this.frequency,\r\n            phaseSequence: this.phaseSequence,\r\n            phaseOffset: this.phaseOffset,\r\n            nodes: this.nodes,\r\n            phaseAngles: Object.fromEntries(\r\n                Object.entries(this.phaseAngles).map(([k, v]) => [k, v * 180 / Math.PI])\r\n            ),\r\n            internalSources: this.internalSources.map(s => s.name)\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 獲取元件資訊字串\r\n     * @returns {string}\r\n     */\r\n    toString() {\r\n        const connectionStr = this.connection.toUpperCase();\r\n        const nodesStr = this.nodes.join('-');\r\n        \r\n        return `${this.name} (3Phase ${connectionStr}): ${nodesStr}, ${this.voltage}V, ${this.frequency}Hz, ${this.phaseSequence}`;\r\n    }\r\n\r\n    /**\r\n     * 序列化為 JSON\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            connection: this.connection,\r\n            voltage: this.voltage,\r\n            frequency: this.frequency,\r\n            phaseSequence: this.phaseSequence,\r\n            phaseOffset: this.phaseOffset,\r\n            threePhaseInfo: this.getThreePhaseInfo()\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 復製三相源\r\n     * @returns {ThreePhaseSource}\r\n     */\r\n    clone() {\r\n        return new ThreePhaseSource(this.name, {\r\n            nodes: [...this.nodes],\r\n            connection: this.connection,\r\n            voltage: this.voltage,\r\n            frequency: this.frequency,\r\n            phaseSequence: this.phaseSequence,\r\n            phaseOffset: this.phaseOffset\r\n        }, { ...this.params });\r\n    }\r\n}","/**\r\n * 電壓控制 MOSFET 模型 - 基於閘極電壓自動決定導通狀態\r\n * \r\n * 特點：\r\n * - 基於 Vgs 閾值電壓自動切換導通狀態\r\n * - 支援線性區和飽和區模型\r\n * - 包含體二極體和寄生電容\r\n * - 適用於閘極驅動電路分析\r\n */\r\n\r\nimport { BaseComponent } from './base.js';\r\n\r\n/**\r\n * 電壓控制 MOSFET\r\n * \r\n * 這個模型實現了：\r\n * 1. 根據 Vgs 自動決定 ON/OFF 狀態\r\n * 2. 閾值電壓 (Vth) 和跨導 (gm) 特性\r\n * 3. 線性區和飽和區行為\r\n * 4. 寄生效應（體二極體、電容）\r\n */\r\nexport class VoltageControlledMOSFET extends BaseComponent {\r\n    /**\r\n     * @param {string} name MOSFET名稱 (如 'M1', 'Q1')\r\n     * @param {string[]} nodes 連接節點 [drain, gate, source] 或 [drain, gate, source, bulk]\r\n     * @param {Object} params MOSFET參數\r\n     * @param {Object} modelParams 額外模型參數\r\n     * \r\n     * 主要參數：\r\n     * - Vth: 閾值電壓 (V)\r\n     * - Kp: 跨導參數 (A/V²)\r\n     * - W/L: 寬長比\r\n     * - Ron: 導通電阻 (Ω)\r\n     * - Vf_body: 體二極體順向電壓 (V)\r\n     */\r\n    constructor(name, nodes, params = {}, modelParams = {}) {\r\n        super(name, 'VM', nodes, 0, { ...params, ...modelParams });\r\n        \r\n        if (nodes.length < 3 || nodes.length > 4) {\r\n            throw new Error(`VoltageControlledMOSFET ${name} must have 3 or 4 nodes: [drain, gate, source] or [drain, gate, source, bulk]`);\r\n        }\r\n        \r\n        // 節點分配\r\n        this.drain = nodes[0];\r\n        this.gate = nodes[1];\r\n        this.source = nodes[2];\r\n        this.bulk = nodes[3] || nodes[2]; // 如果沒有指定 bulk，預設接 source\r\n        \r\n        // MOSFET 基本參數\r\n        this.Vth = this.safeParseValue(params.Vth, 2.0);        // 閾值電壓 (V)\r\n        this.Kp = this.safeParseValue(params.Kp, 100e-6);      // 跨導參數 (A/V²)\r\n        this.W = this.safeParseValue(params.W, 100e-6);        // 通道寬度 (m)\r\n        this.L = this.safeParseValue(params.L, 10e-6);         // 通道長度 (m)\r\n        this.lambda = this.safeParseValue(params.lambda, 0);   // 通道長度調制參數 (V⁻¹)\r\n        \r\n        // 寄生參數\r\n        this.Ron = this.safeParseValue(params.Ron, 0.1);       // 導通電阻 (Ω)\r\n        this.Roff = this.safeParseValue(params.Roff, 1e9);     // 關斷電阻 (Ω)\r\n        this.Vf_body = this.safeParseValue(params.Vf_body, 0.7); // 體二極體順向電壓 (V)\r\n        this.Ron_body = this.safeParseValue(params.Ron_body, 0.01); // 體二極體導通電阻 (Ω)\r\n        \r\n        // 電容參數 (暫時簡化，不在 MNA 中處理)\r\n        this.Cgs = this.safeParseValue(params.Cgs, 1e-12);     // 閘源電容 (F)\r\n        this.Cgd = this.safeParseValue(params.Cgd, 1e-12);     // 閘汲電容 (F) \r\n        this.Cds = this.safeParseValue(params.Cds, 1e-12);     // 汲源電容 (F)\r\n        \r\n        // 模型類型\r\n        this.modelType = params.modelType || 'NMOS'; // 'NMOS' 或 'PMOS'\r\n        this.operatingRegion = 'OFF'; // 'OFF', 'LINEAR', 'SATURATION'\r\n        \r\n        // 狀態變數\r\n        this.Vgs = 0;  // 閘源電壓\r\n        this.Vds = 0;  // 汲源電壓\r\n        this.Vbs = 0;  // 體源電壓\r\n        this.Id = 0;   // 汲極電流\r\n        \r\n        // 驗證參數\r\n        this.validate();\r\n    }\r\n\r\n    /**\r\n     * 安全地解析數值參數\r\n     */\r\n    safeParseValue(value, defaultValue) {\r\n        try {\r\n            if (value === undefined || value === null) {\r\n                return defaultValue;\r\n            }\r\n            return this.parseValue(value);\r\n        } catch (error) {\r\n            return defaultValue;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 更新 MOSFET 的工作電壓\r\n     * @param {Map} nodeVoltages 節點電壓映射\r\n     */\r\n    updateVoltages(nodeVoltages) {\r\n        const Vd = nodeVoltages.get(this.drain) || 0;\r\n        const Vg = nodeVoltages.get(this.gate) || 0;\r\n        const Vs = nodeVoltages.get(this.source) || 0;\r\n        const Vb = nodeVoltages.get(this.bulk) || Vs;\r\n        \r\n        this.Vgs = Vg - Vs;\r\n        this.Vds = Vd - Vs;\r\n        this.Vbs = Vb - Vs;\r\n        \r\n        // 更新工作區域和電流\r\n        this.updateOperatingRegion();\r\n        this.calculateDrainCurrent();\r\n    }\r\n\r\n    /**\r\n     * 判斷 MOSFET 工作區域\r\n     */\r\n    updateOperatingRegion() {\r\n        const effectiveVth = this.getEffectiveThresholdVoltage();\r\n        \r\n        if (this.modelType === 'NMOS') {\r\n            if (this.Vgs < effectiveVth) {\r\n                this.operatingRegion = 'OFF';\r\n            } else if (this.Vds < (this.Vgs - effectiveVth)) {\r\n                this.operatingRegion = 'LINEAR';\r\n            } else {\r\n                this.operatingRegion = 'SATURATION';\r\n            }\r\n        } else { // PMOS\r\n            if (this.Vgs > effectiveVth) {\r\n                this.operatingRegion = 'OFF';\r\n            } else if (this.Vds > (this.Vgs - effectiveVth)) {\r\n                this.operatingRegion = 'LINEAR';\r\n            } else {\r\n                this.operatingRegion = 'SATURATION';\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 獲取有效閾值電壓（考慮體效應）\r\n     * @returns {number} 有效閾值電壓 (V)\r\n     */\r\n    getEffectiveThresholdVoltage() {\r\n        // 簡化的體效應模型：Vth_eff = Vth + γ * (sqrt(|Vbs| + 2φf) - sqrt(2φf))\r\n        // 這裡使用簡化版本，忽略體效應\r\n        return this.Vth;\r\n    }\r\n\r\n    /**\r\n     * 計算汲極電流\r\n     */\r\n    calculateDrainCurrent() {\r\n        const effectiveVth = this.getEffectiveThresholdVoltage();\r\n        const beta = this.Kp * this.W / this.L; // 跨導參數\r\n        \r\n        switch (this.operatingRegion) {\r\n            case 'OFF':\r\n                this.Id = 0;\r\n                break;\r\n                \r\n            case 'LINEAR':\r\n                // 線性區：Id = β * [(Vgs - Vth) * Vds - Vds²/2] * (1 + λ * Vds)\r\n                const Vov = this.Vgs - effectiveVth; // 過驅動電壓\r\n                this.Id = beta * (Vov * this.Vds - this.Vds * this.Vds / 2) * (1 + this.lambda * this.Vds);\r\n                break;\r\n                \r\n            case 'SATURATION':\r\n                // 飽和區：Id = β/2 * (Vgs - Vth)² * (1 + λ * Vds)\r\n                const Vov_sat = this.Vgs - effectiveVth;\r\n                this.Id = (beta / 2) * Vov_sat * Vov_sat * (1 + this.lambda * this.Vds);\r\n                break;\r\n        }\r\n        \r\n        // 確保電流方向正確（NMOS vs PMOS）\r\n        if (this.modelType === 'PMOS') {\r\n            this.Id = -this.Id;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 獲取等效電阻（用於 MNA 分析的簡化模型）\r\n     * @returns {number} 等效電阻 (Ω)\r\n     */\r\n    getEquivalentResistance() {\r\n        if (this.operatingRegion === 'OFF') {\r\n            return this.Roff;\r\n        } else {\r\n            // 使用導通電阻作為簡化模型\r\n            // 在實際應用中，這裡應該根據工作點計算小信號電阻\r\n            return this.Ron;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 檢查體二極體是否導通\r\n     * 體二極體是從 Source 到 Drain 的內建二極體\r\n     * @returns {boolean}\r\n     */\r\n    isBodyDiodeOn() {\r\n        // 體二極體：source 到 drain（對於 NMOS）\r\n        if (this.modelType === 'NMOS') {\r\n            // 當 Vs > Vd + Vf 時，體二極體導通（電流從 source 流向 drain）\r\n            return (-this.Vds) > this.Vf_body;\r\n        } else {\r\n            // 對於 PMOS，體二極體方向相反\r\n            return this.Vds > this.Vf_body;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 為 MNA 分析提供印花支援\r\n     * 使用等效電阻模型進行簡化分析\r\n     */\r\n    stamp(matrix, rhs, nodeMap, voltageSourceMap, time) {\r\n        // 獲取節點索引\r\n        const drainIndex = this.drain === '0' ? -1 : nodeMap.get(this.drain);\r\n        const sourceIndex = this.source === '0' ? -1 : nodeMap.get(this.source);\r\n        \r\n        if (drainIndex === undefined || sourceIndex === undefined) {\r\n            throw new Error(`VoltageControlledMOSFET ${this.name}: Node mapping not found`);\r\n        }\r\n        \r\n        // === 1. MOSFET 通道模型 ===\r\n        const channelResistance = this.getEquivalentResistance();\r\n        const channelConductance = 1 / channelResistance;\r\n        \r\n        // 印花 MOSFET 通道電阻 (drain-source)\r\n        if (drainIndex >= 0) {\r\n            matrix.addAt(drainIndex, drainIndex, channelConductance);\r\n            if (sourceIndex >= 0) {\r\n                matrix.addAt(drainIndex, sourceIndex, -channelConductance);\r\n            }\r\n        }\r\n        \r\n        if (sourceIndex >= 0) {\r\n            matrix.addAt(sourceIndex, sourceIndex, channelConductance);\r\n            if (drainIndex >= 0) {\r\n                matrix.addAt(sourceIndex, drainIndex, -channelConductance);\r\n            }\r\n        }\r\n        \r\n        // === 2. 體二極體模型 ===\r\n        // 體二極體是從 source 到 drain 的反向並聯二極體\r\n        // 導通條件：Vs - Vd > Vf_body (源極電壓高於汲極電壓 + 順向壓降)\r\n        \r\n        // 檢查體二極體是否應該導通\r\n        const bodyDiodeOn = this.isBodyDiodeOn();\r\n        \r\n        if (bodyDiodeOn) {\r\n            // 體二極體導通：建模為理想電壓源 + 串聯電阻\r\n            // 等效電路：從 source 到 drain，壓降 = Vf_body\r\n            \r\n            const diodeConductance = 1 / this.Ron_body;\r\n            \r\n            // 添加體二極體的導納矩陣 (與通道並聯)\r\n            if (drainIndex >= 0) {\r\n                matrix.addAt(drainIndex, drainIndex, diodeConductance);\r\n                if (sourceIndex >= 0) {\r\n                    matrix.addAt(drainIndex, sourceIndex, -diodeConductance);\r\n                }\r\n            }\r\n            \r\n            if (sourceIndex >= 0) {\r\n                matrix.addAt(sourceIndex, sourceIndex, diodeConductance);\r\n                if (drainIndex >= 0) {\r\n                    matrix.addAt(sourceIndex, drainIndex, -diodeConductance);\r\n                }\r\n            }\r\n            \r\n            // 添加體二極體的電壓源項到右側向量\r\n            // 電流 = G * (Vs - Vd - Vf_body)\r\n            // 重新排列：G * Vs - G * Vd = G * Vf_body\r\n            // 右側項：drain 節點 = -G * Vf_body, source 節點 = +G * Vf_body\r\n            \r\n            const voltageTerm = diodeConductance * this.Vf_body;\r\n            \r\n            if (drainIndex >= 0) {\r\n                rhs.addAt(drainIndex, -voltageTerm);\r\n            }\r\n            if (sourceIndex >= 0) {\r\n                rhs.addAt(sourceIndex, voltageTerm);\r\n            }\r\n        }\r\n        \r\n        // 調試輸出（簡化）\r\n        if (this.name === 'M1' && bodyDiodeOn) {\r\n            console.log(`${this.name}: Body diode ON, Vds=${this.Vds.toFixed(2)}V, Channel R=${channelResistance.toExponential(1)}Ω`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 更新元件歷史狀態（在每個時間步求解後調用）\r\n     * @param {Map} nodeVoltages 節點電壓映射\r\n     * @param {Map} branchCurrents 支路電流映射\r\n     */\r\n    updateHistory(nodeVoltages, branchCurrents) {\r\n        // 🔥 關鍵修正：在每個時間步後更新 MOSFET 的工作狀態\r\n        this.updateVoltages(nodeVoltages);\r\n        \r\n        // 調用父類的 updateHistory\r\n        super.updateHistory(nodeVoltages, branchCurrents);\r\n    }\r\n\r\n    /**\r\n     * 設置閘極狀態（由控制器調用）\r\n     * @param {boolean} state 閘極狀態（true=ON, false=OFF）\r\n     */\r\n    setGateState(state) {\r\n        // 這個方法由 solver 的 updateControlInputs 調用\r\n        // 我們可以在這裡設置閘極電壓，但實際上閘極電壓由 VoltageSource 控制\r\n        // 因此這個方法主要用於觸發狀態更新\r\n        this.gateState = state;\r\n        \r\n        // 觸發電壓和工作狀態更新\r\n        // 注意：這裡無法獲取實際的節點電壓，需要等到 stamp 時再更新\r\n    }\r\n\r\n    /**\r\n     * 檢查是否需要電流變數\r\n     * @returns {boolean}\r\n     */\r\n    needsCurrentVariable() {\r\n        return false; // 使用等效電阻模型，不需要額外電流變數\r\n    }\r\n\r\n    /**\r\n     * 計算通過MOSFET的電流\r\n     * @param {Map<string, number>} nodeVoltages 節點電壓\r\n     * @returns {number} 汲極電流 (安培)，正值表示從drain流向source\r\n     */\r\n    getCurrent(nodeVoltages) {\r\n        // 更新電壓\r\n        this.updateVoltages(nodeVoltages);\r\n        \r\n        // 更新操作點\r\n        this.operatingPoint.current = this.Id;\r\n        \r\n        return this.Id;\r\n    }\r\n\r\n    /**\r\n     * 驗證 MOSFET 參數\r\n     */\r\n    validate() {\r\n        if (this.Kp <= 0) {\r\n            throw new Error(`VoltageControlledMOSFET ${this.name}: Kp must be positive`);\r\n        }\r\n        if (this.W <= 0 || this.L <= 0) {\r\n            throw new Error(`VoltageControlledMOSFET ${this.name}: W and L must be positive`);\r\n        }\r\n        if (this.Ron <= 0) {\r\n            throw new Error(`VoltageControlledMOSFET ${this.name}: Ron must be positive`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 獲取詳細工作狀態\r\n     * @returns {Object}\r\n     */\r\n    getOperatingStatus() {\r\n        return {\r\n            name: this.name,\r\n            type: 'VoltageControlledMOSFET',\r\n            modelType: this.modelType,\r\n            operatingRegion: this.operatingRegion,\r\n            voltages: {\r\n                Vgs: this.Vgs,\r\n                Vds: this.Vds,\r\n                Vbs: this.Vbs\r\n            },\r\n            current: {\r\n                Id: this.Id\r\n            },\r\n            equivalentResistance: this.getEquivalentResistance(),\r\n            bodyDiodeOn: this.isBodyDiodeOn(),\r\n            parameters: {\r\n                Vth: this.Vth,\r\n                Kp: this.Kp,\r\n                WoverL: this.W / this.L\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 獲取元件資訊字串\r\n     * @returns {string}\r\n     */\r\n    toString() {\r\n        return `${this.name} (${this.modelType} VC-MOSFET): D=${this.drain} G=${this.gate} S=${this.source}, ` +\r\n               `Vth=${this.Vth}V, Region=${this.operatingRegion}, Id=${this.Id.toExponential(3)}A`;\r\n    }\r\n\r\n    /**\r\n     * 復製 MOSFET\r\n     * @returns {VoltageControlledMOSFET}\r\n     */\r\n    clone() {\r\n        const nodes = [this.drain, this.gate, this.source];\r\n        if (this.bulk !== this.source) {\r\n            nodes.push(this.bulk);\r\n        }\r\n        \r\n        return new VoltageControlledMOSFET(this.name, nodes, {\r\n            Vth: this.Vth,\r\n            Kp: this.Kp,\r\n            W: this.W,\r\n            L: this.L,\r\n            lambda: this.lambda,\r\n            Ron: this.Ron,\r\n            Roff: this.Roff,\r\n            Vf_body: this.Vf_body,\r\n            Ron_body: this.Ron_body,\r\n            modelType: this.modelType\r\n        }, { ...this.params });\r\n    }\r\n}","/**\r\n * Diode 元件模型 (理想二極體模型)\r\n * \r\n * 特點：\r\n * - 基於電壓控制的開關模型\r\n * - 包含順向偏壓電壓 (Vf) 和導通電阻 (Ron)\r\n * - 適用於整流電路、續流二極體等應用\r\n * - 自動根據陽極-陰極電壓決定導通狀態\r\n */\r\n\r\nimport { BaseComponent } from './base.js';\r\n\r\n/**\r\n * 理想二極體模型\r\n * \r\n * 這個模型實現了：\r\n * 1. 當 Va > Vk + Vf 時二極體導通 (低電阻)\r\n * 2. 當 Va <= Vk + Vf 時二極體截止 (高電阻)  \r\n * 3. 支援快速狀態切換和非線性分析\r\n */\r\nexport class Diode extends BaseComponent {\r\n    /**\r\n     * @param {string} name 二極體名稱 (如 'D1', 'CR1')\r\n     * @param {string[]} nodes 連接節點 [anode, cathode]\r\n     * @param {Object} params 參數 {Vf, Ron, Roff}\r\n     */\r\n    constructor(name, nodes, params = {}) {\r\n        super(name, 'D', nodes, 0, params);\r\n        \r\n        if (nodes.length < 2) {\r\n            throw new Error(`Diode ${name} must have 2 nodes: [anode, cathode]`);\r\n        }\r\n        \r\n        // 二極體參數 - 安全地解析參數，如果解析失敗使用默認值\r\n        this.Vf = this.safeParseValue(params.Vf, 0.7);        // 順向偏壓電壓 (默認 0.7V)\r\n        this.Ron = this.safeParseValue(params.Ron, 0.01);     // 導通電阻 (默認 10mΩ)\r\n        this.Roff = this.safeParseValue(params.Roff, 1e6);    // 截止電阻 (默認 1MΩ)\r\n        \r\n        // 節點分配\r\n        this.anode = nodes[0];      // 陽極\r\n        this.cathode = nodes[1];    // 陰極\r\n        \r\n        // 狀態追蹤\r\n        this.isForwardBiased = false;   // 是否順向偏壓\r\n        this.anodeCathodeVoltage = 0;   // 陽極-陰極電壓\r\n        this.current = 0;               // 通過電流\r\n        \r\n        // 初始化參數驗證\r\n        this.validate();\r\n    }\r\n\r\n    /**\r\n     * 安全地解析數值參數，如果失敗則返回默認值\r\n     * @param {*} value 要解析的值\r\n     * @param {number} defaultValue 默認值\r\n     * @returns {number} 解析後的數值或默認值\r\n     */\r\n    safeParseValue(value, defaultValue) {\r\n        try {\r\n            if (value === undefined || value === null) {\r\n                return defaultValue;\r\n            }\r\n            return this.parseValue(value);\r\n        } catch (error) {\r\n            return defaultValue;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 驗證二極體參數\r\n     */\r\n    validate() {\r\n        if (this.Ron <= 0) {\r\n            throw new Error(`Diode ${this.name}: Ron must be positive`);\r\n        }\r\n        if (this.Roff <= this.Ron) {\r\n            throw new Error(`Diode ${this.name}: Roff must be greater than Ron`);\r\n        }\r\n        if (this.Vf < 0) {\r\n            throw new Error(`Diode ${this.name}: Forward voltage Vf must be non-negative`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 計算二極體的等效電阻\r\n     * @param {number} vak 陽極-陰極電壓 (V)\r\n     * @returns {number} 等效電阻 (歐姆)\r\n     */\r\n    getEquivalentResistance(vak) {\r\n        // 二極體導通條件：Va > Vk + Vf，即 vak > Vf\r\n        this.isForwardBiased = vak > this.Vf;\r\n        return this.isForwardBiased ? this.Ron : this.Roff;\r\n    }\r\n\r\n    /**\r\n     * 檢查二極體是否處於導通狀態\r\n     * @returns {boolean}\r\n     */\r\n    isOn() {\r\n        return this.isForwardBiased;\r\n    }\r\n\r\n    /**\r\n     * 獲取二極體壓降 (包含順向偏壓電壓)\r\n     * @returns {number} 實際壓降 (V)\r\n     */\r\n    getVoltageDrop() {\r\n        if (this.isForwardBiased) {\r\n            // 導通時：壓降 = Vf + I * Ron\r\n            return this.Vf + this.current * this.Ron;\r\n        } else {\r\n            // 截止時：壓降等於陽極-陰極電壓\r\n            return this.anodeCathodeVoltage;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 為 MNA 分析提供印花 (stamping) 支援\r\n     * 注意：這是一個非線性元件，需要在每次迭代中更新\r\n     * \r\n     * @param {Matrix} matrix MNA 矩陣\r\n     * @param {Vector} rhs 右側向量  \r\n     * @param {Map} nodeMap 節點映射\r\n     * @param {Map} voltageSourceMap 電壓源映射\r\n     * @param {number} time 當前時間\r\n     */\r\n    stamp(matrix, rhs, nodeMap, voltageSourceMap, time) {\r\n        // 獲取節點索引，接地節點返回 -1\r\n        const anodeIndex = this.anode === '0' || this.anode === 'gnd' ? -1 : nodeMap.get(this.anode);\r\n        const cathodeIndex = this.cathode === '0' || this.cathode === 'gnd' ? -1 : nodeMap.get(this.cathode);\r\n        \r\n        if (anodeIndex === undefined || cathodeIndex === undefined) {\r\n            throw new Error(`Diode ${this.name}: Node mapping not found (anode: ${this.anode}, cathode: ${this.cathode})`);\r\n        }\r\n\r\n        // 獲取當前陽極-陰極電壓 (初始化時為0)\r\n        let vak = 0;\r\n        if (this.anodeCathodeVoltage !== undefined) {\r\n            vak = this.anodeCathodeVoltage;\r\n        }\r\n\r\n        const resistance = this.getEquivalentResistance(vak);\r\n        const conductance = 1 / resistance;\r\n\r\n        // 印花導納矩陣 (類似電阻的印花方式)\r\n        // 接地節點 (index = -1) 不需要印花到矩陣中\r\n        if (anodeIndex >= 0) {\r\n            matrix.addAt(anodeIndex, anodeIndex, conductance);\r\n            if (cathodeIndex >= 0) {\r\n                matrix.addAt(anodeIndex, cathodeIndex, -conductance);\r\n            }\r\n        }\r\n        \r\n        if (cathodeIndex >= 0) {\r\n            matrix.addAt(cathodeIndex, cathodeIndex, conductance);\r\n            if (anodeIndex >= 0) {\r\n                matrix.addAt(cathodeIndex, anodeIndex, -conductance);\r\n            }\r\n        }\r\n\r\n        // 如果二極體導通，需要在 RHS 向量中添加順向偏壓的影響\r\n        if (this.isForwardBiased) {\r\n            const currentSource = this.Vf / resistance;  // 等效電流源\r\n            \r\n            if (anodeIndex >= 0) {\r\n                rhs.addAt(anodeIndex, -currentSource);\r\n            }\r\n            if (cathodeIndex >= 0) {\r\n                rhs.addAt(cathodeIndex, currentSource);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 更新元件狀態 (在每個時間步後調用)\r\n     * @param {number} vak 陽極-陰極電壓\r\n     * @param {number} iak 陽極到陰極電流\r\n     */\r\n    updateState(vak, iak) {\r\n        this.anodeCathodeVoltage = vak;\r\n        this.current = iak;\r\n        \r\n        // 更新導通狀態\r\n        this.isForwardBiased = vak > this.Vf;\r\n    }\r\n\r\n    /**\r\n     * 更新歷史狀態 (在每個時間步結束時調用)\r\n     * @param {Map<string, number>} nodeVoltages 節點電壓\r\n     * @param {Map<string, number>} branchCurrents 支路電流\r\n     */\r\n    updateHistory(nodeVoltages, branchCurrents) {\r\n        // 調用基類方法\r\n        super.updateHistory(nodeVoltages, branchCurrents);\r\n        \r\n        // 計算陽極-陰極電壓\r\n        const anodeVoltage = nodeVoltages.get(this.anode) || 0;\r\n        const cathodeVoltage = nodeVoltages.get(this.cathode) || 0;\r\n        const vak = anodeVoltage - cathodeVoltage;\r\n        \r\n        // 計算電流 (使用歐姆定律)\r\n        const resistance = this.getEquivalentResistance(vak);\r\n        const current = vak / resistance;\r\n        \r\n        // 更新狀態\r\n        this.updateState(vak, current);\r\n    }\r\n\r\n    /**\r\n     * 檢查是否需要電流變數 (對於理想二極體，通常不需要)\r\n     * @returns {boolean}\r\n     */\r\n    needsCurrentVariable() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * 獲取元件資訊字串\r\n     * @returns {string}\r\n     */\r\n    toString() {\r\n        return `${this.name} (Diode): A=${this.anode} K=${this.cathode}, ` +\r\n               `State=${this.isForwardBiased ? 'ON' : 'OFF'}, Vf=${this.Vf}V, Ron=${this.Ron}Ω`;\r\n    }\r\n\r\n    /**\r\n     * 獲取詳細的工作狀態\r\n     * @returns {Object}\r\n     */\r\n    getOperatingStatus() {\r\n        return {\r\n            name: this.name,\r\n            type: 'Diode',\r\n            state: this.isForwardBiased ? 'ON' : 'OFF',\r\n            anodeCathodeVoltage: this.anodeCathodeVoltage,\r\n            current: this.current,\r\n            voltageDrop: this.getVoltageDrop(),\r\n            currentResistance: this.getEquivalentResistance(this.anodeCathodeVoltage),\r\n            isForwardBiased: this.isForwardBiased\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 序列化為 JSON\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            Vf: this.Vf,\r\n            Ron: this.Ron,\r\n            Roff: this.Roff,\r\n            operatingStatus: this.getOperatingStatus()\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 復製二極體\r\n     * @returns {Diode}\r\n     */\r\n    clone() {\r\n        return new Diode(this.name, this.nodes, {\r\n            Vf: this.Vf,\r\n            Ron: this.Ron,\r\n            Roff: this.Roff\r\n        });\r\n    }\r\n}","/**\r\n * 多繞組變壓器模型 - 專為 LLC、Flyback、Forward 等高階拓撲設計\r\n * 🔥 修正版 v2：確保互感值為正，由 MNA 求解器處理極性。\r\n */\r\n\r\nimport { BaseComponent } from './base.js';\r\nimport { Inductor } from './inductor.js';\r\n\r\nexport class MultiWindingTransformer {\r\n    /**\r\n     * @param {string} name 變壓器名稱 (如 'T1', 'XFMR1')\r\n     * @param {Object} config 變壓器配置\r\n     */\r\n    constructor(name, config) {\r\n        this.name = name;\r\n        this.type = 'T_META'; // 標記為元元件\r\n\r\n        if (!config || !config.windings || config.windings.length < 2) {\r\n            throw new Error(`Transformer ${name} must have at least 2 windings`);\r\n        }\r\n        \r\n        const numWindings = config.windings.length;\r\n        \r\n        // 1. 創建內部 Inductor 實例\r\n        this.inductors = config.windings.map((windingDef, index) => {\r\n            const inductorName = `${name}_${windingDef.name || `W${index+1}`}`;\r\n            return new Inductor(inductorName, windingDef.nodes, windingDef.inductance, {\r\n                r: windingDef.resistance || 0\r\n            });\r\n        });\r\n\r\n        // 2. 建立耦合矩陣\r\n        const couplingMatrix = this.buildCouplingMatrix(numWindings, config.couplingMatrix);\r\n\r\n        // 3. 計算互感矩陣\r\n        const mutualMatrix = this.calculateMutualInductanceMatrix(couplingMatrix);\r\n\r\n        // 4. 將耦合資訊注入到每個 Inductor 實例中\r\n        for (let i = 0; i < numWindings; i++) {\r\n            const inductorI = this.inductors[i];\r\n            inductorI.couplings = [];\r\n\r\n            for (let j = 0; j < numWindings; j++) {\r\n                if (i === j) continue;\r\n\r\n                const inductorJ = this.inductors[j];\r\n                const mutualInductance = mutualMatrix[i][j];\r\n                \r\n                // 🔥 核心修正：\r\n                // MNA 矩陣的印花邏輯 (mna.js) 會自動處理負號以符合物理公式。\r\n                // 因此這裡的互感值必須為正，以避免雙重否定導致的相位反轉。\r\n                const polarity = 1.0; \r\n\r\n                inductorI.couplings.push({\r\n                    inductor: inductorJ,\r\n                    mutualInductance: mutualInductance * polarity\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 🔥 核心方法：返回構成變壓器的所有實際元件\r\n     * @returns {Inductor[]}\r\n     */\r\n    getComponents() {\r\n        return this.inductors;\r\n    }\r\n\r\n    buildCouplingMatrix(n, userMatrix) {\r\n        const matrix = Array(n).fill(null).map(() => Array(n).fill(0));\r\n        for (let i = 0; i < n; i++) matrix[i][i] = 1.0;\r\n\r\n        if (userMatrix) {\r\n            for (let i = 0; i < n; i++) {\r\n                for (let j = i + 1; j < n; j++) {\r\n                    const k = (userMatrix[i] && userMatrix[i][j] !== undefined) ? userMatrix[i][j] : 0.99;\r\n                    matrix[i][j] = matrix[j][i] = Math.max(-1, Math.min(1, k));\r\n                }\r\n            }\r\n        } else {\r\n            const defaultK = 0.99;\r\n            for (let i = 0; i < n; i++) {\r\n                for (let j = i + 1; j < n; j++) {\r\n                    matrix[i][j] = matrix[j][i] = defaultK;\r\n                }\r\n            }\r\n        }\r\n        return matrix;\r\n    }\r\n\r\n    calculateMutualInductanceMatrix(couplingMatrix) {\r\n        const n = this.inductors.length;\r\n        const mutualMatrix = Array(n).fill(null).map(() => Array(n).fill(0));\r\n        \r\n        for (let i = 0; i < n; i++) {\r\n            for (let j = i; j < n; j++) {\r\n                if (i === j) {\r\n                    mutualMatrix[i][j] = this.inductors[i].getInductance();\r\n                } else {\r\n                    const Li = this.inductors[i].getInductance();\r\n                    const Lj = this.inductors[j].getInductance();\r\n                    const k_ij = couplingMatrix[i][j];\r\n                    const M = k_ij * Math.sqrt(Li * Lj);\r\n                    mutualMatrix[i][j] = mutualMatrix[j][i] = M;\r\n                }\r\n            }\r\n        }\r\n        return mutualMatrix;\r\n    }\r\n    \r\n    toString() {\r\n        return `${this.name} (MultiWinding Transformer with ${this.inductors.length} windings)`;\r\n    }\r\n}"],"names":["BaseComponent","name","type","nodes","value","params","trimmedValue","suffixes","numPart","suffix","multiplier","numValue","timeStep","nodeVoltages","branchCurrents","v1","v2","voltage","json","LinearTwoTerminal","Resistor","resistance","deltaT","tempFactor","current","resistanceStr","Capacitor","capacitance","C","previousVoltage","currentVoltage","info","capacitanceStr","result","Inductor","inductance","L","previousCurrent","diDt","inductanceStr","CoupledInductor","L1","L2","couplingFactor","M","VoltageSource","source","sourceStr","str","dcMatch","sineMatch","pulseMatch","time","config","offset","amplitude","frequency","delay","damping","t","omega","dampingFactor","td","tr","tf","pw","per","cycleTime","fallTime","td1","tau1","td2","tau2","t1","t2","v_td2","points","valueStr","newValue","CurrentSource","tempVoltageSource","VCVS","outputNodes","controlNodes","gain","allNodes","VCCS","transconductance","CCCS","controlElement","currentGain","matrix","rhs","nodeMap","voltageSourceMap","outputCurrent","node1","node2","CCVS","transresistance","outputVoltage","currentVarIndex","MOSFET","mnaNodes","defaultValue","state","vds","rMosfet","rDiode","drainIndex","sourceIndex","conductance","ids","rTotal","gateInfo","cloned","NetlistParser","netlistText","lines","line","processedLines","error","processed","currentLine","commentIndex","lineNumber","tokens","firstChar","component","resistor","capacitor","inductor","drain","gate","mosfetParams","mosfet","sourceSpec","voltageSource","currentSource","vcvs","vccs","directive","analysis","i","param","equalIndex","modelName","modelType","modelParams","option","token","key","numberPart","componentTypes","comp","count","Matrix","rows","cols","data","j","size","newData","row","precision","val","Vector","values","LUSolver","A","b","x","permutation","n","_","k","maxRow","maxVal","pivot","factor","newVal","row1","row2","temp","LU","sum","maxDiag","minDiag","MNABuilder","components","nodeSet","voltageSourceSet","node","nodeIndex","vsIndex","vsName","n1","n2","h","Geq","currIndex","coupling","otherInductor","otherCurrIndex","R","no1","no2","nc1","nc2","nodeName","index","solution","voltages","currents","header","label","TransientResult","branchName","actualNodeName","voltageMatch","actualBranchName","currentMatch","vectorName","voltageVector","currentVector","vectors","timeSteps","step","TransientAnalysis","currentTime","stepCount","totalSteps","progress","branch","enabled","maxIterations","converged","TransientUtils","command","match","timeStr","abs","DCResult","power","nodeCount","branchCount","DCAnalysis","options","tolerance","iteration","newSolution","maxChange","change","tempNodeVoltages","tempBranchCurrents","totalSupplied","totalDissipated","AkingSPICE","netlist","componentArray","parseResult","analysisCommand","cmd","tranCommand","analysisType","issues","warnings","nodeConnections","connectionCount","validation","issue","warning","controlInputs","stepResult","nodeVoltagesObj","branchCurrentsObj","componentStates","componentName","c","controlFunction","results","ThreePhaseSource","basePhase","neutralNode","phase","phaseNode","sourceName","phaseMap","v","s","connectionStr","nodesStr","VoltageControlledMOSFET","Vd","Vg","Vs","Vb","effectiveVth","beta","Vov","Vov_sat","channelResistance","channelConductance","bodyDiodeOn","diodeConductance","voltageTerm","Diode","vak","anodeIndex","cathodeIndex","iak","anodeVoltage","cathodeVoltage","MultiWindingTransformer","numWindings","windingDef","inductorName","couplingMatrix","mutualMatrix","inductorI","inductorJ","mutualInductance","userMatrix","Li","Lj"],"mappings":"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"}