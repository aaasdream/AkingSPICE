(function(l,d){typeof exports=="object"&&typeof module<"u"?d(exports):typeof define=="function"&&define.amd?define(["exports"],d):(l=typeof globalThis<"u"?globalThis:l||self,d(l.AkingSPICE={}))})(this,(function(l){"use strict";class d{constructor(t,e,s,i,o={}){this.name=t,this.type=e,this.nodes=[...s],this.rawValue=i,this.params={...o},this.value=this.parseValue(i),this.timeStep=null,this.previousValues=new Map,this.historyTerm=0,this.operatingPoint={voltage:0,current:0,power:0},this.temperature=o.temp||27,this.isNonlinear=!1}parseValue(t){if(typeof t=="number")return t;if(typeof t=="string"){const e=t.trim(),s={T:1e12,G:1e9,MEG:1e6,M:1e6,K:1e3,k:1e3,m:.001,u:1e-6,µ:1e-6,n:1e-9,p:1e-12,f:1e-15};if(e.toUpperCase().endsWith("MEG")){const o=parseFloat(e.slice(0,-3));if(!isNaN(o))return o*1e6}for(const[o,n]of Object.entries(s))if(e.endsWith(o)){const r=parseFloat(e.slice(0,-o.length));if(!isNaN(r))return r*n}const i=parseFloat(e);if(!isNaN(i))return i}throw new Error(`Cannot parse value: ${t}`)}needsCurrentVariable(){return this.type==="L"||this.type==="V"||this.type.includes("V")}initTransient(t){this.timeStep=t,this.previousValues.clear(),this.historyTerm=0}updateHistory(t,e){const s=t.get(this.nodes[0])||0,i=t.get(this.nodes[1])||0,o=s-i;this.previousValues.set("voltage",o),this.operatingPoint.voltage=o}calculatePower(){return Math.abs(this.operatingPoint.voltage*this.operatingPoint.current)}toString(){return`${this.name} (${this.type}): ${this.nodes.join("-")} = ${this.value}`}isValid(){return this.name&&this.type&&this.nodes.length>=2&&!isNaN(this.value)&&isFinite(this.value)}clone(){return this.constructor.name==="Resistor"||this.constructor.name==="Capacitor"||this.constructor.name==="Inductor"?new this.constructor(this.name,this.nodes,this.rawValue,this.params):this.constructor.name==="VoltageSource"||this.constructor.name==="CurrentSource"?new this.constructor(this.name,this.nodes,this.rawValue,this.params):new this.constructor(this.name,this.type,this.nodes,this.rawValue,this.params)}toJSON(){return{name:this.name,type:this.type,nodes:this.nodes,value:this.value,rawValue:this.rawValue,params:this.params}}static fromJSON(t){return new d(t.name,t.type,t.nodes,t.rawValue,t.params)}}class $ extends d{constructor(t,e,s,i,o={}){if(super(t,e,s,i,o),s.length!==2)throw new Error(`${e} ${t} must have exactly 2 nodes`)}getVoltage(t){const e=t.get(this.nodes[0])||0,s=t.get(this.nodes[1])||0;return e-s}}class R extends ${constructor(t,e,s,i={}){super(t,"R",e,s,i),this.tc1=i.tc1||0,this.tc2=i.tc2||0,this.tnom=i.tnom||27,this.powerRating=i.power||1/0,this.updateTemperatureCoefficient()}updateTemperatureCoefficient(){const t=this.temperature-this.tnom,e=1+this.tc1*t+this.tc2*t*t;this.actualValue=this.value*e}getResistance(){return this.actualValue||this.value}getConductance(){const t=this.getResistance();if(t===0)throw new Error(`Zero resistance in ${this.name}`);return 1/t}getCurrent(t){const s=this.getVoltage(t)/this.getResistance();return this.operatingPoint.current=s,s}updateHistory(t,e){super.updateHistory(t,e);const s=this.getCurrent(t);this.previousValues.set("current",s),this.operatingPoint.power=this.operatingPoint.voltage*s}isOverPower(){return this.operatingPoint.power>this.powerRating}getInfo(){return{...super.toJSON(),actualResistance:this.getResistance(),conductance:this.getConductance(),tc1:this.tc1,tc2:this.tc2,powerRating:this.powerRating,operatingPoint:{...this.operatingPoint},overPower:this.isOverPower()}}isValid(){return super.isValid()&&this.value>0}toString(){const t=this.getResistance();let e;return t>=1e6?e=`${(t/1e6).toFixed(2)}MΩ`:t>=1e3?e=`${(t/1e3).toFixed(2)}kΩ`:e=`${t.toFixed(2)}Ω`,`${this.name}: ${this.nodes[0]}-${this.nodes[1]} ${e}`}}class E extends ${constructor(t,e,s,i={}){super(t,"C",e,s,i),this.ic=i.ic||0,this.tc1=i.tc1||0,this.tc2=i.tc2||0,this.tnom=i.tnom||27,this.voltageRating=i.voltage||1/0,this.equivalentConductance=0,this.historyCurrentSource=0,this.updateTemperatureCoefficient()}updateTemperatureCoefficient(){const t=this.temperature-this.tnom,e=1+this.tc1*t+this.tc2*t*t;this.actualValue=this.value*e}getCapacitance(){return this.actualValue||this.value}initTransient(t){super.initTransient(t);const e=this.getCapacitance();this.equivalentConductance=e/t,this.previousValues.set("voltage",this.ic),this.historyCurrentSource=-this.equivalentConductance*this.ic}updateCompanionModel(){if(!this.timeStep)return;const t=this.previousValues.get("voltage")||0;this.historyCurrentSource=-this.equivalentConductance*t,this.historyTerm=this.historyCurrentSource}getCurrent(t){const e=this.getVoltage(t);if(!this.timeStep)return this.operatingPoint.current=0,0;const s=this.previousValues.get("voltage")||0,o=this.getCapacitance()*(e-s)/this.timeStep;return this.operatingPoint.current=o,o}getStoredEnergy(t){const e=this.getVoltage(t);return .5*this.getCapacitance()*e*e}updateHistory(t,e){super.updateHistory(t,e);const s=this.getVoltage(t),i=this.getCurrent(t);this.updateCompanionModel(),this.previousValues.set("voltage",s),this.previousValues.set("current",i),this.operatingPoint.power=s*i}isOverVoltage(t){return Math.abs(this.getVoltage(t))>this.voltageRating}getInfo(t=null){const e={...super.toJSON(),actualCapacitance:this.getCapacitance(),ic:this.ic,tc1:this.tc1,tc2:this.tc2,voltageRating:this.voltageRating,operatingPoint:{...this.operatingPoint}};return t&&(e.storedEnergy=this.getStoredEnergy(t),e.overVoltage=this.isOverVoltage(t)),this.timeStep&&(e.equivalentConductance=this.equivalentConductance,e.historyCurrentSource=this.historyCurrentSource),e}isValid(){return super.isValid()&&this.value>0}toString(){const t=this.getCapacitance();let e;t>=.001?e=`${(t*1e3).toFixed(2)}mF`:t>=1e-6?e=`${(t*1e6).toFixed(2)}µF`:t>=1e-9?e=`${(t*1e9).toFixed(2)}nF`:t>=1e-12?e=`${(t*1e12).toFixed(2)}pF`:e=`${t.toExponential(2)}F`;let s=`${this.name}: ${this.nodes[0]}-${this.nodes[1]} ${e}`;return this.ic!==0&&(s+=` IC=${this.ic}V`),s}}class v extends ${constructor(t,e,s,i={}){super(t,"L",e,s,i),this.ic=i.ic||0,this.resistance=i.r||0,this.tc1=i.tc1||0,this.tc2=i.tc2||0,this.tnom=i.tnom||27,this.currentRating=i.current||1/0,this.equivalentResistance=0,this.historyVoltageSource=0,this.needsCurrentVar=!0,this.couplings=null,this.updateTemperatureCoefficient()}updateTemperatureCoefficient(){const t=this.temperature-this.tnom,e=1+this.tc1*t+this.tc2*t*t;this.actualValue=this.value*e}getInductance(){return this.actualValue||this.value}needsCurrentVariable(){return!0}initTransient(t){super.initTransient(t);const e=this.getInductance();this.equivalentResistance=e/t,this.previousValues.set("current",this.ic),this.historyVoltageSource=this.equivalentResistance*this.ic}updateCompanionModel(){if(!this.timeStep)return;const t=this.previousValues.get("current")||0;this.historyVoltageSource=this.equivalentResistance*t,this.historyTerm=t}getVoltageFromCurrent(t){if(!this.timeStep)return t*this.resistance;const e=this.previousValues.get("current")||0,s=this.getInductance(),i=(t-e)/this.timeStep,o=s*i+this.resistance*t;return this.operatingPoint.current=t,this.operatingPoint.voltage=o,o}getStoredEnergy(t){return .5*this.getInductance()*t*t}updateHistory(t,e){super.updateHistory(t,e);const s=e.get(this.name)||0,i=this.getVoltageFromCurrent(s);this.updateCompanionModel(),this.previousValues.set("current",s),this.previousValues.set("voltage",i),this.operatingPoint.power=i*s}isOverCurrent(t){return Math.abs(t)>this.currentRating}getInfo(t=null){const e={...super.toJSON(),actualInductance:this.getInductance(),ic:this.ic,resistance:this.resistance,tc1:this.tc1,tc2:this.tc2,currentRating:this.currentRating,operatingPoint:{...this.operatingPoint}};return t!==null&&(e.storedEnergy=this.getStoredEnergy(t),e.overCurrent=this.isOverCurrent(t)),this.timeStep&&(e.equivalentResistance=this.equivalentResistance,e.historyVoltageSource=this.historyVoltageSource),e}isValid(){return super.isValid()&&this.value>0}toString(){const t=this.getInductance();let e;t>=1?e=`${t.toFixed(3)}H`:t>=.001?e=`${(t*1e3).toFixed(2)}mH`:t>=1e-6?e=`${(t*1e6).toFixed(2)}µH`:t>=1e-9?e=`${(t*1e9).toFixed(2)}nH`:e=`${t.toExponential(2)}H`;let s=`${this.name}: ${this.nodes[0]}-${this.nodes[1]} ${e}`;return this.resistance>0&&(s+=` R=${this.resistance}Ω`),this.ic!==0&&(s+=` IC=${this.ic}A`),s}}class z{constructor(t,e,s,i,o={}){this.name=t,this.type="K",this.L1=e,this.L2=s,this.k=Math.max(0,Math.min(1,i)),this.params=o,this.mutualInductance=this.k*Math.sqrt(e.getInductance()*s.getInductance()),this.dotNodes=o.dotNodes||[e.nodes[0],s.nodes[0]]}getMutualInductance(){return this.k*Math.sqrt(this.L1.getInductance()*this.L2.getInductance())}getInfo(){return{name:this.name,type:this.type,L1:this.L1.name,L2:this.L2.name,couplingFactor:this.k,mutualInductance:this.getMutualInductance(),dotNodes:this.dotNodes,L1_inductance:this.L1.getInductance(),L2_inductance:this.L2.getInductance()}}toString(){const t=this.getMutualInductance();return`${this.name}: ${this.L1.name}-${this.L2.name} k=${this.k} M=${(t*1e6).toFixed(2)}µH`}}class f extends d{constructor(t,e,s,i={}){if(super(t,"V",e,0,i),e.length!==2)throw new Error(`Voltage source ${t} must have exactly 2 nodes`);this.rawSource=s,this.sourceConfig=this.parseSourceConfig(s),this.needsCurrentVar=!0,this.value=this.sourceConfig.dc||this.sourceConfig.amplitude||0}parseSourceConfig(t){if(typeof t=="number")return{type:"DC",dc:t,amplitude:t,offset:t};if(typeof t=="string")return this.parseSpiceSource(t);if(typeof t=="object")return{type:t.type||"DC",...t};throw new Error(`Invalid voltage source specification: ${t}`)}parseSpiceSource(t){const e=t.trim().toUpperCase(),s=e.match(/^(?:DC\()?(-?[\d.]+(?:[eE][-+]?\d+)?)(?:V)?(?:\))?$/);if(s){const n=parseFloat(s[1]);return{type:"DC",dc:n,amplitude:n,offset:n}}const i=e.match(/^SINE\(\s*([-\d.]+(?:[eE][-+]?\d+)?)?\s*([-\d.]+(?:[eE][-+]?\d+)?)?\s*([-\d.]+(?:[eE][-+]?\d+)?)?\s*([-\d.]+(?:[eE][-+]?\d+)?)?\s*([-\d.]+(?:[eE][-+]?\d+)?)?\s*\)$/);if(i)return{type:"SINE",offset:parseFloat(i[1]||"0"),amplitude:parseFloat(i[2]||"0"),frequency:parseFloat(i[3]||"1"),delay:parseFloat(i[4]||"0"),damping:parseFloat(i[5]||"0")};const o=e.match(/^PULSE\(\s*([-\d.]+(?:[eE][-+]?\d+)?)\s+([-\d.]+(?:[eE][-+]?\d+)?)\s*([-\d.]+(?:[eE][-+]?\d+)?)?\s*([-\d.]+(?:[eE][-+]?\d+)?)?\s*([-\d.]+(?:[eE][-+]?\d+)?)?\s*([-\d.]+(?:[eE][-+]?\d+)?)?\s*([-\d.]+(?:[eE][-+]?\d+)?)?\s*\)$/);if(o)return{type:"PULSE",v1:parseFloat(o[1]),v2:parseFloat(o[2]),td:parseFloat(o[3]||"0"),tr:parseFloat(o[4]||"1e-9"),tf:parseFloat(o[5]||"1e-9"),pw:parseFloat(o[6]||"1e-6"),per:parseFloat(o[7]||"2e-6")};throw new Error(`Cannot parse voltage source: ${t}`)}needsCurrentVariable(){return!0}getValue(t=0){const e=this.sourceConfig;switch(e.type){case"DC":return e.dc||0;case"SINE":return this.getSineValue(t,e);case"PULSE":return this.getPulseValue(t,e);case"EXP":return this.getExpValue(t,e);case"PWL":return this.getPWLValue(t,e);default:return console.warn(`Unknown voltage source type: ${e.type}`),0}}getSineValue(t,e){const{offset:s,amplitude:i,frequency:o,delay:n,damping:r}=e;if(t<n)return s;const a=t-n,h=2*Math.PI*o,c=r>0?Math.exp(-r*a):1;return s+i*Math.sin(h*a)*c}getPulseValue(t,e){const{v1:s,v2:i,td:o,tr:n,tf:r,pw:a,per:h}=e;if(t<o)return s;const c=(t-o)%h;if(c<=n)return s+(i-s)*(c/n);if(c<=n+a)return i;if(c<=n+a+r){const u=c-n-a;return i-(i-s)*(u/r)}else return s}getExpValue(t,e){const{v1:s,v2:i,td1:o,tau1:n,td2:r,tau2:a}=e;if(t<o)return s;if(t<r){const h=t-o;return s+(i-s)*(1-Math.exp(-h/n))}else{const h=r-o,c=t-r,u=s+(i-s)*(1-Math.exp(-h/n));return u+(s-u)*(1-Math.exp(-c/a))}}getPWLValue(t,e){const{points:s}=e;if(!s||s.length===0)return 0;for(let i=0;i<s.length-1;i++){const[o,n]=s[i],[r,a]=s[i+1];if(t>=o&&t<=r)return n+(a-n)*(t-o)/(r-o)}return t>=s[s.length-1][0]?s[s.length-1][1]:s[0][1]}getInfo(t=0){return{...super.toJSON(),sourceConfig:this.sourceConfig,currentValue:this.getValue(t),operatingPoint:{...this.operatingPoint}}}toString(){const t=this.sourceConfig;let e;switch(t.type){case"DC":e=`DC(${t.dc}V)`;break;case"SINE":e=`SINE(${t.offset}V, ${t.amplitude}V, ${t.frequency}Hz)`;break;case"PULSE":e=`PULSE(${t.v1}V, ${t.v2}V, ${t.per*1e6}µs)`;break;default:e=`${t.type}`}return`${this.name}: ${this.nodes[0]}(+) ${this.nodes[1]}(-) ${e}`}setValue(t){this.value=t,this.sourceConfig.type==="DC"&&(this.sourceConfig.dc=t,this.sourceConfig.amplitude=t,this.sourceConfig.offset=t)}}class N extends d{constructor(t,e,s,i={}){if(super(t,"I",e,0,i),e.length!==2)throw new Error(`Current source ${t} must have exactly 2 nodes`);this.rawSource=s,this.sourceConfig=this.parseSourceConfig(s),this.value=this.sourceConfig.dc||this.sourceConfig.amplitude||0}parseSourceConfig(t){return new f("temp",["1","0"],t).sourceConfig}getValue(t=0){const e=new f("temp",["1","0"],this.sourceConfig);return e.sourceConfig=this.sourceConfig,e.getValue(t)}needsCurrentVariable(){return!1}getInfo(t=0){return{...super.toJSON(),sourceConfig:this.sourceConfig,currentValue:this.getValue(t),operatingPoint:{...this.operatingPoint}}}toString(){const t=this.sourceConfig;let e;switch(t.type){case"DC":e=`DC(${t.dc}A)`;break;case"SINE":e=`SINE(${t.offset}A, ${t.amplitude}A, ${t.frequency}Hz)`;break;case"PULSE":e=`PULSE(${t.v1}A, ${t.v2}A, ${t.per*1e6}µs)`;break;default:e=`${t.type}`}return`${this.name}: ${this.nodes[0]}→${this.nodes[1]} ${e}`}}class A extends d{constructor(t,e,s,i,o={}){const n=[...e,...s];super(t,"VCVS",n,i,o),this.outputNodes=[...e],this.controlNodes=[...s],this.gain=i}needsCurrentVariable(){return!0}toString(){return`${this.name}: ${this.outputNodes[0]}-${this.outputNodes[1]} = ${this.gain} * (${this.controlNodes[0]}-${this.controlNodes[1]})`}}class P extends d{constructor(t,e,s,i,o={}){const n=[...e,...s];super(t,"VCCS",n,i,o),this.outputNodes=[...e],this.controlNodes=[...s],this.transconductance=i}needsCurrentVariable(){return!1}toString(){return`${this.name}: I(${this.outputNodes[0]}→${this.outputNodes[1]}) = ${this.transconductance} * V(${this.controlNodes[0]}-${this.controlNodes[1]})`}}class b extends d{constructor(t,e,s,i,o={}){if(super(t,"CCCS",e,i,o),e.length!==2)throw new Error(`CCCS ${t} must have exactly 2 output nodes`);this.outputNodes=[...e],this.controlElement=s,this.currentGain=i,this.controlCurrent=0}setControlCurrent(t){this.controlCurrent=t}getOutputCurrent(){return this.currentGain*this.controlCurrent}stamp(t,e,s,i,o){const n=this.getOutputCurrent(),r=this.outputNodes[0]==="0"?-1:s.get(this.outputNodes[0]),a=this.outputNodes[1]==="0"?-1:s.get(this.outputNodes[1]);r>=0&&e.addAt(r,-n),a>=0&&e.addAt(a,n)}needsCurrentVariable(){return!1}toString(){return`${this.name}: I(${this.outputNodes[0]}→${this.outputNodes[1]}) = ${this.currentGain} * I(${this.controlElement})`}clone(){return new b(this.name,[...this.outputNodes],this.controlElement,this.currentGain,{...this.params})}}class I extends d{constructor(t,e,s,i,o={}){if(super(t,"CCVS",e,i,o),e.length!==2)throw new Error(`CCVS ${t} must have exactly 2 output nodes`);this.outputNodes=[...e],this.controlElement=s,this.transresistance=i,this.controlCurrent=0}setControlCurrent(t){this.controlCurrent=t}getOutputVoltage(){return this.transresistance*this.controlCurrent}stamp(t,e,s,i,o){const n=this.getOutputVoltage(),r=this.outputNodes[0]==="0"?-1:s.get(this.outputNodes[0]),a=this.outputNodes[1]==="0"?-1:s.get(this.outputNodes[1]),h=i.get(this.name);if(h===void 0)throw new Error(`CCVS ${this.name}: Current variable not found in voltage source map`);t.rows,r>=0&&(t.addAt(h,r,1),t.addAt(r,h,1)),a>=0&&(t.addAt(h,a,-1),t.addAt(a,h,-1)),e.setAt(h,n)}needsCurrentVariable(){return!0}toString(){return`${this.name}: V(${this.outputNodes[0]}-${this.outputNodes[1]}) = ${this.transresistance} * I(${this.controlElement})`}clone(){return new I(this.name,[...this.outputNodes],this.controlElement,this.transresistance,{...this.params})}}class V extends d{constructor(t,e,s={}){const i=e.length>=3?[e[0],e[1]]:e;if(super(t,"M",i,0,s),e.length<2)throw new Error(`MOSFET ${t} must have at least 2 nodes: [drain, source], optional gate`);this.Ron=this.safeParseValue(s.Ron,.001),this.Roff=this.safeParseValue(s.Roff,1e6),this.Vf_diode=this.safeParseValue(s.Vf_diode,.7),this.Von_diode=this.safeParseValue(s.Von_diode,.001),this.Roff_diode=this.safeParseValue(s.Roff_diode,1e6),this.gateState=!1,this.isExtControlled=!0,this.drain=e[0],this.source=e[1],this.gate=e[2]||null,this.mosfetCurrent=0,this.validate()}safeParseValue(t,e){try{return t==null?e:this.parseValue(t)}catch{return e}}validate(){if(this.Ron<=0)throw new Error(`MOSFET ${this.name}: Ron must be positive`);if(this.Roff<=this.Ron)throw new Error(`MOSFET ${this.name}: Roff must be greater than Ron`);this.mosfetCurrent=0,this.diodeCurrent=0,this.totalCurrent=0,this.drainSourceVoltage=0}setGateState(t){this.gateState=!!t}getGateState(){return this.gateState}getMOSFETResistance(){return this.gateState?this.Ron:this.Roff}getBodyDiodeResistance(t){return t<-this.Vf_diode?this.Von_diode:this.Roff_diode}getEquivalentResistance(t){const e=this.getMOSFETResistance(),s=this.getBodyDiodeResistance(t);return 1/(1/e+1/s)}stamp(t,e,s,i,o){const n=this.drain==="0"||this.drain==="gnd"?-1:s.get(this.drain),r=this.source==="0"||this.source==="gnd"?-1:s.get(this.source);if(n===void 0||r===void 0)throw new Error(`MOSFET ${this.name}: Node mapping not found (drain: ${this.drain}, source: ${this.source})`);let a=0;this.drainSourceVoltage!==void 0&&(a=this.drainSourceVoltage);const c=1/this.getEquivalentResistance(a);n>=0&&(t.addAt(n,n,c),r>=0&&t.addAt(n,r,-c)),r>=0&&(t.addAt(r,r,c),n>=0&&t.addAt(r,n,-c))}updateState(t,e){this.drainSourceVoltage=t,this.totalCurrent=e;const s=this.getMOSFETResistance(),i=this.getBodyDiodeResistance(t),o=this.getEquivalentResistance(t);this.mosfetCurrent=e*(o/s),this.diodeCurrent=e*(o/i)}getCurrent(t){const e=this.getVoltage(t);this.drainSourceVoltage=e;const s=this.getEquivalentResistance(e),i=e/s;return this.totalCurrent=i,this.operatingPoint.current=i,i}needsCurrentVariable(){return!1}toString(){const t=this.gate?` G=${this.gate}`:" (Ext. Control)";return`${this.name} (MOSFET): D=${this.drain} S=${this.source}${t}, State=${this.gateState?"ON":"OFF"}, Ron=${this.Ron}Ω, Roff=${this.Roff}Ω`}getOperatingStatus(){return{name:this.name,type:"MOSFET",gateState:this.gateState?"ON":"OFF",drainSourceVoltage:this.drainSourceVoltage,totalCurrent:this.totalCurrent,mosfetCurrent:this.mosfetCurrent,diodeCurrent:this.diodeCurrent,currentResistance:this.getEquivalentResistance(this.drainSourceVoltage),bodyDiodeActive:this.drainSourceVoltage<-this.Vf_diode}}toJSON(){return{...super.toJSON(),gateState:this.gateState,Ron:this.Ron,Roff:this.Roff,Vf_diode:this.Vf_diode,Von_diode:this.Von_diode,operatingStatus:this.getOperatingStatus()}}clone(){const t=new V(this.name,this.nodes,{Ron:this.Ron,Roff:this.Roff,Vf_diode:this.Vf_diode,Von_diode:this.Von_diode,Roff_diode:this.Roff_diode});return t.setGateState(this.gateState),t}}class F{constructor(){this.components=[],this.models=new Map,this.parameters=new Map,this.analyses=[],this.options=new Map,this.includes=[],this.stats={totalLines:0,parsedLines:0,skippedLines:0,errors:[]}}parse(t){this.reset();const e=t.split(/\r?\n/).map(s=>s.trim());this.stats.totalLines=e.length,console.log(`Parsing netlist with ${e.length} lines...`);try{const s=this.preprocessLines(e);for(let i=0;i<s.length;i++){const o=s[i];if(o.length!==0)try{this.parseLine(o,i+1),this.stats.parsedLines++}catch(n){this.stats.errors.push({line:i+1,content:o,error:n.message})}}return console.log(`Netlist parsing completed: ${this.components.length} components, ${this.stats.errors.length} errors`),{components:this.components,models:this.models,parameters:this.parameters,analyses:this.analyses,options:this.options,stats:this.stats}}catch(s){throw console.error("Netlist parsing failed:",s),s}}reset(){this.components=[],this.models.clear(),this.parameters.clear(),this.analyses=[],this.options.clear(),this.includes=[],this.stats={totalLines:0,parsedLines:0,skippedLines:0,errors:[]}}preprocessLines(t){const e=[];let s="";for(let i of t){if(i.startsWith("*")||i.startsWith(";"))continue;const o=Math.min(i.indexOf("$")>=0?i.indexOf("$"):i.length,i.indexOf(";")>=0?i.indexOf(";"):i.length);i=i.substring(0,o).trim(),i.length!==0&&(i.startsWith("+")?s+=" "+i.substring(1).trim():(s.length>0&&e.push(s),s=i))}return s.length>0&&e.push(s),e}parseLine(t,e=1){const s=t.split(/\s+/);if(s.length===0)return null;const i=s[0][0].toUpperCase();let o=null;try{switch(i){case"R":o=this.parseResistor(s);break;case"C":o=this.parseCapacitor(s);break;case"L":o=this.parseInductor(s);break;case"V":o=this.parseVoltageSource(s);break;case"I":o=this.parseCurrentSource(s);break;case"E":o=this.parseVCVS(s);break;case"G":o=this.parseVCCS(s);break;case"M":o=this.parseMOSFET(s);break;case".":this.parseDirective(s);break;default:console.warn(`Unknown component type: ${s[0]} (line ${e})`),this.stats.skippedLines++}}catch(n){throw new Error(`Line ${e}: ${n.message}`)}return o}parseResistor(t){if(t.length<4)throw new Error("Resistor requires at least 4 tokens: R<name> <node1> <node2> <value>");const e=t[0],s=[t[1],t[2]],i=t[3],o=this.parseParameters(t.slice(4)),n=new R(e,s,i,o);return this.components.push(n),n}parseCapacitor(t){if(t.length<4)throw new Error("Capacitor requires at least 4 tokens: C<name> <node1> <node2> <value>");const e=t[0],s=[t[1],t[2]],i=t[3],o=this.parseParameters(t.slice(4)),n=new E(e,s,i,o);return this.components.push(n),n}parseInductor(t){if(t.length<4)throw new Error("Inductor requires at least 4 tokens: L<name> <node1> <node2> <value>");const e=t[0],s=[t[1],t[2]],i=t[3],o=this.parseParameters(t.slice(4)),n=new v(e,s,i,o);return this.components.push(n),n}parseMOSFET(t){if(t.length<4)throw new Error("MOSFET requires at least 4 tokens: M<name> <drain> <source> <gate>");const e=t[0],s=t[1],i=t[2],o=t[3],n=[s,i,o],r=this.parseParameters(t.slice(4)),a={Ron:r.Ron||r.ron||"1m",Roff:r.Roff||r.roff||"1M",Vf_diode:r.Vf||r.vf||r.Vf_diode||"0.7",Von_diode:r.Von_diode||r.von_diode||"1m",Roff_diode:r.Roff_diode||r.roff_diode||"1M"},h=new V(e,n,a);return this.components.push(h),h}parseVoltageSource(t){if(t.length<4)throw new Error("Voltage source requires at least 4 tokens: V<name> <node+> <node-> <source>");const e=t[0],s=[t[1],t[2]];let i=t.slice(3).join(" ");const o={},n=new f(e,s,i,o);return this.components.push(n),n}parseCurrentSource(t){if(t.length<4)throw new Error("Current source requires at least 4 tokens: I<name> <node+> <node-> <source>");const e=t[0],s=[t[1],t[2]];let i=t.slice(3).join(" ");const o={},n=new N(e,s,i,o);return this.components.push(n),n}parseVCVS(t){if(t.length<6)throw new Error("VCVS requires 6 tokens: E<name> <out+> <out-> <in+> <in-> <gain>");const e=t[0],s=[t[1],t[2]],i=[t[3],t[4]],o=parseFloat(t[5]),n=new A(e,s,i,o);this.components.push(n)}parseVCCS(t){if(t.length<6)throw new Error("VCCS requires 6 tokens: G<name> <out+> <out-> <in+> <in-> <gm>");const e=t[0],s=[t[1],t[2]],i=[t[3],t[4]],o=parseFloat(t[5]),n=new P(e,s,i,o);this.components.push(n)}parseDirective(t){const e=t[0].toLowerCase();switch(e){case".tran":this.parseTranDirective(t);break;case".dc":this.parseDCDirective(t);break;case".param":this.parseParamDirective(t);break;case".model":this.parseModelDirective(t);break;case".options":this.parseOptionsDirective(t);break;case".end":break;case".title":break;default:console.warn(`Unknown directive: ${e}`)}}parseTranDirective(t){if(t.length<3)throw new Error(".TRAN requires at least 2 parameters: .TRAN <tstep> <tstop>");const e={type:"TRAN",tstep:t[1],tstop:t[2],tstart:t[3]||"0",tmax:t[4]||t[1]};this.analyses.push(e)}parseDCDirective(t){const e={type:"DC",parameters:t.slice(1)};this.analyses.push(e)}parseParamDirective(t){for(let e=1;e<t.length;e++){const s=t[e],i=s.indexOf("=");if(i>0){const o=s.substring(0,i),n=s.substring(i+1);this.parameters.set(o,n)}}}parseModelDirective(t){if(t.length<3)throw new Error(".MODEL requires at least 2 parameters: .MODEL <name> <type>");const e=t[1],s=t[2],i=this.parseParameters(t.slice(3));this.models.set(e,{type:s,parameters:i})}parseOptionsDirective(t){for(let e=1;e<t.length;e++){const s=t[e],i=s.indexOf("=");if(i>0){const o=s.substring(0,i),n=s.substring(i+1);this.options.set(o.toLowerCase(),n)}else this.options.set(s.toLowerCase(),!0)}}parseParameters(t){const e={};for(const s of t){const i=s.indexOf("=");if(i>0){const o=s.substring(0,i).toLowerCase(),n=s.substring(i+1),r=n.trim();if(/^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/.test(r)){const a=parseFloat(r);e[o]=isNaN(a)?n:a}else e[o]=n}}return e}getStats(){return{...this.stats,componentCount:this.components.length,modelCount:this.models.size,parameterCount:this.parameters.size,analysisCount:this.analyses.length}}parseValue(t){if(typeof t=="number")return t;if(typeof t!="string")return null;const e=t.toString().trim().toLowerCase(),s=parseFloat(e);if(isNaN(s))return null;switch(e.slice(s.toString().length)){case"p":case"pico":return s*1e-12;case"n":case"nano":return s*1e-9;case"u":case"μ":case"micro":return s*1e-6;case"m":case"milli":return s*.001;case"k":case"kilo":return s*1e3;case"meg":case"mega":return s*1e6;case"g":case"giga":return s*1e9;case"t":case"tera":return s*1e12;case"":return s;default:return s}}printReport(){console.log("\\n=== Netlist Parsing Report ==="),console.log(`Total lines: ${this.stats.totalLines}`),console.log(`Parsed lines: ${this.stats.parsedLines}`),console.log(`Skipped lines: ${this.stats.skippedLines}`),console.log(`Errors: ${this.stats.errors.length}`),console.log(`\\nComponents: ${this.components.length}`);const t={};for(const e of this.components)t[e.type]=(t[e.type]||0)+1;for(const[e,s]of Object.entries(t))console.log(`  ${e}: ${s}`);if(this.analyses.length>0){console.log(`\\nAnalyses: ${this.analyses.length}`);for(const e of this.analyses)console.log(`  ${e.type}`)}if(this.stats.errors.length>0){console.log("\\nErrors:");for(const e of this.stats.errors)console.log(`  Line ${e.line}: ${e.error}`),console.log(`    "${e.content}"`)}console.log("==============================\\n")}}class m{constructor(t,e,s=null){this.rows=t,this.cols=e,s?this.data=s:this.data=Array(t).fill().map(()=>Array(e).fill(0))}get(t,e){if(t<0||t>=this.rows||e<0||e>=this.cols)throw new Error(`Matrix index out of bounds: (${t}, ${e})`);return this.data[t][e]}set(t,e,s){if(t<0||t>=this.rows||e<0||e>=this.cols)throw new Error(`Matrix index out of bounds: (${t}, ${e})`);this.data[t][e]=s}addAt(t,e,s){this.data[t][e]+=s}static identity(t){const e=new m(t,t);for(let s=0;s<t;s++)e.set(s,s,1);return e}static zeros(t,e=t){return new m(t,e)}clone(){const t=this.data.map(e=>[...e]);return new m(this.rows,this.cols,t)}isSquare(){return this.rows===this.cols}print(t=6){console.log("Matrix:");for(let e=0;e<this.rows;e++){const s=this.data[e].map(i=>i.toFixed(t)).join("  ");console.log(`[${s}]`)}}}class S{constructor(t,e=null){this.size=t,this.data=e?[...e]:Array(t).fill(0)}get(t){if(t<0||t>=this.size)throw new Error(`Vector index out of bounds: ${t}`);return this.data[t]}set(t,e){if(t<0||t>=this.size)throw new Error(`Vector index out of bounds: ${t}`);this.data[t]=e}addAt(t,e){this.data[t]+=e}static zeros(t){return new S(t)}clone(){return new S(this.size,this.data)}print(t=6){const e=this.data.map(s=>s.toFixed(t)).join(", ");console.log(`Vector: [${e}]`)}}class C{static solve(t,e){if(!t.isSquare())throw new Error("Matrix A must be square");if(t.rows!==e.size)throw new Error("Matrix A and vector b dimensions do not match");t.rows;const s=e.clone(),i=this.luDecomposition(t);return this.applyPermutation(s,i),this.forwardSubstitution(t,s),this.backwardSubstitution(t,s),s}static luDecomposition(t){const e=t.rows,s=Array.from({length:e},(i,o)=>o);for(let i=0;i<e-1;i++){let o=i,n=Math.abs(t.get(i,i));for(let a=i+1;a<e;a++){const h=Math.abs(t.get(a,i));h>n&&(n=h,o=a)}if(n<1e-14)throw new Error(`Matrix is singular or nearly singular at column ${i}`);o!==i&&(this.swapRows(t,i,o),[s[i],s[o]]=[s[o],s[i]]);const r=t.get(i,i);for(let a=i+1;a<e;a++){const h=t.get(a,i)/r;t.set(a,i,h);for(let c=i+1;c<e;c++){const u=t.get(a,c)-h*t.get(i,c);t.set(a,c,u)}}}if(Math.abs(t.get(e-1,e-1))<1e-14)throw new Error("Matrix is singular or nearly singular");return s}static swapRows(t,e,s){if(e!==s)for(let i=0;i<t.cols;i++){const o=t.get(e,i);t.set(e,i,t.get(s,i)),t.set(s,i,o)}}static applyPermutation(t,e){const s=Array(t.size);for(let i=0;i<t.size;i++)s[i]=t.get(e[i]);for(let i=0;i<t.size;i++)t.set(i,s[i])}static forwardSubstitution(t,e){const s=e.size;for(let i=0;i<s;i++){let o=0;for(let n=0;n<i;n++)o+=t.get(i,n)*e.get(n);e.set(i,e.get(i)-o)}}static backwardSubstitution(t,e){const s=e.size;for(let i=s-1;i>=0;i--){let o=0;for(let n=i+1;n<s;n++)o+=t.get(i,n)*e.get(n);e.set(i,(e.get(i)-o)/t.get(i,i))}}static estimateConditionNumber(t){let e=0,s=1/0;for(let i=0;i<t.rows;i++){const o=Math.abs(t.get(i,i));e=Math.max(e,o),s=Math.min(s,o)}return s>1e-14?e/s:1/0}}class O{constructor(){this.nodeMap=new Map,this.nodeCount=0,this.voltageSourceMap=new Map,this.voltageSourceCount=0,this.matrixSize=0,this.matrix=null,this.rhs=null,this.debugInfo={nodeNames:[],voltageSourceNames:[],matrixLabels:[]}}reset(){this.nodeMap.clear(),this.nodeCount=0,this.voltageSourceMap.clear(),this.voltageSourceCount=0,this.matrixSize=0,this.matrix=null,this.rhs=null,this.debugInfo={nodeNames:[],voltageSourceNames:[],matrixLabels:[]}}analyzeCircuit(t){this.reset();const e=new Set,s=new Set;for(const n of t){if(n.nodes)for(const r of n.nodes)r!=="0"&&r!=="gnd"&&e.add(r);(n.type==="V"||n.needsCurrentVariable())&&s.add(n.name)}let i=0;for(const n of Array.from(e).sort())this.nodeMap.set(n,i),this.debugInfo.nodeNames.push(n),i++;this.nodeCount=i;let o=0;for(const n of Array.from(s).sort())this.voltageSourceMap.set(n,this.nodeCount+o),this.debugInfo.voltageSourceNames.push(n),o++;this.voltageSourceCount=o,this.matrixSize=this.nodeCount+this.voltageSourceCount,this.debugInfo.matrixLabels=[...this.debugInfo.nodeNames.map(n=>`V(${n})`),...this.debugInfo.voltageSourceNames.map(n=>`I(${n})`)],console.log(`MNA Analysis: ${this.nodeCount} nodes, ${this.voltageSourceCount} voltage sources, matrix size: ${this.matrixSize}x${this.matrixSize}`)}buildMNAMatrix(t,e=0){if(this.matrixSize===0)throw new Error("Circuit not analyzed. Call analyzeCircuit() first.");this.matrix=m.zeros(this.matrixSize,this.matrixSize),this.rhs=S.zeros(this.matrixSize);for(const s of t)try{this.stampComponent(s,e)}catch(i){throw new Error(`Failed to stamp component ${s.name}: ${i.message}`)}return{matrix:this.matrix,rhs:this.rhs}}stampComponent(t,e){switch(t.type){case"R":this.stampResistor(t);break;case"C":this.stampCapacitor(t);break;case"L":this.stampInductor(t);break;case"V":this.stampVoltageSource(t,e);break;case"I":this.stampCurrentSource(t,e);break;case"VCVS":this.stampVCVS(t);break;case"VCCS":this.stampVCCS(t);break;default:typeof t.stamp=="function"?t.stamp(this.matrix,this.rhs,this.nodeMap,this.voltageSourceMap,e):console.warn(`Unknown component type: ${t.type} (${t.name})`)}}stampResistor(t){const e=t.nodes,s=1/t.value,i=this.getNodeIndex(e[0]),o=this.getNodeIndex(e[1]);i>=0&&(this.matrix.addAt(i,i,s),o>=0&&this.matrix.addAt(i,o,-s)),o>=0&&(this.matrix.addAt(o,o,s),i>=0&&this.matrix.addAt(o,i,-s))}stampCapacitor(t){if(!t.timeStep)return;const e=t.nodes,s=t.value,i=t.timeStep,o=s/i,n=this.getNodeIndex(e[0]),r=this.getNodeIndex(e[1]);n>=0&&(this.matrix.addAt(n,n,o),r>=0&&this.matrix.addAt(n,r,-o)),r>=0&&(this.matrix.addAt(r,r,o),n>=0&&this.matrix.addAt(r,n,-o)),t.historyTerm!==void 0&&(n>=0&&this.rhs.addAt(n,-t.historyTerm),r>=0&&this.rhs.addAt(r,t.historyTerm))}stampInductor(t){const e=t.nodes,s=t.getInductance(),i=this.getNodeIndex(e[0]),o=this.getNodeIndex(e[1]),n=this.voltageSourceMap.get(t.name);if(n===void 0)throw new Error(`Inductor ${t.name} current variable not found`);if(i>=0&&(this.matrix.addAt(i,n,1),this.matrix.addAt(n,i,1)),o>=0&&(this.matrix.addAt(o,n,-1),this.matrix.addAt(n,o,-1)),t.timeStep){const r=t.timeStep;if(this.matrix.addAt(n,n,-s/r),t.historyTerm!==void 0&&this.rhs.addAt(n,-s/r*t.historyTerm),t.couplings)for(const a of t.couplings){const h=a.inductor,c=a.mutualInductance,u=this.voltageSourceMap.get(h.name);if(u===void 0)throw new Error(`Coupled inductor ${h.name} not found for ${t.name}`);this.matrix.addAt(n,u,-c/r),h.historyTerm!==void 0&&this.rhs.addAt(n,-c/r*h.historyTerm)}}else{const r=t.resistance||1e-9;this.matrix.addAt(n,n,-r)}}stampVoltageSource(t,e){const s=t.nodes,i=this.getNodeIndex(s[0]),o=this.getNodeIndex(s[1]),n=this.voltageSourceMap.get(t.name);if(n===void 0)throw new Error(`Voltage source ${t.name} current variable not found`);i>=0&&(this.matrix.addAt(i,n,1),this.matrix.addAt(n,i,1)),o>=0&&(this.matrix.addAt(o,n,-1),this.matrix.addAt(n,o,-1));const r=t.getValue(e);this.rhs.addAt(n,r)}stampCurrentSource(t,e){const s=t.nodes,i=this.getNodeIndex(s[0]),o=this.getNodeIndex(s[1]),n=t.getValue(e);i>=0&&this.rhs.addAt(i,-n),o>=0&&this.rhs.addAt(o,n)}stampVCVS(t){const e=[t.nodes[0],t.nodes[1]],s=[t.nodes[2],t.nodes[3]],i=t.value,o=this.getNodeIndex(e[0]),n=this.getNodeIndex(e[1]),r=this.getNodeIndex(s[0]),a=this.getNodeIndex(s[1]),h=this.voltageSourceMap.get(t.name);o>=0&&(this.matrix.addAt(o,h,1),this.matrix.addAt(h,o,1)),n>=0&&(this.matrix.addAt(n,h,-1),this.matrix.addAt(h,n,-1)),r>=0&&this.matrix.addAt(h,r,-i),a>=0&&this.matrix.addAt(h,a,i)}stampVCCS(t){const e=[t.nodes[0],t.nodes[1]],s=[t.nodes[2],t.nodes[3]],i=t.value,o=this.getNodeIndex(e[0]),n=this.getNodeIndex(e[1]),r=this.getNodeIndex(s[0]),a=this.getNodeIndex(s[1]);o>=0&&r>=0&&this.matrix.addAt(o,r,i),o>=0&&a>=0&&this.matrix.addAt(o,a,-i),n>=0&&r>=0&&this.matrix.addAt(n,r,-i),n>=0&&a>=0&&this.matrix.addAt(n,a,i)}getNodeIndex(t){if(t==="0"||t==="gnd")return-1;const e=this.nodeMap.get(t);if(e===void 0)throw new Error(`Node ${t} not found in circuit`);return e}extractNodeVoltages(t){const e=new Map;e.set("0",0),e.set("gnd",0);for(const[s,i]of this.nodeMap)e.set(s,t.get(i));return e}extractVoltageSourceCurrents(t){const e=new Map;for(const[s,i]of this.voltageSourceMap)e.set(s,t.get(i));return e}printMNAMatrix(t=4){console.log(`
=== MNA Matrix ===`);const e="     "+this.debugInfo.matrixLabels.map(s=>s.padStart(12)).join("");console.log(e+"     RHS");for(let s=0;s<this.matrixSize;s++){let o=this.debugInfo.matrixLabels[s].padStart(4)+" ";for(let n=0;n<this.matrixSize;n++){const r=this.matrix.get(s,n);o+=r.toFixed(t).padStart(12)}o+=" | "+this.rhs.get(s).toFixed(t).padStart(10),console.log(o)}console.log(`==================
`)}getMatrixInfo(){return{nodeCount:this.nodeCount,voltageSourceCount:this.voltageSourceCount,matrixSize:this.matrixSize,nodeNames:[...this.debugInfo.nodeNames],voltageSourceNames:[...this.debugInfo.voltageSourceNames],matrixLabels:[...this.debugInfo.matrixLabels]}}}class L{constructor(){this.timeVector=[],this.nodeVoltages=new Map,this.branchCurrents=new Map,this.componentData=new Map,this.analysisInfo={}}addTimePoint(t,e,s){this.timeVector.push(t);for(const[i,o]of e)this.nodeVoltages.has(i)||this.nodeVoltages.set(i,[]),this.nodeVoltages.get(i).push(o);for(const[i,o]of s)this.branchCurrents.has(i)||this.branchCurrents.set(i,[]),this.branchCurrents.get(i).push(o)}getTimeVector(){return[...this.timeVector]}getVoltageVector(t){let e=t;const s=t.match(/^V\((.+)\)$/);return s&&(e=s[1]),this.nodeVoltages.get(e)||[]}getCurrentVector(t){let e=t;const s=t.match(/^I\((.+)\)$/);return s&&(e=s[1]),this.branchCurrents.get(e)||[]}getVector(t){if(t.toLowerCase()==="time")return this.getTimeVector();const e=this.getVoltageVector(t);if(e.length>0)return e;const s=this.getCurrentVector(t);return s.length>0?s:(console.warn(`Vector ${t} not found`),[])}getAvailableVectors(){const t=["time"];for(const e of this.nodeVoltages.keys())t.push(`V(${e})`);for(const e of this.branchCurrents.keys())t.push(`I(${e})`);return t}getAnalysisInfo(){const t={...this.analysisInfo,totalTimePoints:this.timeVector.length,startTime:this.timeVector[0]||0,stopTime:this.timeVector[this.timeVector.length-1]||0,availableVectors:this.getAvailableVectors()};if(this.timeVector.length>1){const e=[];for(let s=1;s<this.timeVector.length;s++)e.push(this.timeVector[s]-this.timeVector[s-1]);t.averageTimeStep=e.reduce((s,i)=>s+i,0)/e.length,t.minTimeStep=Math.min(...e),t.maxTimeStep=Math.max(...e)}return t}}class D{constructor(){this.mnaBuilder=new O,this.components=[],this.result=null,this.timeStep=1e-6,this.startTime=0,this.stopTime=.001,this.maxTimeStep=1e-6,this.minTimeStep=1e-12,this.maxIterations=50,this.convergenceTol=1e-9,this.debug=!1,this.saveHistory=!0,this.progressCallback=null}setParameters(t){t.timeStep!==void 0&&(this.timeStep=t.timeStep),t.startTime!==void 0&&(this.startTime=t.startTime),t.stopTime!==void 0&&(this.stopTime=t.stopTime),t.maxTimeStep!==void 0&&(this.maxTimeStep=t.maxTimeStep),t.minTimeStep!==void 0&&(this.minTimeStep=t.minTimeStep),t.maxIterations!==void 0&&(this.maxIterations=t.maxIterations),t.convergenceTol!==void 0&&(this.convergenceTol=t.convergenceTol),t.debug!==void 0&&(this.debug=t.debug),t.progressCallback!==void 0&&(this.progressCallback=t.progressCallback)}async run(t,e={}){this.setParameters(e),this.components=[...t],this.result=new L,console.log(`Starting transient analysis: ${this.startTime}s to ${this.stopTime}s, step=${this.timeStep}s`);try{return await this.initialize(),await this.timeLoop(),this.finalize(),console.log(`Transient analysis completed: ${this.result.timeVector.length} time points`),this.result}catch(s){throw console.error("Transient analysis failed:",s),s}}async initialize(t=null,e=null){t&&(this.components=[...t]),e!==null&&(this.timeStep=e),this.mnaBuilder.analyzeCircuit(this.components);for(const s of this.components)s.initTransient(this.timeStep);await this.setInitialConditions(),this.result.analysisInfo={timeStep:this.timeStep,startTime:this.startTime,stopTime:this.stopTime,method:"Backward Euler",matrixSize:this.mnaBuilder.matrixSize,nodeCount:this.mnaBuilder.nodeCount,voltageSourceCount:this.mnaBuilder.voltageSourceCount}}async setInitialConditions(){this.debug&&console.log("Setting initial conditions...");const{matrix:t,rhs:e}=this.mnaBuilder.buildMNAMatrix(this.components,0);this.debug&&this.mnaBuilder.printMNAMatrix();const s=C.solve(t,e),i=this.mnaBuilder.extractNodeVoltages(s),o=this.mnaBuilder.extractVoltageSourceCurrents(s);for(const n of this.components)n.updateHistory(i,o);this.result.addTimePoint(this.startTime,i,o),this.debug&&(console.log("Initial conditions set"),this.printSolutionSummary(i,o))}async timeLoop(){let t=this.startTime+this.timeStep,e=0;const s=Math.ceil((this.stopTime-this.startTime)/this.timeStep);for(;t<=this.stopTime;){e++;try{if(await this.singleTimeStep(t),this.progressCallback){const i=e/s;this.progressCallback(i,t,e)}this.debug&&e%100===0&&console.log(`Step ${e}/${s}, time=${(t*1e6).toFixed(2)}µs`),t+=this.timeStep}catch(i){throw console.error(`Time step failed at t=${t}s:`,i),i}}}async singleTimeStep(t){for(const r of this.components)typeof r.updateCompanionModel=="function"&&r.updateCompanionModel();const{matrix:e,rhs:s}=this.mnaBuilder.buildMNAMatrix(this.components,t),i=C.solve(e,s),o=this.mnaBuilder.extractNodeVoltages(i),n=this.mnaBuilder.extractVoltageSourceCurrents(i);for(const r of this.components)r.updateHistory(o,n);this.result.addTimePoint(t,o,n)}finalize(){const t=this.result.getAnalysisInfo();console.log(`Analysis summary: ${t.totalTimePoints} points, avg step=${(t.averageTimeStep*1e6).toFixed(2)}µs`),this.mnaBuilder.reset()}printSolutionSummary(t,e){console.log("\\nSolution Summary:"),console.log("Node Voltages:");for(const[s,i]of t)console.log(`  V(${s}) = ${i.toFixed(6)}V`);console.log("Branch Currents:");for(const[s,i]of e)console.log(`  I(${s}) = ${(i*1e3).toFixed(3)}mA`);console.log("")}setDebug(t){this.debug=t}getStatus(){return{isRunning:this.result!==null,currentTime:this.result?this.result.timeVector[this.result.timeVector.length-1]:0,progress:this.result?this.result.timeVector.length/Math.ceil((this.stopTime-this.startTime)/this.timeStep):0,timePoints:this.result?this.result.timeVector.length:0}}solveTimeStep(t,e=this.maxIterations){try{const{matrix:s,rhs:i}=this.mnaBuilder.buildMNAMatrix(this.components,t),o=C.solve(s,i),n=this.mnaBuilder.extractNodeVoltages(o),r=this.mnaBuilder.extractVoltageSourceCurrents(o),a=!0;for(const h of this.components)h.updateHistory(n,r);return{converged:a,nodeVoltages:n,branchCurrents:r,time:t}}catch(s){throw new Error(`Time step solution failed at t=${t}s: ${s.message}`)}}}class _{static parseTranCommand(t){const s=t.trim().toLowerCase().match(/^\.tran\s+([0-9.]+[a-z]*)\s+([0-9.]+[a-z]*)(?:\s+([0-9.]+[a-z]*))?(?:\s+([0-9.]+[a-z]*))?/);if(!s)throw new Error(`Invalid .tran command: ${t}`);return{timeStep:this.parseTimeValue(s[1]),stopTime:this.parseTimeValue(s[2]),startTime:s[3]?this.parseTimeValue(s[3]):0,maxTimeStep:s[4]?this.parseTimeValue(s[4]):void 0}}static parseTimeValue(t){const e=t.trim().toLowerCase(),s={fs:1e-15,ps:1e-12,ns:1e-9,us:1e-6,µs:1e-6,ms:.001,s:1};for(const[o,n]of Object.entries(s))if(e.endsWith(o)){const r=parseFloat(e.slice(0,-o.length));if(!isNaN(r))return r*n}const i=parseFloat(e);if(!isNaN(i))return i;throw new Error(`Cannot parse time value: ${t}`)}static formatTime(t){const e=Math.abs(t);return e>=1?`${t.toFixed(3)}s`:e>=.001?`${(t*1e3).toFixed(3)}ms`:e>=1e-6?`${(t*1e6).toFixed(3)}µs`:e>=1e-9?`${(t*1e9).toFixed(3)}ns`:`${(t*1e12).toFixed(3)}ps`}}class k{constructor(){this.nodeVoltages=new Map,this.branchCurrents=new Map,this.componentPower=new Map,this.totalPower=0,this.analysisInfo={},this.converged=!1}getNodeVoltage(t){return this.nodeVoltages.get(t)||0}getBranchCurrent(t){return this.branchCurrents.get(t)||0}calculatePower(t){this.totalPower=0;for(const e of t){let s=0;if(e.type==="R"){const i=e.getVoltage(this.nodeVoltages);s=i*i/e.getResistance()}else if(e.type==="V"){const i=e.getValue(),o=this.getBranchCurrent(e.name);s=-i*o}else if(e.type==="I"){const i=e.getVoltage(this.nodeVoltages),o=e.getValue();s=-i*o}this.componentPower.set(e.name,s),this.totalPower+=Math.abs(s)}}getSummary(){const t=this.nodeVoltages.size,e=this.branchCurrents.size;return{...this.analysisInfo,converged:this.converged,nodeCount:t,branchCount:e,totalPower:this.totalPower,nodes:Array.from(this.nodeVoltages.keys()),branches:Array.from(this.branchCurrents.keys())}}}class q{constructor(){this.mnaBuilder=new O,this.debug=!1}async run(t,e={}){this.debug=e.debug||!1;const s=new k;try{this.debug&&console.log("Starting DC analysis..."),this.mnaBuilder.analyzeCircuit(t);const i=20,o=1e-9;let n=0,r=!1,a;for(;n<i&&!r;){n++;const{matrix:h,rhs:c}=this.mnaBuilder.buildMNAMatrix(t,0);this.debug&&n===1&&(console.log("MNA Matrix built"),this.mnaBuilder.printMNAMatrix());const u=C.solve(h,c);if(n>1){let g=0;for(let w=0;w<u.size;w++){const j=Math.abs(u.get(w)-a.get(w));g=Math.max(g,j)}g<o&&(r=!0,this.debug&&console.log(`DC analysis converged after ${n} iterations (max change: ${g.toExponential(2)})`))}a=u;const y=this.mnaBuilder.extractNodeVoltages(a),H=this.mnaBuilder.extractVoltageSourceCurrents(a);for(const g of t)typeof g.updateHistory=="function"&&g.updateHistory(y,H)}return r||console.warn(`DC analysis did not converge after ${i} iterations`),s.nodeVoltages=this.mnaBuilder.extractNodeVoltages(a),s.branchCurrents=this.mnaBuilder.extractVoltageSourceCurrents(a),s.converged=r,s.calculatePower(t),s.analysisInfo={method:"Modified Nodal Analysis",matrixSize:this.mnaBuilder.matrixSize,nodeCount:this.mnaBuilder.nodeCount,voltageSourceCount:this.mnaBuilder.voltageSourceCount,iterations:n,convergence:r?"converged":"max iterations reached"},this.debug&&this.printResults(s),s}catch(i){return console.error("DC analysis failed:",i),s.converged=!1,s.analysisInfo.error=i.message,s}}estimateCondition(t){try{return C.estimateConditionNumber(t)}catch{return 1/0}}printResults(t){console.log("\\n=== DC Analysis Results ==="),console.log("\\nNode Voltages:");for(const[o,n]of t.nodeVoltages)Math.abs(n)<1e-12?console.log(`  V(${o}) = 0V`):Math.abs(n)>=1e3?console.log(`  V(${o}) = ${(n/1e3).toFixed(3)}kV`):Math.abs(n)>=1?console.log(`  V(${o}) = ${n.toFixed(6)}V`):Math.abs(n)>=.001?console.log(`  V(${o}) = ${(n*1e3).toFixed(3)}mV`):Math.abs(n)>=1e-6?console.log(`  V(${o}) = ${(n*1e6).toFixed(3)}µV`):console.log(`  V(${o}) = ${n.toExponential(3)}V`);console.log("\\nBranch Currents:");for(const[o,n]of t.branchCurrents)Math.abs(n)<1e-12?console.log(`  I(${o}) = 0A`):Math.abs(n)>=1?console.log(`  I(${o}) = ${n.toFixed(6)}A`):Math.abs(n)>=.001?console.log(`  I(${o}) = ${(n*1e3).toFixed(3)}mA`):Math.abs(n)>=1e-6?console.log(`  I(${o}) = ${(n*1e6).toFixed(3)}µA`):Math.abs(n)>=1e-9?console.log(`  I(${o}) = ${(n*1e9).toFixed(3)}nA`):console.log(`  I(${o}) = ${n.toExponential(3)}A`);console.log("\\nComponent Power:");let e=0,s=0;for(const[o,n]of t.componentPower)n<0?(e+=Math.abs(n),console.log(`  P(${o}) = ${Math.abs(n).toFixed(6)}W (supplied)`)):n>1e-12&&(s+=n,console.log(`  P(${o}) = ${n.toFixed(6)}W (dissipated)`));console.log("\\nPower Balance:"),console.log(`  Total Supplied: ${e.toFixed(6)}W`),console.log(`  Total Dissipated: ${s.toFixed(6)}W`),console.log(`  Balance Error: ${Math.abs(e-s).toFixed(9)}W`);const i=t.getSummary();console.log(`\\nMatrix Info: ${i.matrixSize}×${i.matrixSize}, iterations: ${i.iterations}`),console.log("===========================\\n")}setDebug(t){this.debug=t}}class B{constructor(t=null){this.parser=new F,this.transientAnalysis=new D,this.dcAnalysis=new q,this._components=[],this.models=new Map,this.parameters=new Map,this.analyses=[],this.options=new Map,this.results=new Map,this.lastResult=null,this.isInitialized=!1,this.debug=!1,t&&this.loadNetlist(t)}set components(t){this._components=[],this.addComponents(t)}get components(){return this._components||[]}addComponent(t){this._components||(this._components=[]),t.type==="T_META"&&typeof t.getComponents=="function"?this._components.push(...t.getComponents()):this._components.push(t)}addComponents(t){for(const e of t)this.addComponent(e)}loadNetlist(t){console.log("Loading netlist...");try{const e=this.parser.parse(t);return this.components=e.components,this.models=e.models,this.parameters=e.parameters,this.analyses=e.analyses,this.options=e.options,this.isInitialized=!0,this.debug&&this.parser.printReport(),console.log(`Netlist loaded: ${this.components.length} components`),e.stats}catch(e){throw console.error("Failed to load netlist:",e),e}}async runAnalysis(t=null){if(!this.isInitialized)throw new Error("No netlist loaded. Call loadNetlist() first.");if(t){const e=t.trim().toLowerCase();if(e.startsWith(".tran"))return await this.runTransientAnalysis(t);if(e.startsWith(".dc")||e.startsWith(".op"))return await this.runDCAnalysis();throw new Error(`Unsupported analysis command: ${t}`)}if(this.analyses.length>0){const e=this.analyses[0];if(e.type==="TRAN"){const s=`.tran ${e.tstep} ${e.tstop} ${e.tstart||"0"} ${e.tmax||e.tstep}`;return await this.runTransientAnalysis(s)}else if(e.type==="DC")return await this.runDCAnalysis()}return console.log("No analysis specified, running DC analysis"),await this.runDCAnalysis()}async runTransientAnalysis(t){console.log(`Running transient analysis: ${t}`);try{const e=_.parseTranCommand(t);e.debug=this.debug;const s=await this.transientAnalysis.run(this.components,e);return this.results.set("tran",s),this.lastResult=s,console.log(`Transient analysis completed: ${s.timeVector.length} time points`),s}catch(e){throw console.error("Transient analysis failed:",e),e}}async runDCAnalysis(){console.log("Running DC analysis...");try{const t={debug:this.debug},e=await this.dcAnalysis.run(this.components,t);return this.results.set("dc",e),this.lastResult=e,console.log("DC analysis completed"),e}catch(t){throw console.error("DC analysis failed:",t),t}}getResult(t=null){return t?this.results.get(t):this.lastResult}getCircuitInfo(){return{componentCount:this.components.length,components:this.components.map(t=>({name:t.name,type:t.type,nodes:t.nodes,value:t.value})),nodeList:this.getNodeList(),modelCount:this.models.size,parameterCount:this.parameters.size,analysisCount:this.analyses.length,isInitialized:this.isInitialized}}getNodeList(){const t=new Set;for(const e of this.components)if(e.nodes)for(const s of e.nodes)t.add(s);return Array.from(t).sort()}setDebug(t){this.debug=t,this.transientAnalysis.setDebug(t),this.dcAnalysis.setDebug(t)}validateCircuit(){const t=[],e=[];if(this.components.length===0)return t.push("No components found in circuit"),{valid:!1,issues:t,warnings:e};for(const n of this.components){n.isValid()||t.push(`Invalid component: ${n.name}`);for(const r of n.nodes)(!r||typeof r!="string")&&t.push(`Invalid node in component ${n.name}: ${r}`);n.value===0&&(n.type==="R"||n.type==="L"||n.type==="C")&&e.push(`Zero value in ${n.name} may cause numerical issues`)}const s=this.getNodeList();s.includes("0")||s.includes("gnd")||s.includes("GND")||e.push("No ground node (0 or gnd) found - circuit may be floating");const o=new Map;for(const n of this.components)for(const r of n.nodes)o.set(r,(o.get(r)||0)+1);for(const[n,r]of o)r===1&&n!=="0"&&n!=="gnd"&&e.push(`Node ${n} has only one connection`);return{valid:t.length===0,issues:t,warnings:e,componentCount:this.components.length,nodeCount:s.length}}printCircuitSummary(){console.log("\\n=== Circuit Summary ===");const t=this.getCircuitInfo();console.log(`Components: ${t.componentCount}`),console.log(`Nodes: ${t.nodeList.length}`),console.log(`Models: ${t.modelCount}`),console.log(`Parameters: ${t.parameterCount}`);const e={};for(const i of this.components)e[i.type]=(e[i.type]||0)+1;console.log("\\nComponent breakdown:");for(const[i,o]of Object.entries(e))console.log(`  ${i}: ${o}`);console.log("\\nNodes:",t.nodeList.join(", "));const s=this.validateCircuit();console.log(`\\nValidation: ${s.valid?"PASSED":"FAILED"}`),s.issues.length>0&&(console.log("Issues:"),s.issues.forEach(i=>console.log(`  - ${i}`))),s.warnings.length>0&&(console.log("Warnings:"),s.warnings.forEach(i=>console.log(`  - ${i}`))),console.log("=======================\\n")}reset(){this.components=[],this.models.clear(),this.parameters.clear(),this.analyses=[],this.options.clear(),this.results.clear(),this.lastResult=null,this.isInitialized=!1,this.parser.reset()}async initSteppedTransient(t={}){try{if(!this.isInitialized)throw new Error("Circuit not initialized. Load a netlist first.");return this.steppedParams={startTime:t.startTime||0,stopTime:t.stopTime||.001,timeStep:t.timeStep||1e-6,maxIterations:t.maxIterations||10},this.transientAnalysis.setParameters({timeStep:this.steppedParams.timeStep,startTime:this.steppedParams.startTime,stopTime:this.steppedParams.stopTime,maxIterations:this.steppedParams.maxIterations}),this.transientAnalysis.result=new L,await this.transientAnalysis.initialize(this.components,this.steppedParams.timeStep),this.currentTime=this.steppedParams.startTime,this.currentIteration=0,this.isSteppedMode=!0,this.steppedResults={time:[],voltages:[],currents:[],componentStates:[]},console.log("步進式暫態分析初始化完成:"),console.log(`  時間範圍: ${this.steppedParams.startTime}s 到 ${this.steppedParams.stopTime}s`),console.log(`  時間步長: ${this.steppedParams.timeStep}s`),console.log(`  最大迭代數: ${this.steppedParams.maxIterations}`),!0}catch(e){return console.error(`步進式暫態分析初始化失敗: ${e.message}`),!1}}step(t={}){if(!this.isSteppedMode)throw new Error("Step mode not initialized. Call initSteppedTransient() first.");if(this.isFinished())return console.warn("Simulation already finished"),null;try{this.updateControlInputs(t);const e=this.transientAnalysis.solveTimeStep(this.currentTime,this.steppedParams.maxIterations),s=Object.fromEntries(e.nodeVoltages),i=Object.fromEntries(e.branchCurrents);this.steppedResults.time.push(this.currentTime),this.steppedResults.voltages.push({...s}),this.steppedResults.currents.push({...i});const o={};for(const n of this.components)n.getOperatingStatus&&(o[n.name]=n.getOperatingStatus());return this.steppedResults.componentStates.push(o),this.currentTime+=this.steppedParams.timeStep,this.currentIteration++,{time:this.currentTime-this.steppedParams.timeStep,iteration:this.currentIteration-1,nodeVoltages:Object.fromEntries(e.nodeVoltages),branchCurrents:Object.fromEntries(e.branchCurrents),componentStates:o,converged:e.converged}}catch(e){throw console.error(`Time step ${this.currentIteration} failed: ${e.message}`),e}}isFinished(){return this.isSteppedMode&&this.currentTime>=this.steppedParams.stopTime}getCurrentTime(){return this.currentTime||0}updateControlInputs(t){for(const[e,s]of Object.entries(t)){const i=this.components.find(o=>o.name===e);i&&i.setGateState?(i.setGateState(s),this.debug&&console.log(`Updated ${e} gate state: ${s?"ON":"OFF"}`)):i&&i.setValue&&i.setValue(s)}}setGateState(t,e){this.updateControlInputs({[t]:e})}getVoltage(t){return!this.isSteppedMode||this.steppedResults.voltages.length===0?0:this.steppedResults.voltages[this.steppedResults.voltages.length-1][t]||0}getCurrent(t){return!this.isSteppedMode||this.steppedResults.currents.length===0?0:this.steppedResults.currents[this.steppedResults.currents.length-1][t]||0}getComponentState(t){return!this.isSteppedMode||this.steppedResults.componentStates.length===0?null:this.steppedResults.componentStates[this.steppedResults.componentStates.length-1][t]||null}getSteppedResults(){return this.isSteppedMode?this.steppedResults:null}async runSteppedSimulation(t,e={}){if(console.log("開始步進式模擬..."),!await this.initSteppedTransient(e))throw new Error("Failed to initialize stepped simulation");const s=[];let i=0;for(;!this.isFinished();){const o=t?t(this.currentTime):{},n=this.step(o);if(n&&(s.push(n),i++,i%1e3===0)){const r=(this.currentTime-this.steppedParams.startTime)/(this.steppedParams.stopTime-this.steppedParams.startTime)*100;console.log(`模擬進度: ${r.toFixed(1)}% (${i} steps)`)}}return console.log(`步進式模擬完成: ${i} 個時間步`),{steps:s,summary:{totalSteps:i,simulationTime:this.steppedParams.stopTime-this.steppedParams.startTime,timeStep:this.steppedParams.timeStep}}}resetSteppedMode(){this.isSteppedMode=!1,this.currentTime=0,this.currentIteration=0,this.steppedParams=null,this.steppedResults=null}static getVersionInfo(){return{name:"AkingSPICE",version:"0.1.0",description:"JavaScript Solver for Power Electronics",features:["Modified Nodal Analysis (MNA)","LU decomposition solver","Backward Euler transient analysis","DC operating point analysis","SPICE-compatible netlist format","Basic passive components (R, L, C)","Independent sources (V, I)","Controlled sources (VCVS, VCCS)","MOSFET with body diode model","Stepped simulation control API"],author:"AkingSPICE Development Team",license:"MIT"}}}class x extends d{constructor(t,e,s={}){if(super(t,"V3PH",e.nodes,e.voltage,s),!e||!e.nodes)throw new Error(`ThreePhaseSource ${t}: nodes configuration required`);this.voltage=e.voltage||220,this.frequency=e.frequency||50,this.phaseOffset=e.phaseOffset||0,this.phaseSequence=e.phaseSequence||"ABC",this.connection=e.connection||"wye",this.nodes=e.nodes,this.validateNodeConfiguration(),this.phaseVoltage=this.connection==="wye"?this.voltage/Math.sqrt(3):this.voltage,this.createInternalSources(),this.calculatePhaseAngles()}validateNodeConfiguration(){if(this.connection==="wye"){if(this.nodes.length!==4)throw new Error(`ThreePhaseSource ${this.name}: Wye connection requires 4 nodes [A, B, C, N]`)}else if(this.connection==="delta"){if(this.nodes.length!==3)throw new Error(`ThreePhaseSource ${this.name}: Delta connection requires 3 nodes [AB, BC, CA]`)}else throw new Error(`ThreePhaseSource ${this.name}: Invalid connection type '${this.connection}'. Use 'wye' or 'delta'`)}calculatePhaseAngles(){const t=this.phaseOffset*Math.PI/180;if(this.phaseSequence==="ABC")this.phaseAngles={A:t,B:t-2*Math.PI/3,C:t-4*Math.PI/3};else if(this.phaseSequence==="ACB")this.phaseAngles={A:t,B:t+2*Math.PI/3,C:t+4*Math.PI/3};else throw new Error(`ThreePhaseSource ${this.name}: Invalid phase sequence '${this.phaseSequence}'. Use 'ABC' or 'ACB'`)}createInternalSources(){if(this.internalSources=[],this.connection==="wye"){const t=this.nodes[3];["A","B","C"].forEach((s,i)=>{const o=this.nodes[i],n=`${this.name}_${s}`,r=new f(n,[o,t],{type:"SINE",amplitude:this.phaseVoltage*Math.sqrt(2),frequency:this.frequency,phase:this.phaseAngles[s]*180/Math.PI,offset:0});this.internalSources.push(r)})}else this.connection==="delta"&&[{name:"AB",nodes:[this.nodes[0],this.nodes[1]],phase:"A"},{name:"BC",nodes:[this.nodes[1],this.nodes[2]],phase:"B"},{name:"CA",nodes:[this.nodes[2],this.nodes[0]],phase:"C"}].forEach(e=>{const s=`${this.name}_${e.name}`,i=new f(s,e.nodes,{type:"SINE",amplitude:this.voltage*Math.sqrt(2),frequency:this.frequency,phase:this.phaseAngles[e.phase]*180/Math.PI,offset:0});this.internalSources.push(i)})}getPhaseVoltage(t,e){if(!this.phaseAngles[t])throw new Error(`Invalid phase: ${t}`);const s=2*Math.PI*this.frequency;return(this.connection==="wye"?this.phaseVoltage*Math.sqrt(2):this.voltage*Math.sqrt(2))*Math.sin(s*e+this.phaseAngles[t])}getLineVoltage(t,e){if(this.connection==="delta"){const s={AB:"A",BC:"B",CA:"C"};return this.getPhaseVoltage(s[t],e)}else switch(t){case"AB":return this.getPhaseVoltage("A",e)-this.getPhaseVoltage("B",e);case"BC":return this.getPhaseVoltage("B",e)-this.getPhaseVoltage("C",e);case"CA":return this.getPhaseVoltage("C",e)-this.getPhaseVoltage("A",e);default:throw new Error(`Invalid line: ${t}`)}}stamp(t,e,s,i,o){this.internalSources.forEach(n=>{n.stamp&&n.stamp(t,e,s,i,o)})}needsCurrentVariable(){return!0}getCurrentVariableCount(){return this.internalSources.length}getThreePhaseInfo(){return{name:this.name,connection:this.connection,voltage:this.voltage,phaseVoltage:this.phaseVoltage,frequency:this.frequency,phaseSequence:this.phaseSequence,phaseOffset:this.phaseOffset,nodes:this.nodes,phaseAngles:Object.fromEntries(Object.entries(this.phaseAngles).map(([t,e])=>[t,e*180/Math.PI])),internalSources:this.internalSources.map(t=>t.name)}}toString(){const t=this.connection.toUpperCase(),e=this.nodes.join("-");return`${this.name} (3Phase ${t}): ${e}, ${this.voltage}V, ${this.frequency}Hz, ${this.phaseSequence}`}toJSON(){return{...super.toJSON(),connection:this.connection,voltage:this.voltage,frequency:this.frequency,phaseSequence:this.phaseSequence,phaseOffset:this.phaseOffset,threePhaseInfo:this.getThreePhaseInfo()}}clone(){return new x(this.name,{nodes:[...this.nodes],connection:this.connection,voltage:this.voltage,frequency:this.frequency,phaseSequence:this.phaseSequence,phaseOffset:this.phaseOffset},{...this.params})}}class T extends d{constructor(t,e,s={},i={}){if(super(t,"VM",e,0,{...s,...i}),e.length<3||e.length>4)throw new Error(`VoltageControlledMOSFET ${t} must have 3 or 4 nodes: [drain, gate, source] or [drain, gate, source, bulk]`);this.drain=e[0],this.gate=e[1],this.source=e[2],this.bulk=e[3]||e[2],this.Vth=this.safeParseValue(s.Vth,2),this.Kp=this.safeParseValue(s.Kp,1e-4),this.W=this.safeParseValue(s.W,1e-4),this.L=this.safeParseValue(s.L,1e-5),this.lambda=this.safeParseValue(s.lambda,0),this.Ron=this.safeParseValue(s.Ron,.1),this.Roff=this.safeParseValue(s.Roff,1e9),this.Vf_body=this.safeParseValue(s.Vf_body,.7),this.Ron_body=this.safeParseValue(s.Ron_body,.01),this.Cgs=this.safeParseValue(s.Cgs,1e-12),this.Cgd=this.safeParseValue(s.Cgd,1e-12),this.Cds=this.safeParseValue(s.Cds,1e-12),this.modelType=s.modelType||"NMOS",this.operatingRegion="OFF",this.Vgs=0,this.Vds=0,this.Vbs=0,this.Id=0,this.validate()}safeParseValue(t,e){try{return t==null?e:this.parseValue(t)}catch{return e}}updateVoltages(t){const e=t.get(this.drain)||0,s=t.get(this.gate)||0,i=t.get(this.source)||0,o=t.get(this.bulk)||i;this.Vgs=s-i,this.Vds=e-i,this.Vbs=o-i,this.updateOperatingRegion(),this.calculateDrainCurrent()}updateOperatingRegion(){const t=this.getEffectiveThresholdVoltage();this.modelType==="NMOS"?this.Vgs<t?this.operatingRegion="OFF":this.Vds<this.Vgs-t?this.operatingRegion="LINEAR":this.operatingRegion="SATURATION":this.Vgs>t?this.operatingRegion="OFF":this.Vds>this.Vgs-t?this.operatingRegion="LINEAR":this.operatingRegion="SATURATION"}getEffectiveThresholdVoltage(){return this.Vth}calculateDrainCurrent(){const t=this.getEffectiveThresholdVoltage(),e=this.Kp*this.W/this.L;switch(this.operatingRegion){case"OFF":this.Id=0;break;case"LINEAR":const s=this.Vgs-t;this.Id=e*(s*this.Vds-this.Vds*this.Vds/2)*(1+this.lambda*this.Vds);break;case"SATURATION":const i=this.Vgs-t;this.Id=e/2*i*i*(1+this.lambda*this.Vds);break}this.modelType==="PMOS"&&(this.Id=-this.Id)}getEquivalentResistance(){return this.operatingRegion==="OFF"?this.Roff:this.Ron}isBodyDiodeOn(){return this.modelType==="NMOS"?-this.Vds>this.Vf_body:this.Vds>this.Vf_body}stamp(t,e,s,i,o){const n=this.drain==="0"?-1:s.get(this.drain),r=this.source==="0"?-1:s.get(this.source);if(n===void 0||r===void 0)throw new Error(`VoltageControlledMOSFET ${this.name}: Node mapping not found`);const a=this.getEquivalentResistance(),h=1/a;n>=0&&(t.addAt(n,n,h),r>=0&&t.addAt(n,r,-h)),r>=0&&(t.addAt(r,r,h),n>=0&&t.addAt(r,n,-h));const c=this.isBodyDiodeOn();if(c){const u=1/this.Ron_body;n>=0&&(t.addAt(n,n,u),r>=0&&t.addAt(n,r,-u)),r>=0&&(t.addAt(r,r,u),n>=0&&t.addAt(r,n,-u));const y=u*this.Vf_body;n>=0&&e.addAt(n,-y),r>=0&&e.addAt(r,y)}this.name==="M1"&&c&&console.log(`${this.name}: Body diode ON, Vds=${this.Vds.toFixed(2)}V, Channel R=${a.toExponential(1)}Ω`)}updateHistory(t,e){this.updateVoltages(t),super.updateHistory(t,e)}setGateState(t){this.gateState=t}needsCurrentVariable(){return!1}getCurrent(t){return this.updateVoltages(t),this.operatingPoint.current=this.Id,this.Id}validate(){if(this.Kp<=0)throw new Error(`VoltageControlledMOSFET ${this.name}: Kp must be positive`);if(this.W<=0||this.L<=0)throw new Error(`VoltageControlledMOSFET ${this.name}: W and L must be positive`);if(this.Ron<=0)throw new Error(`VoltageControlledMOSFET ${this.name}: Ron must be positive`)}getOperatingStatus(){return{name:this.name,type:"VoltageControlledMOSFET",modelType:this.modelType,operatingRegion:this.operatingRegion,voltages:{Vgs:this.Vgs,Vds:this.Vds,Vbs:this.Vbs},current:{Id:this.Id},equivalentResistance:this.getEquivalentResistance(),bodyDiodeOn:this.isBodyDiodeOn(),parameters:{Vth:this.Vth,Kp:this.Kp,WoverL:this.W/this.L}}}toString(){return`${this.name} (${this.modelType} VC-MOSFET): D=${this.drain} G=${this.gate} S=${this.source}, Vth=${this.Vth}V, Region=${this.operatingRegion}, Id=${this.Id.toExponential(3)}A`}clone(){const t=[this.drain,this.gate,this.source];return this.bulk!==this.source&&t.push(this.bulk),new T(this.name,t,{Vth:this.Vth,Kp:this.Kp,W:this.W,L:this.L,lambda:this.lambda,Ron:this.Ron,Roff:this.Roff,Vf_body:this.Vf_body,Ron_body:this.Ron_body,modelType:this.modelType},{...this.params})}}class M extends d{constructor(t,e,s={}){if(super(t,"D",e,0,s),e.length<2)throw new Error(`Diode ${t} must have 2 nodes: [anode, cathode]`);this.Vf=this.safeParseValue(s.Vf,.7),this.Ron=this.safeParseValue(s.Ron,.01),this.Roff=this.safeParseValue(s.Roff,1e6),this.anode=e[0],this.cathode=e[1],this.isForwardBiased=!1,this.anodeCathodeVoltage=0,this.current=0,this.validate()}safeParseValue(t,e){try{return t==null?e:this.parseValue(t)}catch{return e}}validate(){if(this.Ron<=0)throw new Error(`Diode ${this.name}: Ron must be positive`);if(this.Roff<=this.Ron)throw new Error(`Diode ${this.name}: Roff must be greater than Ron`);if(this.Vf<0)throw new Error(`Diode ${this.name}: Forward voltage Vf must be non-negative`)}getEquivalentResistance(t){return this.isForwardBiased=t>this.Vf,this.isForwardBiased?this.Ron:this.Roff}isOn(){return this.isForwardBiased}getVoltageDrop(){return this.isForwardBiased?this.Vf+this.current*this.Ron:this.anodeCathodeVoltage}stamp(t,e,s,i,o){const n=this.anode==="0"||this.anode==="gnd"?-1:s.get(this.anode),r=this.cathode==="0"||this.cathode==="gnd"?-1:s.get(this.cathode);if(n===void 0||r===void 0)throw new Error(`Diode ${this.name}: Node mapping not found (anode: ${this.anode}, cathode: ${this.cathode})`);let a=0;this.anodeCathodeVoltage!==void 0&&(a=this.anodeCathodeVoltage);const h=this.getEquivalentResistance(a),c=1/h;if(n>=0&&(t.addAt(n,n,c),r>=0&&t.addAt(n,r,-c)),r>=0&&(t.addAt(r,r,c),n>=0&&t.addAt(r,n,-c)),this.isForwardBiased){const u=this.Vf/h;n>=0&&e.addAt(n,-u),r>=0&&e.addAt(r,u)}}updateState(t,e){this.anodeCathodeVoltage=t,this.current=e,this.isForwardBiased=t>this.Vf}updateHistory(t,e){super.updateHistory(t,e);const s=t.get(this.anode)||0,i=t.get(this.cathode)||0,o=s-i,n=this.getEquivalentResistance(o),r=o/n;this.updateState(o,r)}needsCurrentVariable(){return!1}toString(){return`${this.name} (Diode): A=${this.anode} K=${this.cathode}, State=${this.isForwardBiased?"ON":"OFF"}, Vf=${this.Vf}V, Ron=${this.Ron}Ω`}getOperatingStatus(){return{name:this.name,type:"Diode",state:this.isForwardBiased?"ON":"OFF",anodeCathodeVoltage:this.anodeCathodeVoltage,current:this.current,voltageDrop:this.getVoltageDrop(),currentResistance:this.getEquivalentResistance(this.anodeCathodeVoltage),isForwardBiased:this.isForwardBiased}}toJSON(){return{...super.toJSON(),Vf:this.Vf,Ron:this.Ron,Roff:this.Roff,operatingStatus:this.getOperatingStatus()}}clone(){return new M(this.name,this.nodes,{Vf:this.Vf,Ron:this.Ron,Roff:this.Roff})}}class W{constructor(t,e){if(this.name=t,this.type="T_META",!e||!e.windings||e.windings.length<2)throw new Error(`Transformer ${t} must have at least 2 windings`);const s=e.windings.length;this.inductors=e.windings.map((n,r)=>{const a=`${t}_${n.name||`W${r+1}`}`;return new v(a,n.nodes,n.inductance,{r:n.resistance||0})});const i=this.buildCouplingMatrix(s,e.couplingMatrix),o=this.calculateMutualInductanceMatrix(i);for(let n=0;n<s;n++){const r=this.inductors[n];r.couplings=[];for(let a=0;a<s;a++){if(n===a)continue;const h=this.inductors[a],c=o[n][a];r.couplings.push({inductor:h,mutualInductance:c*1})}}}getComponents(){return this.inductors}buildCouplingMatrix(t,e){const s=Array(t).fill(null).map(()=>Array(t).fill(0));for(let i=0;i<t;i++)s[i][i]=1;if(e)for(let i=0;i<t;i++)for(let o=i+1;o<t;o++){const n=e[i]&&e[i][o]!==void 0?e[i][o]:.99;s[i][o]=s[o][i]=Math.max(-1,Math.min(1,n))}else for(let o=0;o<t;o++)for(let n=o+1;n<t;n++)s[o][n]=s[n][o]=.99;return s}calculateMutualInductanceMatrix(t){const e=this.inductors.length,s=Array(e).fill(null).map(()=>Array(e).fill(0));for(let i=0;i<e;i++)for(let o=i;o<e;o++)if(i===o)s[i][o]=this.inductors[i].getInductance();else{const n=this.inductors[i].getInductance(),r=this.inductors[o].getInductance(),h=t[i][o]*Math.sqrt(n*r);s[i][o]=s[o][i]=h}return s}toString(){return`${this.name} (MultiWinding Transformer with ${this.inductors.length} windings)`}}l.AkingSPICE=B,l.BaseComponent=d,l.CCCS=b,l.CCVS=I,l.Capacitor=E,l.CoupledInductor=z,l.CurrentSource=N,l.DCAnalysis=q,l.Diode=M,l.Inductor=v,l.MOSFET=V,l.MultiWindingTransformer=W,l.NetlistParser=F,l.Resistor=R,l.ThreePhaseSource=x,l.TransientAnalysis=D,l.VCCS=P,l.VCVS=A,l.VoltageControlledMOSFET=T,l.VoltageSource=f,l.default=B,Object.defineProperties(l,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
//# sourceMappingURL=AkingSPICE.umd.js.map
