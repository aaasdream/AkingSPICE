<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>AkingSPICE LLCè¨ºæ–·</title>
  <style>
    body {
      font-family: Arial;
      padding: 20px;
      background: #2c3e50;
      color: white;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 10px;
    }

    #log {
      height: 400px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.4);
      padding: 15px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      margin-top: 20px;
    }

    .success {
      color: #27ae60;
    }

    .error {
      color: #e74c3c;
    }

    .warning {
      color: #f39c12;
    }

    .info {
      color: #3498db;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>ğŸ” AkingSPICE LLCå•é¡Œè¨ºæ–·</h1>
    <p>æ·±å…¥åˆ†æAkingSPICEçš„æ•¸å€¼æ±‚è§£å•é¡Œ</p>

    <div id="log">é–‹å§‹è¨ºæ–·AkingSPICE...<br></div>
  </div>

  <script src="./lib-dist/AkingSPICE.umd.js"></script>

  <script>
    function log(message, type = 'info') {
      const colors = {
        'success': '#27ae60',
        'error': '#e74c3c',
        'warning': '#f39c12',
        'info': '#3498db'
      };

      const time = new Date().toLocaleTimeString();
      const logElement = document.getElementById('log');
      logElement.innerHTML += `<span style="color: ${colors[type]};">[${time}] ${message}</span><br>`;
      logElement.scrollTop = logElement.scrollHeight;
      console.log(`[${time}] ${message}`);
    }

    document.addEventListener('DOMContentLoaded', function () {
      log('ğŸ” é–‹å§‹AkingSPICEæ·±åº¦è¨ºæ–·', 'success');

      if (!window.AkingSPICE) {
        log('âŒ AkingSPICEæœªè¼‰å…¥', 'error');
        return;
      }

      log('âœ… AkingSPICEå·²è¼‰å…¥', 'success');

      // æª¢æŸ¥å¯ç”¨çš„çµ„ä»¶å’Œæ±‚è§£å™¨
      const spice = window.AkingSPICE;
      log('ğŸ“¦ æª¢æŸ¥AkingSPICEå…§å®¹:', 'info');

      for (const key in spice) {
        log(`  - ${key}: ${typeof spice[key]}`, 'info');
      }

      try {
        const { VoltageSource, Resistor, Capacitor, Inductor, ExplicitStateSolver } = spice;

        log('ğŸ§ª æ¸¬è©¦1: æœ€ç°¡å–®çš„é›»è·¯ (V + R)', 'warning');

        // æœ€ç°¡å–®çš„é›»è·¯
        const simpleComponents = [
          new VoltageSource('V1', [1, 0], 5.0),
          new Resistor('R1', [1, 0], 10.0)
        ];

        log('å‰µå»ºçµ„ä»¶å®Œæˆ', 'success');

        const solver1 = new ExplicitStateSolver();
        log('å‰µå»ºæ±‚è§£å™¨å®Œæˆ', 'success');

        // å˜—è©¦åˆå§‹åŒ–
        log('å˜—è©¦åˆå§‹åŒ–æ±‚è§£å™¨...', 'info');
        solver1.initialize(simpleComponents, 1e-3, {
          debug: true,
          maxIterations: 50,
          tolerance: 1e-3
        });

        log('âœ… ç°¡å–®é›»è·¯åˆå§‹åŒ–æˆåŠŸ', 'success');

        // åŸ·è¡Œå¹¾æ­¥
        for (let i = 0; i < 3; i++) {
          const result = solver1.step();
          log(`æ­¥é©Ÿ ${i + 1}: nodeVoltages = ${JSON.stringify(result.nodeVoltages)}`, 'success');
        }

        log('ğŸ§ª æ¸¬è©¦2: æ·»åŠ é›»å®¹å™¨ (RLC)', 'warning');

        const rlcComponents = [
          new VoltageSource('V1', [1, 0], 5.0),
          new Resistor('R1', [1, 2], 10.0),
          new Inductor('L1', [2, 3], 1e-3),  // 1mH
          new Capacitor('C1', [3, 0], 1e-6)  // 1Î¼F
        ];

        const solver2 = new ExplicitStateSolver();

        try {
          solver2.initialize(rlcComponents, 1e-5, {  // 10Î¼s
            debug: true,
            maxIterations: 100,
            tolerance: 1e-4
          });

          log('âœ… RLCé›»è·¯åˆå§‹åŒ–æˆåŠŸ', 'success');

          // åŸ·è¡Œå¹¾æ­¥çœ‹çœ‹
          for (let i = 0; i < 5; i++) {
            const result = solver2.step();
            log(`RLCæ­¥é©Ÿ ${i + 1}: ç¯€é»é›»å£“ = ${JSON.stringify(result.nodeVoltages)}`, 'success');
          }

        } catch (rlcError) {
          log(`âŒ RLCé›»è·¯å¤±æ•—: ${rlcError.message}`, 'error');
          log(`éŒ¯èª¤è©³ç´°: ${rlcError.stack}`, 'error');
        }

        log('ğŸ§ª æ¸¬è©¦3: æª¢æŸ¥LLCçµ„ä»¶éœ€æ±‚', 'warning');

        // æª¢æŸ¥æ˜¯å¦æœ‰è®Šå£“å™¨çµ„ä»¶
        if (spice.Transformer) {
          log('âœ… æ‰¾åˆ°Transformerçµ„ä»¶', 'success');
        } else {
          log('âŒ æ²’æœ‰Transformerçµ„ä»¶', 'error');
          log('éœ€è¦ä½¿ç”¨è€¦åˆé›»æ„Ÿä¾†å¯¦ç¾è®Šå£“å™¨', 'warning');
        }

        // æª¢æŸ¥æ˜¯å¦æœ‰è€¦åˆé›»æ„Ÿ
        if (spice.CoupledInductor || spice.MutualInductor) {
          log('âœ… æ‰¾åˆ°è€¦åˆé›»æ„Ÿçµ„ä»¶', 'success');
        } else {
          log('âŒ æ²’æœ‰è€¦åˆé›»æ„Ÿçµ„ä»¶', 'error');
          log('éœ€è¦ç”¨å¤šå€‹ç¨ç«‹é›»æ„Ÿè¿‘ä¼¼è®Šå£“å™¨', 'warning');
        }

        log('ğŸ”§ åˆ†æExplicitStateSolverçš„åƒæ•¸:', 'info');

        // å˜—è©¦ä¸åŒçš„æ±‚è§£å™¨è¨­ç½®
        log('æ¸¬è©¦ä¸åŒçš„æ•¸å€¼åƒæ•¸...', 'info');

        const testParams = [
          { dt: 1e-6, maxIter: 50, tol: 1e-3 },   // 1Î¼s, å¯¬é¬†
          { dt: 1e-7, maxIter: 100, tol: 1e-4 },  // 0.1Î¼s, ä¸­ç­‰
          { dt: 1e-8, maxIter: 200, tol: 1e-5 }   // 0.01Î¼s, åš´æ ¼
        ];

        for (let p = 0; p < testParams.length; p++) {
          const param = testParams[p];
          log(`æ¸¬è©¦åƒæ•¸çµ„ ${p + 1}: dt=${param.dt}, maxIter=${param.maxIter}, tol=${param.tol}`, 'info');

          try {
            const testSolver = new ExplicitStateSolver();
            testSolver.initialize(simpleComponents, param.dt, {
              maxIterations: param.maxIter,
              tolerance: param.tol
            });

            const testResult = testSolver.step();
            log(`  âœ… åƒæ•¸çµ„ ${p + 1} å¯ä»¥å·¥ä½œ`, 'success');

          } catch (paramError) {
            log(`  âŒ åƒæ•¸çµ„ ${p + 1} å¤±æ•—: ${paramError.message}`, 'error');
          }
        }

        log('ğŸ¯ è¨ºæ–·å®Œæˆï¼æº–å‚™å‰µå»ºçœŸå¯¦çš„LLC...', 'success');

      } catch (error) {
        log(`âŒ è¨ºæ–·éç¨‹éŒ¯èª¤: ${error.message}`, 'error');
        log(`éŒ¯èª¤å †ç–Š: ${error.stack}`, 'error');
      }
    });

  </script>
</body>

</html>