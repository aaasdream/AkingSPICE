<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>AkingSPICE診斷測試</title>
  <style>
    body {
      font-family: Arial;
      padding: 20px;
      background: #2c3e50;
      color: white;
    }

    .test-box {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      margin: 10px 0;
      border-radius: 8px;
    }

    .success {
      border-left: 4px solid #2ecc71;
    }

    .error {
      border-left: 4px solid #e74c3c;
    }

    .warning {
      border-left: 4px solid #f39c12;
    }

    #log {
      height: 400px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.3);
      padding: 10px;
      font-family: monospace;
      font-size: 12px;
    }
  </style>
</head>

<body>
  <h1>🔧 AkingSPICE診斷測試</h1>

  <div class="test-box" id="status">
    <h3>測試狀態</h3>
    <div id="test-status">準備測試...</div>
  </div>

  <div class="test-box">
    <h3>📋 測試日誌</h3>
    <div id="log">開始AkingSPICE診斷測試...<br></div>
  </div>

  <script src="./lib-dist/AkingSPICE.umd.js"></script>

  <script>
    function log(msg, type = 'info') {
      const colors = { info: '#ecf0f1', error: '#e74c3c', success: '#2ecc71', warning: '#f39c12' };
      const time = new Date().toLocaleTimeString();

      const logDiv = document.getElementById('log');
      logDiv.innerHTML += `<span style="color:${colors[type]};">[${time}] ${msg}</span><br>`;
      logDiv.scrollTop = logDiv.scrollHeight;
      console.log(`[${time}] ${msg}`);
    }

    function updateStatus(msg, type = 'info') {
      const statusDiv = document.getElementById('status');
      const testStatusDiv = document.getElementById('test-status');

      statusDiv.className = `test-box ${type}`;
      testStatusDiv.textContent = msg;
    }

    // 開始診斷測試
    document.addEventListener('DOMContentLoaded', async function () {
      log('🚀 開始AkingSPICE診斷測試', 'success');

      try {
        // 測試1: 檢查AkingSPICE載入
        log('📦 測試1: 檢查AkingSPICE載入...', 'info');
        if (!window.AkingSPICE) {
          throw new Error('AkingSPICE未載入');
        }
        log('✅ AkingSPICE載入成功', 'success');
        updateStatus('AkingSPICE載入成功', 'success');

        // 測試2: 檢查組件類別
        log('🔧 測試2: 檢查組件類別...', 'info');
        const { VoltageSource, Resistor, Capacitor, Inductor, ExplicitStateSolver } = window.AkingSPICE;

        if (!VoltageSource || !Resistor || !Capacitor || !Inductor || !ExplicitStateSolver) {
          throw new Error('組件類別不完整');
        }
        log('✅ 所有基本組件類別可用', 'success');

        // 測試3: 創建簡單組件
        log('⚙️ 測試3: 創建簡單組件...', 'info');
        const v1 = new VoltageSource('V1', [1, 0], 5.0);
        const r1 = new Resistor('R1', [1, 0], 1000.0);
        log(`✅ 電壓源創建: ${v1.name} = ${v1.value}V`, 'success');
        log(`✅ 電阻創建: ${r1.name} = ${r1.value}Ω`, 'success');

        // 測試4: 創建求解器
        log('🧮 測試4: 創建ExplicitStateSolver...', 'info');
        const solver = new ExplicitStateSolver();
        log('✅ 求解器創建成功', 'success');

        // 測試5: 簡單電路初始化
        log('🔌 測試5: 簡單電路初始化 (V-R電路)...', 'info');
        const simpleComponents = [
          new VoltageSource('V1', [1, 0], 12.0),
          new Resistor('R1', [1, 0], 1000.0)
        ];

        try {
          solver.initialize(simpleComponents, 1e-4, {
            debug: false,
            maxIterations: 100,
            tolerance: 1e-6
          });
          log('✅ 簡單電路初始化成功', 'success');
        } catch (error) {
          log(`❌ 簡單電路初始化失敗: ${error.message}`, 'error');
          throw error;
        }

        // 測試6: 執行一步模擬
        log('▶️ 測試6: 執行模擬步驟...', 'info');
        try {
          const result = solver.step();
          log('✅ 模擬步驟執行成功', 'success');

          if (result.nodeVoltages) {
            const v = result.nodeVoltages[1] || 0;
            log(`📊 節點1電壓: ${v.toFixed(3)}V`, 'info');
          }

          log('🎉 所有基本測試通過！', 'success');
          updateStatus('AkingSPICE基本功能正常', 'success');

          // 現在測試複雜電路
          setTimeout(testComplexCircuit, 1000);

        } catch (error) {
          log(`❌ 模擬步驟失敗: ${error.message}`, 'error');
          throw error;
        }

      } catch (error) {
        log(`❌ 診斷測試失敗: ${error.message}`, 'error');
        updateStatus(`測試失敗: ${error.message}`, 'error');
      }
    });

    // 測試複雜電路
    async function testComplexCircuit() {
      log('🧪 開始複雜電路測試...', 'warning');

      try {
        const { VoltageSource, Resistor, Capacitor, Inductor, ExplicitStateSolver } = window.AkingSPICE;

        // 測試7: RLC電路
        log('🔋 測試7: RLC電路測試...', 'info');
        const rlcComponents = [
          new VoltageSource('Vin', [1, 0], 10.0),
          new Resistor('R1', [1, 2], 100.0),
          new Inductor('L1', [2, 3], 1e-3),  // 1mH
          new Capacitor('C1', [3, 0], 1e-6)  // 1μF
        ];

        const rlcSolver = new ExplicitStateSolver();

        try {
          rlcSolver.initialize(rlcComponents, 1e-5, {  // 較大時間步長
            debug: false,
            maxIterations: 50,  // 降低最大迭代次數
            tolerance: 1e-5     // 放寬容差
          });

          log('✅ RLC電路初始化成功', 'success');

          // 執行幾步
          for (let i = 0; i < 5; i++) {
            const result = rlcSolver.step();
            const v3 = result.nodeVoltages && result.nodeVoltages[3] ? result.nodeVoltages[3] : 0;
            log(`步驟 ${i + 1}: 電容電壓 = ${v3.toFixed(4)}V`, 'info');
          }

          log('🎉 RLC電路測試成功！', 'success');
          updateStatus('RLC電路測試通過 - 問題可能在LLC參數', 'warning');

        } catch (error) {
          log(`❌ RLC電路失敗: ${error.message}`, 'error');
          updateStatus('RLC電路也失敗 - AkingSPICE有數值問題', 'error');
        }

        // 測試8: LLC相關問題診斷
        log('🔍 測試8: LLC問題診斷...', 'warning');
        log('可能的LLC問題:', 'warning');
        log('1. 時間步長太小 (20ns可能太小)', 'warning');
        log('2. 電路節點過多且耦合緊密', 'warning');
        log('3. 變壓器模型近似不當', 'warning');
        log('4. 初始條件不穩定', 'warning');
        log('5. 電阻值過小導致剛性問題', 'warning');

      } catch (error) {
        log(`❌ 複雜電路測試錯誤: ${error.message}`, 'error');
      }
    }
  </script>
</body>

</html>