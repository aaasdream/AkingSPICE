<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>AkingSPICE最基本測試</title>
  <style>
    body {
      font-family: Arial;
      padding: 20px;
      background: #2c3e50;
      color: white;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 10px;
    }

    #log {
      height: 400px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.4);
      padding: 15px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      margin-top: 20px;
    }

    .success {
      color: #27ae60;
    }

    .error {
      color: #e74c3c;
    }

    .warning {
      color: #f39c12;
    }

    .info {
      color: #3498db;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>⚡ AkingSPICE最基本測試</h1>
    <p>從最簡單的電路開始逐步測試</p>

    <div id="log">開始最基本的AkingSPICE測試...<br></div>
  </div>

  <script src="./lib-dist/AkingSPICE.umd.js"></script>

  <script>
    function log(message, type = 'info') {
      const colors = {
        'success': '#27ae60',
        'error': '#e74c3c',
        'warning': '#f39c12',
        'info': '#3498db'
      };

      const time = new Date().toLocaleTimeString();
      const logElement = document.getElementById('log');
      logElement.innerHTML += `<span style="color: ${colors[type]};">[${time}] ${message}</span><br>`;
      logElement.scrollTop = logElement.scrollHeight;
    }

    document.addEventListener('DOMContentLoaded', function () {
      log('⚡ 開始AkingSPICE最基本測試', 'success');

      if (!window.AkingSPICE) {
        log('❌ AkingSPICE未載入', 'error');
        return;
      }

      const spice = window.AkingSPICE;
      const { VoltageSource, Resistor, ExplicitStateSolver } = spice;

      // 測試1: 只有電壓源 (應該失敗，因為沒有完整回路)
      try {
        log('🧪 測試1: 只有電壓源 (無回路)', 'info');
        const onlyVoltage = [
          new VoltageSource('V1', [1, 0], 5.0)
        ];

        const solver1 = new ExplicitStateSolver();
        solver1.initialize(onlyVoltage, 1e-3);
        log('⚠️ 測試1意外通過 (只有電壓源)', 'warning');
      } catch (e1) {
        log(`✅ 測試1正確失敗: ${e1.message}`, 'success');
      }

      // 測試2: 電壓源 + 電阻 (最簡單的完整電路)
      try {
        log('🧪 測試2: V + R (最簡單完整電路)', 'info');
        const vr_circuit = [
          new VoltageSource('V1', [1, 0], 5.0),
          new Resistor('R1', [1, 0], 10.0)
        ];

        log('創建電路組件...', 'info');
        const solver2 = new ExplicitStateSolver();

        log('初始化求解器 (寬鬆參數)...', 'info');
        solver2.initialize(vr_circuit, 1e-3, {
          maxIterations: 20,   // 只允許20次迭代
          tolerance: 1e-2,     // 非常寬鬆的容差 1%
          debug: true
        });

        log('✅ 測試2初始化成功', 'success');

        // 執行一步
        log('執行求解步驟...', 'info');
        const result2 = solver2.step();

        log(`✅ 測試2執行成功: nodeVoltages = ${JSON.stringify(result2.nodeVoltages)}`, 'success');

        // 驗證結果 (5V電源，10Ω電阻，應該有0.5A電流)
        const v1 = result2.nodeVoltages[1] || 0;
        const current = v1 / 10.0;
        log(`計算: V1=${v1.toFixed(3)}V, I=${current.toFixed(3)}A`, 'info');

      } catch (e2) {
        log(`❌ 測試2失敗: ${e2.message}`, 'error');

        // 如果基本電路都失敗，嘗試更寬鬆的參數
        try {
          log('🔧 嘗試極寬鬆參數...', 'warning');
          const vr_circuit2 = [
            new VoltageSource('V1', [1, 0], 1.0),  // 降低到1V
            new Resistor('R1', [1, 0], 1000.0)     // 增加到1kΩ
          ];

          const solver3 = new ExplicitStateSolver();
          solver3.initialize(vr_circuit2, 1e-2, {   // 10ms大時間步長
            maxIterations: 5,     // 只允許5次迭代
            tolerance: 1e-1,      // 10%容差
            debug: true
          });

          const result3 = solver3.step();
          log(`✅ 極寬鬆參數成功: ${JSON.stringify(result3.nodeVoltages)}`, 'success');

        } catch (e3) {
          log(`❌ 連極寬鬆參數都失敗: ${e3.message}`, 'error');
        }
      }

      // 測試3: 檢查組件內部狀態
      try {
        log('🧪 測試3: 檢查組件內部狀態', 'info');

        const v_test = new VoltageSource('V1', [1, 0], 5.0);
        const r_test = new Resistor('R1', [1, 0], 10.0);

        log(`VoltageSource: name=${v_test.name}, nodes=${JSON.stringify(v_test.nodes)}, voltage=${v_test.voltage}`, 'info');
        log(`Resistor: name=${r_test.name}, nodes=${JSON.stringify(r_test.nodes)}, resistance=${r_test.resistance}`, 'info');

        // 檢查是否有stamp方法
        if (typeof v_test.stamp === 'function') {
          log('✅ VoltageSource有stamp方法', 'success');
        } else {
          log('❌ VoltageSource沒有stamp方法', 'error');
        }

        if (typeof r_test.stamp === 'function') {
          log('✅ Resistor有stamp方法', 'success');
        } else {
          log('❌ Resistor沒有stamp方法', 'error');
        }

      } catch (e3) {
        log(`❌ 測試3失敗: ${e3.message}`, 'error');
      }

      // 測試4: 手動創建最簡單的矩陣
      try {
        log('🧪 測試4: 手動矩陣測試', 'info');

        // 創建一個2x2矩陣 [2 1; 1 2] x = [3; 4]
        // 解應該是 x = [2/3; 4/3]

        if (spice.Matrix) {
          const Matrix = spice.Matrix;
          const mat = new Matrix(2, 2);
          mat.set(0, 0, 2.0);
          mat.set(0, 1, 1.0);
          mat.set(1, 0, 1.0);
          mat.set(1, 1, 2.0);

          const b = new Float64Array([3.0, 4.0]);

          log('創建2x2測試矩陣', 'info');
          log(`Matrix[0,0]=${mat.get(0, 0)}, Matrix[0,1]=${mat.get(0, 1)}`, 'info');
          log(`Matrix[1,0]=${mat.get(1, 0)}, Matrix[1,1]=${mat.get(1, 1)}`, 'info');

          // 直接手算驗證
          const x_manual = [(3 * 2 - 1 * 4) / (2 * 2 - 1 * 1), (4 * 2 - 3 * 1) / (2 * 2 - 1 * 1)];
          log(`手算解: x=[${x_manual[0].toFixed(3)}, ${x_manual[1].toFixed(3)}]`, 'success');

        } else {
          log('❌ 找不到Matrix類', 'error');
        }

      } catch (e4) {
        log(`❌ 測試4失敗: ${e4.message}`, 'error');
      }

      log('🏁 基本測試完成', 'success');
    });

  </script>
</body>

</html>