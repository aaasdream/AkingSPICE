<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>ğŸš€ AkingSPICE - CPU vs GPU å®Œæ•´æ€§èƒ½æ¸¬è©¦</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; 
            margin: 20px; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 0;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        h1 { 
            color: #333; 
            text-align: center; 
            margin-bottom: 30px;
        }
        .test-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        .test-panel {
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            color: white;
        }
        .cpu-panel {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        .gpu-panel {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }
        .circuit-info {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #007bff;
            grid-column: 1 / -1;
        }
        button { 
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white; 
            border: none; 
            padding: 12px 25px; 
            border-radius: 8px; 
            cursor: pointer; 
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 8px;
            min-width: 180px;
        }
        button:hover:not(:disabled) { 
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        button:disabled { 
            background: #aaa; 
            cursor: not-allowed; 
            transform: none;
        }
        .results {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255,255,255,0.8);
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            max-height: 350px;
            overflow-y: auto;
        }
        .status {
            padding: 8px;
            margin: 8px 0;
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.9em;
        }
        .status.info { background: #d1ecf1; color: #0c5460; }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.warning { background: #fff3cd; color: #856404; }
        .progress {
            width: 100%;
            height: 22px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            transition: width 0.3s ease;
            text-align: center;
            line-height: 22px;
            color: white;
            font-weight: bold;
            font-size: 0.85em;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 12px;
            margin-top: 15px;
        }
        .metric {
            background: white;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .metric-value {
            font-size: 1.3em;
            font-weight: bold;
            color: #007bff;
        }
        .metric-label {
            font-size: 0.8em;
            color: #666;
            margin-top: 3px;
        }
        .comparison-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            display: none;
        }
        .comparison-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .gpu-status {
            background: rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }
        .control-buttons {
            text-align: center;
            margin-top: 20px;
        }
        .control-buttons button {
            margin: 10px;
            min-width: 250px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ AkingSPICE - CPU vs GPU å®Œæ•´æ€§èƒ½æ¸¬è©¦</h1>
        
        <div class="test-grid">
            <div class="circuit-info">
                <h3>ğŸ“‹ æ¸¬è©¦é›»è·¯ï¼šç°¡å–®RCé›»è·¯</h3>
                <p><strong>çµ„ä»¶ï¼š</strong>é›»å£“æº 5Vï¼Œé›»é˜» 10Î©ï¼Œé›»å®¹ 1Î¼F</p>
                <p><strong>æ™‚é–“æ­¥é•·ï¼š</strong>10ns &nbsp;|&nbsp; <strong>æ¸¬è©¦æ­¥æ•¸ï¼š</strong>100,000 æ­¥ (1ms æ¨¡æ“¬æ™‚é–“)</p>
                <p><strong>é æœŸçµæœï¼š</strong>é›»å®¹å……é›»æ›²ç·šï¼Œæœ€çµ‚é›»å£“è¶¨è¿‘ 5V</p>
            </div>

            <div class="cpu-panel">
                <h3>ğŸ’» CPU æ¸¬è©¦</h3>
                <button id="cpuTestBtn" onclick="runCPUTest()">ğŸ”„ åŸ·è¡Œ CPU æ¸¬è©¦</button>
                <button onclick="runSmallCPUTest()">ğŸ”„ å¿«é€Ÿæ¸¬è©¦ (1è¬æ­¥)</button>
                <div class="progress" id="cpuProgress" style="display:none;">
                    <div class="progress-bar" id="cpuProgressBar">0%</div>
                </div>
                <div class="results" id="cpuResults">ç­‰å¾…æ¸¬è©¦...</div>
                <div class="metrics" id="cpuMetrics" style="display:none;"></div>
            </div>
            
            <div class="gpu-panel">
                <h3>âš¡ GPU æ¸¬è©¦</h3>
                <div class="gpu-status" id="gpuStatus">ğŸ” æª¢æŸ¥ GPU æ”¯æ´...</div>
                <button id="gpuTestBtn" onclick="runGPUTest()" disabled>ğŸš€ åŸ·è¡Œ GPU æ¸¬è©¦ (10è¬æ­¥)</button>
                <button onclick="runSmallGPUTest()" disabled id="gpuSmallBtn">ğŸš€ å¿«é€Ÿæ¸¬è©¦ (1è¬æ­¥)</button>
                <button onclick="runMicroGPUTest()" disabled id="gpuMicroBtn">âš¡ æ¥µé€Ÿæ¸¬è©¦ (1000æ­¥)</button>
                <div class="progress" id="gpuProgress" style="display:none;">
                    <div class="progress-bar" id="gpuProgressBar">0%</div>
                </div>
                <div class="results" id="gpuResults">ç­‰å¾…GPUæª¢æŸ¥...</div>
                <div class="metrics" id="gpuMetrics" style="display:none;"></div>
            </div>
        </div>

        <div class="comparison-section" id="comparisonSection">
            <h3>ğŸ“Š CPU vs GPU æ€§èƒ½æ¯”è¼ƒ</h3>
            <div class="comparison-metrics" id="comparisonMetrics"></div>
        </div>
        
        <div class="control-buttons">
            <button onclick="runBothTests()" id="runBothBtn">ğŸ”¥ åŒæ™‚åŸ·è¡Œ CPU & GPU æ¸¬è©¦</button>
            <button onclick="analyzeGPUPerformance()" id="analyzeBtn">ğŸ”¬ GPU æ€§èƒ½åˆ†æ</button>
            <button onclick="resetTests()">ğŸ”„ é‡ç½®æ‰€æœ‰æ¸¬è©¦</button>
        </div>
    </div>

    <!-- è¼‰å…¥æœ¬åœ°ç·¨è­¯çš„ AkingSPICE åº« -->
    <script src="https://keepmy.link/6cc06b23"></script>
    
    <script>
        // å…¨å±€ç‹€æ…‹
        let cpuResults = null;
        let gpuResults = null;
        let gpuAvailable = false;
        
        // æ¸¬è©¦åƒæ•¸
        const TEST_STEPS = 100000;  // 10è¬æ­¥
        const SMALL_TEST_STEPS = 10000;  // 1è¬æ­¥
        const TIME_STEP = 10e-9;    // 10ns
        
        // å‰µå»ºæ¸¬è©¦é›»è·¯çµ„ä»¶
        function createTestCircuit() {
            try {
                if (!AkingSPICE.VoltageSource || !AkingSPICE.Resistor || !AkingSPICE.Capacitor) {
                    throw new Error('AkingSPICE çµ„ä»¶é¡ä¸å¯ç”¨');
                }
                
                const components = [
                    new AkingSPICE.VoltageSource('V1', ['vin', 'gnd'], 5.0),
                    new AkingSPICE.Resistor('R1', ['vin', 'vout'], 10),
                    new AkingSPICE.Capacitor('C1', ['vout', 'gnd'], 1e-6)
                ];
                
                return components;
            } catch (error) {
                throw new Error(`çµ„ä»¶å‰µå»ºå¤±æ•—: ${error.message}`);
            }
        }
        
        // è¨˜éŒ„ç‹€æ…‹
        function logStatus(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            const statusDiv = document.createElement('div');
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
            element.appendChild(statusDiv);
            element.scrollTop = element.scrollHeight;
        }
        
        // æ›´æ–°é€²åº¦æ¢
        function updateProgress(progressId, current, total) {
            const progressBar = document.getElementById(progressId);
            const percentage = Math.round((current / total) * 100);
            progressBar.style.width = `${percentage}%`;
            progressBar.textContent = `${percentage}%`;
        }
        
        // é¡¯ç¤ºæ¸¬è©¦çµæœæŒ‡æ¨™
        function showMetrics(metricsId, results, testType) {
            const metricsDiv = document.getElementById(metricsId);
            const finalTime = results.totalSteps * TIME_STEP * 1000; // ms
            const efficiency = (results.stepsPerSecond / 1000).toFixed(1); // Kæ­¥/ç§’
            
            metricsDiv.innerHTML = `
                <div class="metric">
                    <div class="metric-value">${results.totalSteps.toLocaleString()}</div>
                    <div class="metric-label">æ­¥æ•¸</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${results.duration.toFixed(1)}</div>
                    <div class="metric-label">æ™‚é–“(ms)</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${efficiency}K</div>
                    <div class="metric-label">æ­¥/ç§’</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${results.finalVoltage.toFixed(4)}</div>
                    <div class="metric-label">æœ€çµ‚é›»å£“(V)</div>
                </div>
            `;
            metricsDiv.style.display = 'grid';
        }
        
        // CPUæ¸¬è©¦ - é€šç”¨å‡½æ•¸
        async function runCPUTestWithSteps(steps, testName) {
            const startTime = performance.now();
            const cpuBtn = document.getElementById('cpuTestBtn');
            const cpuProgressDiv = document.getElementById('cpuProgress');
            
            try {
                cpuBtn.disabled = true;
                cpuBtn.textContent = `â³ ${testName}åŸ·è¡Œä¸­...`;
                cpuProgressDiv.style.display = 'block';
                document.getElementById('cpuResults').innerHTML = '';
                
                logStatus('cpuResults', `é–‹å§‹ ${testName} (${steps.toLocaleString()} æ­¥)...`, 'info');
                
                if (typeof AkingSPICE === 'undefined') {
                    throw new Error('AkingSPICE åº«æœªè¼‰å…¥');
                }
                
                const cpuSolver = new AkingSPICE.ExplicitStateSolver({
                    debug: false,
                    timeStep: TIME_STEP
                });
                
                const circuit = createTestCircuit();
                await cpuSolver.initialize(circuit, TIME_STEP);
                
                logStatus('cpuResults', 'âœ… CPU æ±‚è§£å™¨åˆå§‹åŒ–å®Œæˆ', 'success');
                logStatus('cpuResults', `é–‹å§‹ ${steps.toLocaleString()} æ­¥æ¨¡æ“¬...`, 'info');
                
                const batchSize = Math.min(2000, Math.max(500, Math.floor(steps / 50)));
                const totalBatches = Math.ceil(steps / batchSize);
                let completedSteps = 0;
                
                for (let batch = 0; batch < totalBatches; batch++) {
                    const batchStart = batch * batchSize;
                    const batchEnd = Math.min(batchStart + batchSize, steps);
                    
                    for (let step = batchStart; step < batchEnd; step++) {
                        cpuSolver.step();
                        completedSteps++;
                    }
                    
                    updateProgress('cpuProgressBar', completedSteps, steps);
                    
                    if (batch % Math.max(1, Math.floor(totalBatches / 10)) === 0) {
                        logStatus('cpuResults', `é€²åº¦: ${completedSteps.toLocaleString()}/${steps.toLocaleString()} (${Math.round(completedSteps/steps*100)}%)`, 'info');
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
                
                const endTime = performance.now();
                const duration = endTime - startTime;
                const stepsPerSecond = Math.round(steps / (duration / 1000));
                
                const finalResult = cpuSolver.step();
                const finalVoltage = finalResult.stateVariables?.get('C1') || 0;
                
                cpuResults = {
                    duration: duration,
                    stepsPerSecond: stepsPerSecond,
                    finalVoltage: finalVoltage,
                    totalSteps: steps
                };
                
                logStatus('cpuResults', `âœ… ${testName} å®Œæˆ!`, 'success');
                logStatus('cpuResults', `ğŸš€ CPUæ€§èƒ½: ${stepsPerSecond.toLocaleString()} æ­¥/ç§’`, 'success');
                logStatus('cpuResults', `ğŸ”‹ æœ€çµ‚é›»å®¹é›»å£“: ${finalVoltage.toFixed(6)} V`, 'success');
                
                showMetrics('cpuMetrics', cpuResults, 'CPU');
                updateComparison();
                
            } catch (error) {
                logStatus('cpuResults', `âŒ ${testName} å¤±æ•—: ${error.message}`, 'error');
                console.error('CPU Test Error:', error);
            } finally {
                cpuBtn.disabled = false;
                cpuBtn.textContent = 'ğŸ”„ åŸ·è¡Œ CPU æ¸¬è©¦';
                cpuProgressDiv.style.display = 'none';
            }
        }
        
        // GPUæ¸¬è©¦ - é«˜æ€§èƒ½ç‰ˆæœ¬
        async function runGPUTestWithSteps(steps, testName) {
            if (!gpuAvailable) {
                logStatus('gpuResults', 'âŒ GPU ä¸å¯ç”¨ï¼Œç„¡æ³•åŸ·è¡Œæ¸¬è©¦', 'error');
                return;
            }
            
            const startTime = performance.now();
            const gpuBtn = document.getElementById('gpuTestBtn');
            const gpuProgressDiv = document.getElementById('gpuProgress');
            
            try {
                gpuBtn.disabled = true;
                gpuBtn.textContent = `â³ ${testName}åŸ·è¡Œä¸­...`;
                gpuProgressDiv.style.display = 'block';
                document.getElementById('gpuResults').innerHTML = '';
                
                logStatus('gpuResults', `é–‹å§‹ ${testName} (${steps.toLocaleString()} æ­¥)...`, 'info');
                
                // å…ˆå–å¾—WebGPUè¨­å‚™
                logStatus('gpuResults', 'æ­£åœ¨åˆå§‹åŒ–WebGPUè¨­å‚™...', 'info');
                const adapter = await navigator.gpu.requestAdapter();
                const device = await adapter.requestDevice();
                
                let gpuSolver;
                try {
                    gpuSolver = new AkingSPICE.GPUExplicitStateSolver({
                        debug: false,  // å®Œå…¨é—œé–‰èª¿è©¦æ¨¡å¼
                        timeStep: TIME_STEP,
                        solverMaxIterations: 20,   // é€²ä¸€æ­¥é™ä½è¿­ä»£æ¬¡æ•¸
                        solverTolerance: 1e-4,     // é€²ä¸€æ­¥æ”¾å¯¬å®¹å¿åº¦
                        webGPUDevice: device,
                        webGPUAdapter: adapter
                    });
                    logStatus('gpuResults', 'âœ… GPU æ±‚è§£å™¨å‰µå»ºæˆåŠŸ (é«˜æ€§èƒ½æ¨¡å¼)', 'success');
                } catch (createError) {
                    logStatus('gpuResults', `âŒ GPU æ±‚è§£å™¨å‰µå»ºå¤±æ•—: ${createError.message}`, 'error');
                    throw createError;
                }
                
                const circuit = createTestCircuit();
                await gpuSolver.initialize(circuit, TIME_STEP, {
                    webGPUDevice: device,
                    webGPUAdapter: adapter
                });
                
                logStatus('gpuResults', 'âœ… GPU æ±‚è§£å™¨åˆå§‹åŒ–å®Œæˆ', 'success');
                logStatus('gpuResults', `é–‹å§‹é«˜é€Ÿ GPU æ¨¡æ“¬ (${steps.toLocaleString()} æ­¥)...`, 'info');
                
                // ä½¿ç”¨æ›´å¤§çš„æ‰¹æ¬¡ä»¥æ¸›å°‘é€²åº¦æ›´æ–°é–‹éŠ·
                const batchSize = Math.min(5000, Math.max(1000, Math.floor(steps / 20)));
                const totalBatches = Math.ceil(steps / batchSize);
                let completedSteps = 0;
                
                // æ‰¹é‡åŸ·è¡Œä»¥æ¸›å°‘åŒæ­¥é–‹éŠ·
                for (let batch = 0; batch < totalBatches; batch++) {
                    const batchStart = batch * batchSize;
                    const batchEnd = Math.min(batchStart + batchSize, steps);
                    
                    // é€£çºŒåŸ·è¡Œä¸€æ‰¹æ­¥é©Ÿï¼Œæ¸›å°‘ä¸­é–“åŒæ­¥
                    const batchStartTime = performance.now();
                    for (let step = batchStart; step < batchEnd; step++) {
                        await gpuSolver.step();
                        completedSteps++;
                    }
                    const batchEndTime = performance.now();
                    
                    updateProgress('gpuProgressBar', completedSteps, steps);
                    
                    // åªåœ¨é—œéµç¯€é»é¡¯ç¤ºé€²åº¦ä»¥æ¸›å°‘æ—¥èªŒé–‹éŠ·
                    if (batch % Math.max(1, Math.floor(totalBatches / 5)) === 0) {
                        const batchStepsPerSec = Math.round((batchEnd - batchStart) / ((batchEndTime - batchStartTime) / 1000));
                        logStatus('gpuResults', `æ‰¹æ¬¡ ${batch + 1}/${totalBatches}: ${batchStepsPerSec.toLocaleString()} æ­¥/ç§’`, 'info');
                    }
                    
                    // æ¸›å°‘ä¸å¿…è¦çš„ç•°æ­¥ç­‰å¾…
                    if (batch % 4 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }
                
                const endTime = performance.now();
                const duration = endTime - startTime;
                const stepsPerSecond = Math.round(steps / (duration / 1000));
                
                const finalResult = await gpuSolver.step();
                const finalVoltage = finalResult.stateVariables?.get('C1') || 0;
                
                gpuResults = {
                    duration: duration,
                    stepsPerSecond: stepsPerSecond,
                    finalVoltage: finalVoltage,
                    totalSteps: steps
                };
                
                logStatus('gpuResults', `âœ… ${testName} å®Œæˆ!`, 'success');
                logStatus('gpuResults', `ğŸš€ GPUæ€§èƒ½: ${stepsPerSecond.toLocaleString()} æ­¥/ç§’`, 'success');
                logStatus('gpuResults', `ğŸ”‹ æœ€çµ‚é›»å®¹é›»å£“: ${finalVoltage.toFixed(6)} V`, 'success');
                
                showMetrics('gpuMetrics', gpuResults, 'GPU');
                updateComparison();
                
            } catch (error) {
                logStatus('gpuResults', `âŒ ${testName} å¤±æ•—: ${error.message}`, 'error');
                console.error('GPU Test Error:', error);
            } finally {
                gpuBtn.disabled = false;
                gpuBtn.textContent = 'ğŸš€ åŸ·è¡Œ GPU æ¸¬è©¦';
                gpuProgressDiv.style.display = 'none';
            }
        }
        
        // æ›´æ–°æ¯”è¼ƒçµæœ
        function updateComparison() {
            if (!cpuResults || !gpuResults) return;
            
            const comparisonSection = document.getElementById('comparisonSection');
            const comparisonMetrics = document.getElementById('comparisonMetrics');
            
            const speedRatio = gpuResults.stepsPerSecond / cpuResults.stepsPerSecond;
            const timeRatio = cpuResults.duration / gpuResults.duration;
            const voltageError = Math.abs((gpuResults.finalVoltage - cpuResults.finalVoltage) / cpuResults.finalVoltage * 100);
            const winner = speedRatio > 1 ? 'GPU' : 'CPU';
            const advantage = speedRatio > 1 ? speedRatio.toFixed(2) : (1/speedRatio).toFixed(2);
            
            comparisonMetrics.innerHTML = `
                <div class="metric">
                    <div class="metric-value">${cpuResults.stepsPerSecond.toLocaleString()}</div>
                    <div class="metric-label">CPU æ­¥/ç§’</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${gpuResults.stepsPerSecond.toLocaleString()}</div>
                    <div class="metric-label">GPU æ­¥/ç§’</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${winner} ${advantage}x</div>
                    <div class="metric-label">æ€§èƒ½å„ªå‹¢</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${voltageError.toFixed(4)}%</div>
                    <div class="metric-label">ç²¾åº¦èª¤å·®</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${cpuResults.duration.toFixed(1)} ms</div>
                    <div class="metric-label">CPU è€—æ™‚</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${gpuResults.duration.toFixed(1)} ms</div>
                    <div class="metric-label">GPU è€—æ™‚</div>
                </div>
            `;
            
            comparisonSection.style.display = 'block';
        }
        
        // è¨ºæ–· AkingSPICE åº«çµæ§‹
        function diagnoseAkingSPICE() {
            console.log('=== AkingSPICE è¨ºæ–·å ±å‘Š ===');
            console.log('typeof AkingSPICE:', typeof AkingSPICE);
            console.log('AkingSPICE å¯ç”¨å±¬æ€§:', Object.keys(AkingSPICE));
            
            if (AkingSPICE.GPUExplicitStateSolver) {
                console.log('GPUExplicitStateSolver å­˜åœ¨');
                console.log('GPUExplicitStateSolver prototype:', Object.getOwnPropertyNames(AkingSPICE.GPUExplicitStateSolver.prototype));
            } else {
                console.log('âŒ GPUExplicitStateSolver ä¸å­˜åœ¨');
            }
            
            // æª¢æŸ¥æ˜¯å¦æœ‰å…¶ä»–ç›¸é—œçš„ GPU é¡
            const gpuRelated = Object.keys(AkingSPICE).filter(key => key.toLowerCase().includes('gpu'));
            console.log('GPU ç›¸é—œå±¬æ€§:', gpuRelated);
            
            console.log('=== è¨ºæ–·å ±å‘ŠçµæŸ ===');
        }
        
        // æª¢æŸ¥GPUæ”¯æ´
        async function checkGPUSupport() {
            try {
                logStatus('gpuResults', 'æª¢æŸ¥ GPU æ”¯æ´ç‹€æ…‹...', 'info');
                
                // é‹è¡Œè¨ºæ–·
                diagnoseAkingSPICE();
                
                // é¦–å…ˆæª¢æŸ¥ç€è¦½å™¨WebGPUæ”¯æ´
                if (!navigator.gpu) {
                    throw new Error('ç€è¦½å™¨ä¸æ”¯æ´ WebGPU API');
                }
                
                logStatus('gpuResults', 'âœ… ç€è¦½å™¨æ”¯æ´ WebGPU API', 'success');
                
                // å˜—è©¦è«‹æ±‚ WebGPU é©é…å™¨
                logStatus('gpuResults', 'æ­£åœ¨è«‹æ±‚ WebGPU é©é…å™¨...', 'info');
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    throw new Error('ç„¡æ³•å–å¾— WebGPU é©é…å™¨ - å¯èƒ½ç¡¬é«”ä¸æ”¯æ´');
                }
                
                logStatus('gpuResults', 'âœ… WebGPU é©é…å™¨å–å¾—æˆåŠŸ', 'success');
                logStatus('gpuResults', `GPU è³‡è¨Š: ${adapter.info?.vendor || 'Unknown'} ${adapter.info?.device || ''}`, 'info');
                
                // å˜—è©¦è«‹æ±‚ WebGPU è¨­å‚™
                logStatus('gpuResults', 'æ­£åœ¨è«‹æ±‚ WebGPU è¨­å‚™...', 'info');
                const device = await adapter.requestDevice();
                if (!device) {
                    throw new Error('ç„¡æ³•å–å¾— WebGPU è¨­å‚™');
                }
                
                logStatus('gpuResults', 'âœ… WebGPU è¨­å‚™å–å¾—æˆåŠŸ', 'success');
                
                // æª¢æŸ¥ AkingSPICE GPU æ±‚è§£å™¨
                if (!AkingSPICE.GPUExplicitStateSolver) {
                    throw new Error('GPUExplicitStateSolver é¡ä¸å¯ç”¨');
                }
                
                logStatus('gpuResults', 'âœ… GPU æ±‚è§£å™¨é¡å¯ç”¨', 'success');
                
                // è¨ºæ–·ï¼šæª¢æŸ¥ AkingSPICE åº«çš„å…§éƒ¨çµæ§‹
                logStatus('gpuResults', 'ğŸ” è¨ºæ–·ï¼šæª¢æŸ¥ AkingSPICE å…§éƒ¨çµæ§‹...', 'info');
                console.log('AkingSPICE.GPUExplicitStateSolver:', AkingSPICE.GPUExplicitStateSolver);
                console.log('AkingSPICE keys:', Object.keys(AkingSPICE));
                
                // å˜—è©¦å‰µå»ºGPUæ±‚è§£å™¨å¯¦ä¾‹ï¼Œä¸¦å‚³éWebGPUè¨­å‚™
                logStatus('gpuResults', 'æ­£åœ¨å‰µå»º GPU æ±‚è§£å™¨å¯¦ä¾‹...', 'info');
                let testSolver;
                try {
                    testSolver = new AkingSPICE.GPUExplicitStateSolver({
                        debug: true,  // å•Ÿç”¨èª¿è©¦æ¨¡å¼
                        timeStep: TIME_STEP,
                        webGPUDevice: device,  // æ˜ç¢ºå‚³éWebGPUè¨­å‚™
                        webGPUAdapter: adapter  // æ˜ç¢ºå‚³éWebGPUé©é…å™¨
                    });
                    logStatus('gpuResults', 'âœ… GPU æ±‚è§£å™¨å¯¦ä¾‹å‰µå»ºæˆåŠŸ', 'success');
                } catch (createError) {
                    logStatus('gpuResults', `âŒ GPU æ±‚è§£å™¨å‰µå»ºå¤±æ•—: ${createError.message}`, 'error');
                    console.error('Solver creation error:', createError);
                    throw createError;
                }
                
                logStatus('gpuResults', 'æ­£åœ¨åˆå§‹åŒ– GPU æ±‚è§£å™¨...', 'info');
                
                // è¨ºæ–·ï¼šåœ¨åˆå§‹åŒ–å‰æª¢æŸ¥ä¸€äº›é—œéµå±¬æ€§
                console.log('testSolver å±¬æ€§:', Object.getOwnPropertyNames(testSolver));
                if (testSolver.webgpuSolver) {
                    console.log('webgpuSolver å­˜åœ¨:', testSolver.webgpuSolver);
                } else {
                    console.log('webgpuSolver ä¸å­˜åœ¨');
                }
                
                // å˜—è©¦åˆå§‹åŒ–ï¼ˆé€™æœƒè§¸ç™¼WebGPUæª¢æŸ¥ï¼‰
                const testCircuit = createTestCircuit();
                try {
                    // åœ¨ initialize æ™‚å†æ¬¡å‚³é WebGPU è¨­å‚™é¸é …
                    await testSolver.initialize(testCircuit, TIME_STEP, {
                        webGPUDevice: device,
                        webGPUAdapter: adapter
                    });
                } catch (initError) {
                    logStatus('gpuResults', `âŒ åˆå§‹åŒ–è©³ç´°éŒ¯èª¤: ${initError.message}`, 'error');
                    console.error('è©³ç´°éŒ¯èª¤å †ç–Š:', initError.stack);
                    throw initError;
                }
                
                gpuAvailable = true;
                document.getElementById('gpuStatus').innerHTML = 'âœ… GPU åŠ é€Ÿå¯ç”¨ - WebGPU åˆå§‹åŒ–æˆåŠŸ';
                document.getElementById('gpuTestBtn').disabled = false;
                document.getElementById('gpuSmallBtn').disabled = false;
                document.getElementById('gpuMicroBtn').disabled = false;
                logStatus('gpuResults', 'ğŸ‰ GPU æ”¯æ´æª¢æŸ¥å®Œæˆ - å¯ä»¥é–‹å§‹æ¸¬è©¦ï¼', 'success');
                logStatus('gpuResults', 'ğŸš€ WebGPU è¨­å‚™åˆå§‹åŒ–æˆåŠŸ', 'success');
                
            } catch (error) {
                // å¦‚æœå‚³éWebGPUè¨­å‚™å¤±æ•—ï¼Œå˜—è©¦è®“æ±‚è§£å™¨è‡ªå·±åˆå§‹åŒ–
                if (error.message.includes('create') || error.message.includes('undefined')) {
                    try {
                        logStatus('gpuResults', 'ğŸ”„ å˜—è©¦å‚™ç”¨åˆå§‹åŒ–æ–¹æ³•...', 'warning');
                        
                        const fallbackSolver = new AkingSPICE.GPUExplicitStateSolver({
                            debug: true,
                            timeStep: TIME_STEP
                        });
                        
                        const testCircuit = createTestCircuit();
                        await fallbackSolver.initialize(testCircuit, TIME_STEP);
                        
                        gpuAvailable = true;
                        document.getElementById('gpuStatus').innerHTML = 'âœ… GPU åŠ é€Ÿå¯ç”¨ - å‚™ç”¨æ–¹æ³•åˆå§‹åŒ–æˆåŠŸ';
                        document.getElementById('gpuTestBtn').disabled = false;
                        document.getElementById('gpuSmallBtn').disabled = false;
                        document.getElementById('gpuMicroBtn').disabled = false;
                        logStatus('gpuResults', 'ğŸ‰ å‚™ç”¨åˆå§‹åŒ–æˆåŠŸ - å¯ä»¥é–‹å§‹æ¸¬è©¦ï¼', 'success');
                        return;
                        
                    } catch (fallbackError) {
                        logStatus('gpuResults', `âŒ å‚™ç”¨åˆå§‹åŒ–ä¹Ÿå¤±æ•—: ${fallbackError.message}`, 'error');
                    }
                }
                
                gpuAvailable = false;
                document.getElementById('gpuStatus').innerHTML = `âŒ GPU ä¸å¯ç”¨: ${error.message}`;
                document.getElementById('gpuTestBtn').disabled = true;
                document.getElementById('gpuSmallBtn').disabled = true;
                document.getElementById('gpuMicroBtn').disabled = true;
                logStatus('gpuResults', `âŒ GPU æª¢æŸ¥å¤±æ•—: ${error.message}`, 'error');
                
                // è©³ç´°éŒ¯èª¤ä¿¡æ¯å’Œå»ºè­°
                if (error.message.includes('create') || error.message.includes('undefined')) {
                    logStatus('gpuResults', 'ğŸ’¡ WebGPU API ç›¸å®¹æ€§å•é¡Œ:', 'warning');
                    logStatus('gpuResults', '  â€¢ å¯èƒ½æ˜¯AkingSPICEç‰ˆæœ¬èˆ‡WebGPU APIä¸ç›¸å®¹', 'warning');
                    logStatus('gpuResults', '  â€¢ å˜—è©¦æ›´æ–°AkingSPICEåº«åˆ°æœ€æ–°ç‰ˆæœ¬', 'warning');
                    logStatus('gpuResults', '  â€¢ æˆ–ä½¿ç”¨CPUæ¨¡å¼é€²è¡Œæ¸¬è©¦', 'warning');
                } else if (error.message.includes('é©é…å™¨') || error.message.includes('adapter')) {
                    logStatus('gpuResults', 'ğŸ’¡ WebGPU é©é…å™¨å•é¡Œå¯èƒ½åŸå› :', 'warning');
                    logStatus('gpuResults', '  â€¢ é¡¯å¡é©…å‹•ç¨‹å¼éèˆŠ (è«‹æ›´æ–°åˆ°æœ€æ–°ç‰ˆ)', 'warning');
                    logStatus('gpuResults', '  â€¢ é¡¯å¡ä¸æ”¯æ´ WebGPU (éœ€ D3D12 æˆ– Vulkan)', 'warning');
                    logStatus('gpuResults', '  â€¢ Windows ç‰ˆæœ¬éèˆŠ (å»ºè­° Windows 10 20H1+)', 'warning');
                } else if (error.message.includes('è¨­å‚™') || error.message.includes('device')) {
                    logStatus('gpuResults', 'ğŸ’¡ WebGPU è¨­å‚™å•é¡Œå¯èƒ½åŸå› :', 'warning');
                    logStatus('gpuResults', '  â€¢ GPU è¨˜æ†¶é«”ä¸è¶³', 'warning');
                    logStatus('gpuResults', '  â€¢ å…¶ä»–æ‡‰ç”¨ç¨‹å¼ä½”ç”¨ GPU', 'warning');
                } else if (error.message.includes('WebGPU') || error.message.includes('ä¸æ”¯æ´')) {
                    logStatus('gpuResults', 'ğŸ’¡ Chrome WebGPU å•Ÿç”¨æª¢æŸ¥:', 'warning');
                    logStatus('gpuResults', '  â€¢ å‰å¾€ chrome://flags/', 'warning');
                    logStatus('gpuResults', '  â€¢ æœå°‹ "webgpu" ä¸¦å•Ÿç”¨', 'warning');
                    logStatus('gpuResults', '  â€¢ é‡æ–°å•Ÿå‹•ç€è¦½å™¨', 'warning');
                } else {
                    logStatus('gpuResults', 'ğŸ’¡ ä¸€èˆ¬æ•…éšœæ’é™¤:', 'warning');
                    logStatus('gpuResults', '  â€¢ æª¢æŸ¥ chrome://gpu/ é é¢', 'warning');
                    logStatus('gpuResults', '  â€¢ ç¢ºèª WebGPU ç‹€æ…‹ç‚º "å¯ç”¨"', 'warning');
                    logStatus('gpuResults', '  â€¢ å˜—è©¦é‡æ–°è¼‰å…¥é é¢', 'warning');
                }
            }
        }
        
        // æ€§èƒ½åˆ†æå‡½æ•¸
        async function analyzeGPUPerformance() {
            logStatus('gpuResults', 'ğŸ”¬ é–‹å§‹ GPU æ€§èƒ½åˆ†æ...', 'info');
            
            const testConfigs = [
                { maxIter: 10, tol: 1e-3, name: 'è¶…é«˜é€Ÿæ¨¡å¼' },
                { maxIter: 20, tol: 1e-4, name: 'é«˜é€Ÿæ¨¡å¼' },
                { maxIter: 50, tol: 1e-6, name: 'å¹³è¡¡æ¨¡å¼' },
                { maxIter: 100, tol: 1e-8, name: 'ç²¾ç¢ºæ¨¡å¼' }
            ];
            
            for (const config of testConfigs) {
                const startTime = performance.now();
                
                try {
                    const adapter = await navigator.gpu.requestAdapter();
                    const device = await adapter.requestDevice();
                    
                    const solver = new AkingSPICE.GPUExplicitStateSolver({
                        debug: false,
                        timeStep: TIME_STEP,
                        solverMaxIterations: config.maxIter,
                        solverTolerance: config.tol,
                        webGPUDevice: device,
                        webGPUAdapter: adapter
                    });
                    
                    const circuit = createTestCircuit();
                    await solver.initialize(circuit, TIME_STEP, {
                        webGPUDevice: device,
                        webGPUAdapter: adapter
                    });
                    
                    // åŸ·è¡Œ 10 æ­¥æ¸¬è©¦
                    for (let i = 0; i < 10; i++) {
                        await solver.step();
                    }
                    
                    const endTime = performance.now();
                    const timePerStep = (endTime - startTime) / 10;
                    const stepsPerSec = 1000 / timePerStep;
                    
                    logStatus('gpuResults', `${config.name}: ${stepsPerSec.toFixed(0)} æ­¥/ç§’ (${config.maxIter}æ¬¡è¿­ä»£, ${config.tol}å®¹å¿åº¦)`, 'info');
                    
                } catch (error) {
                    logStatus('gpuResults', `${config.name} å¤±æ•—: ${error.message}`, 'error');
                }
            }
        }
        
        // æ¸¬è©¦å‡½æ•¸
        async function runCPUTest() { await runCPUTestWithSteps(TEST_STEPS, 'CPUå¤§è¦æ¨¡æ¸¬è©¦'); }
        async function runSmallCPUTest() { await runCPUTestWithSteps(SMALL_TEST_STEPS, 'CPUå¿«é€Ÿæ¸¬è©¦'); }
        async function runGPUTest() { await runGPUTestWithSteps(TEST_STEPS, 'GPUå¤§è¦æ¨¡æ¸¬è©¦'); }
        async function runSmallGPUTest() { await runGPUTestWithSteps(SMALL_TEST_STEPS, 'GPUå¿«é€Ÿæ¸¬è©¦'); }
        async function runMicroGPUTest() { await runGPUTestWithSteps(1000, 'GPUæ¥µé€Ÿæ¸¬è©¦'); }
        
        // åŒæ™‚åŸ·è¡Œå…©é …æ¸¬è©¦
        async function runBothTests() {
            const runBothBtn = document.getElementById('runBothBtn');
            runBothBtn.disabled = true;
            runBothBtn.textContent = 'â³ åŒæ™‚åŸ·è¡Œä¸­...';
            
            try {
                if (gpuAvailable) {
                    await Promise.all([runCPUTest(), runGPUTest()]);
                } else {
                    logStatus('cpuResults', 'âš ï¸ GPUä¸å¯ç”¨ï¼Œåƒ…åŸ·è¡ŒCPUæ¸¬è©¦', 'warning');
                    await runCPUTest();
                }
            } finally {
                runBothBtn.disabled = false;
                runBothBtn.textContent = 'ğŸ”¥ åŒæ™‚åŸ·è¡Œ CPU & GPU æ¸¬è©¦';
            }
        }
        
        // é‡ç½®æ¸¬è©¦
        function resetTests() {
            cpuResults = null;
            gpuResults = null;
            document.getElementById('cpuResults').innerHTML = 'ç­‰å¾…æ¸¬è©¦...';
            document.getElementById('gpuResults').innerHTML = 'ç­‰å¾…GPUæª¢æŸ¥...';
            document.getElementById('cpuMetrics').style.display = 'none';
            document.getElementById('gpuMetrics').style.display = 'none';
            document.getElementById('comparisonSection').style.display = 'none';
            
            // é‡æ–°æª¢æŸ¥GPU
            checkGPUSupport();
        }
        
        // æª¢æ¸¬ç€è¦½å™¨WebGPUåŸºæœ¬æ”¯æ´
        function detectWebGPUSupport() {
            const status = document.getElementById('gpuStatus');
            
            if (!navigator.gpu) {
                status.innerHTML = 'âŒ ç€è¦½å™¨ä¸æ”¯æ´ WebGPU';
                logStatus('gpuResults', 'âŒ navigator.gpu ä¸å­˜åœ¨', 'error');
                logStatus('gpuResults', 'ğŸ’¡ è«‹ä½¿ç”¨æ”¯æ´ WebGPU çš„ç€è¦½å™¨', 'warning');
                return false;
            }
            
            status.innerHTML = 'ğŸ” ç€è¦½å™¨æ”¯æ´ WebGPUï¼Œæ­£åœ¨æª¢æŸ¥ GPU è¨­å‚™...';
            logStatus('gpuResults', 'âœ… navigator.gpu å¯ç”¨', 'success');
            return true;
        }
        
        // é é¢è¼‰å…¥å®Œæˆå¾Œåˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ğŸš€ AkingSPICE CPU vs GPU æ¸¬è©¦é é¢è¼‰å…¥å®Œæˆ');
            
            // ç«‹å³æª¢æŸ¥WebGPUåŸºæœ¬æ”¯æ´
            const hasWebGPU = detectWebGPUSupport();
            
            setTimeout(() => {
                if (typeof AkingSPICE !== 'undefined') {
                    console.log('âœ… AkingSPICE åº«è¼‰å…¥æˆåŠŸ');
                    logStatus('cpuResults', 'ğŸ‰ AkingSPICE åº«è¼‰å…¥å®Œæˆï¼', 'success');
                    
                    // æª¢æŸ¥CPUçµ„ä»¶
                    const cpuComponents = ['ExplicitStateSolver', 'VoltageSource', 'Resistor', 'Capacitor'];
                    const cpuMissing = cpuComponents.filter(comp => !AkingSPICE[comp]);
                    if (cpuMissing.length === 0) {
                        logStatus('cpuResults', 'âœ… CPU æ±‚è§£å™¨çµ„ä»¶å®Œæ•´ï¼Œå¯ä»¥é–‹å§‹æ¸¬è©¦ï¼', 'success');
                    } else {
                        logStatus('cpuResults', `âŒ ç¼ºå°‘CPUçµ„ä»¶: ${cpuMissing.join(', ')}`, 'error');
                    }
                    
                    // æª¢æŸ¥GPUæ”¯æ´ï¼ˆåªæœ‰åœ¨æœ‰WebGPUæ™‚æ‰é€²è¡Œï¼‰
                    if (hasWebGPU) {
                        checkGPUSupport();
                    } else {
                        logStatus('gpuResults', 'âš ï¸ è·³éGPUæ¸¬è©¦ - WebGPUä¸å¯ç”¨', 'warning');
                    }
                } else {
                    logStatus('cpuResults', 'âŒ AkingSPICE åº«è¼‰å…¥å¤±æ•—', 'error');
                    logStatus('gpuResults', 'âŒ AkingSPICE åº«è¼‰å…¥å¤±æ•—', 'error');
                }
            }, 1000);
        });
    </script>
</body>
</html>