<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>🚀 AkingSPICE - CPU vs GPU 完整性能測試</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; 
            margin: 20px; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 0;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        h1 { 
            color: #333; 
            text-align: center; 
            margin-bottom: 30px;
        }
        .test-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        .test-panel {
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            color: white;
        }
        .cpu-panel {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        .gpu-panel {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }
        .circuit-info {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #007bff;
            grid-column: 1 / -1;
        }
        button { 
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white; 
            border: none; 
            padding: 12px 25px; 
            border-radius: 8px; 
            cursor: pointer; 
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 8px;
            min-width: 180px;
        }
        button:hover:not(:disabled) { 
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        button:disabled { 
            background: #aaa; 
            cursor: not-allowed; 
            transform: none;
        }
        .results {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255,255,255,0.8);
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            max-height: 350px;
            overflow-y: auto;
        }
        .status {
            padding: 8px;
            margin: 8px 0;
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.9em;
        }
        .status.info { background: #d1ecf1; color: #0c5460; }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.warning { background: #fff3cd; color: #856404; }
        .progress {
            width: 100%;
            height: 22px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            transition: width 0.3s ease;
            text-align: center;
            line-height: 22px;
            color: white;
            font-weight: bold;
            font-size: 0.85em;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 12px;
            margin-top: 15px;
        }
        .metric {
            background: white;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .metric-value {
            font-size: 1.3em;
            font-weight: bold;
            color: #007bff;
        }
        .metric-label {
            font-size: 0.8em;
            color: #666;
            margin-top: 3px;
        }
        .comparison-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            display: none;
        }
        .comparison-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .gpu-status {
            background: rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }
        .control-buttons {
            text-align: center;
            margin-top: 20px;
        }
        .control-buttons button {
            margin: 10px;
            min-width: 250px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🚀 AkingSPICE - CPU vs GPU 完整性能測試</h1>
        
        <div class="test-grid">
            <div class="circuit-info">
                <h3>📋 測試電路：簡單RC電路</h3>
                <p><strong>組件：</strong>電壓源 5V，電阻 10Ω，電容 1μF</p>
                <p><strong>時間步長：</strong>10ns &nbsp;|&nbsp; <strong>測試步數：</strong>100,000 步 (1ms 模擬時間)</p>
                <p><strong>預期結果：</strong>電容充電曲線，最終電壓趨近 5V</p>
            </div>

            <div class="cpu-panel">
                <h3>💻 CPU 測試</h3>
                <button id="cpuTestBtn" onclick="runCPUTest()">🔄 執行 CPU 測試</button>
                <button onclick="runSmallCPUTest()">🔄 快速測試 (1萬步)</button>
                <div class="progress" id="cpuProgress" style="display:none;">
                    <div class="progress-bar" id="cpuProgressBar">0%</div>
                </div>
                <div class="results" id="cpuResults">等待測試...</div>
                <div class="metrics" id="cpuMetrics" style="display:none;"></div>
            </div>
            
            <div class="gpu-panel">
                <h3>⚡ GPU 測試</h3>
                <div class="gpu-status" id="gpuStatus">🔍 檢查 GPU 支援...</div>
                <button id="gpuTestBtn" onclick="runGPUTest()" disabled>🚀 執行 GPU 測試 (10萬步)</button>
                <button onclick="runSmallGPUTest()" disabled id="gpuSmallBtn">🚀 快速測試 (1萬步)</button>
                <button onclick="runMicroGPUTest()" disabled id="gpuMicroBtn">⚡ 極速測試 (1000步)</button>
                <div class="progress" id="gpuProgress" style="display:none;">
                    <div class="progress-bar" id="gpuProgressBar">0%</div>
                </div>
                <div class="results" id="gpuResults">等待GPU檢查...</div>
                <div class="metrics" id="gpuMetrics" style="display:none;"></div>
            </div>
        </div>

        <div class="comparison-section" id="comparisonSection">
            <h3>📊 CPU vs GPU 性能比較</h3>
            <div class="comparison-metrics" id="comparisonMetrics"></div>
        </div>
        
        <div class="control-buttons">
            <button onclick="runBothTests()" id="runBothBtn">🔥 同時執行 CPU & GPU 測試</button>
            <button onclick="analyzeGPUPerformance()" id="analyzeBtn">🔬 GPU 性能分析</button>
            <button onclick="resetTests()">🔄 重置所有測試</button>
        </div>
    </div>

    <!-- 載入本地編譯的 AkingSPICE 庫 -->
    <script src="https://keepmy.link/6cc06b23"></script>
    
    <script>
        // 全局狀態
        let cpuResults = null;
        let gpuResults = null;
        let gpuAvailable = false;
        
        // 測試參數
        const TEST_STEPS = 100000;  // 10萬步
        const SMALL_TEST_STEPS = 10000;  // 1萬步
        const TIME_STEP = 10e-9;    // 10ns
        
        // 創建測試電路組件
        function createTestCircuit() {
            try {
                if (!AkingSPICE.VoltageSource || !AkingSPICE.Resistor || !AkingSPICE.Capacitor) {
                    throw new Error('AkingSPICE 組件類不可用');
                }
                
                const components = [
                    new AkingSPICE.VoltageSource('V1', ['vin', 'gnd'], 5.0),
                    new AkingSPICE.Resistor('R1', ['vin', 'vout'], 10),
                    new AkingSPICE.Capacitor('C1', ['vout', 'gnd'], 1e-6)
                ];
                
                return components;
            } catch (error) {
                throw new Error(`組件創建失敗: ${error.message}`);
            }
        }
        
        // 記錄狀態
        function logStatus(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            const statusDiv = document.createElement('div');
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
            element.appendChild(statusDiv);
            element.scrollTop = element.scrollHeight;
        }
        
        // 更新進度條
        function updateProgress(progressId, current, total) {
            const progressBar = document.getElementById(progressId);
            const percentage = Math.round((current / total) * 100);
            progressBar.style.width = `${percentage}%`;
            progressBar.textContent = `${percentage}%`;
        }
        
        // 顯示測試結果指標
        function showMetrics(metricsId, results, testType) {
            const metricsDiv = document.getElementById(metricsId);
            const finalTime = results.totalSteps * TIME_STEP * 1000; // ms
            const efficiency = (results.stepsPerSecond / 1000).toFixed(1); // K步/秒
            
            metricsDiv.innerHTML = `
                <div class="metric">
                    <div class="metric-value">${results.totalSteps.toLocaleString()}</div>
                    <div class="metric-label">步數</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${results.duration.toFixed(1)}</div>
                    <div class="metric-label">時間(ms)</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${efficiency}K</div>
                    <div class="metric-label">步/秒</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${results.finalVoltage.toFixed(4)}</div>
                    <div class="metric-label">最終電壓(V)</div>
                </div>
            `;
            metricsDiv.style.display = 'grid';
        }
        
        // CPU測試 - 通用函數
        async function runCPUTestWithSteps(steps, testName) {
            const startTime = performance.now();
            const cpuBtn = document.getElementById('cpuTestBtn');
            const cpuProgressDiv = document.getElementById('cpuProgress');
            
            try {
                cpuBtn.disabled = true;
                cpuBtn.textContent = `⏳ ${testName}執行中...`;
                cpuProgressDiv.style.display = 'block';
                document.getElementById('cpuResults').innerHTML = '';
                
                logStatus('cpuResults', `開始 ${testName} (${steps.toLocaleString()} 步)...`, 'info');
                
                if (typeof AkingSPICE === 'undefined') {
                    throw new Error('AkingSPICE 庫未載入');
                }
                
                const cpuSolver = new AkingSPICE.ExplicitStateSolver({
                    debug: false,
                    timeStep: TIME_STEP
                });
                
                const circuit = createTestCircuit();
                await cpuSolver.initialize(circuit, TIME_STEP);
                
                logStatus('cpuResults', '✅ CPU 求解器初始化完成', 'success');
                logStatus('cpuResults', `開始 ${steps.toLocaleString()} 步模擬...`, 'info');
                
                const batchSize = Math.min(2000, Math.max(500, Math.floor(steps / 50)));
                const totalBatches = Math.ceil(steps / batchSize);
                let completedSteps = 0;
                
                for (let batch = 0; batch < totalBatches; batch++) {
                    const batchStart = batch * batchSize;
                    const batchEnd = Math.min(batchStart + batchSize, steps);
                    
                    for (let step = batchStart; step < batchEnd; step++) {
                        cpuSolver.step();
                        completedSteps++;
                    }
                    
                    updateProgress('cpuProgressBar', completedSteps, steps);
                    
                    if (batch % Math.max(1, Math.floor(totalBatches / 10)) === 0) {
                        logStatus('cpuResults', `進度: ${completedSteps.toLocaleString()}/${steps.toLocaleString()} (${Math.round(completedSteps/steps*100)}%)`, 'info');
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
                
                const endTime = performance.now();
                const duration = endTime - startTime;
                const stepsPerSecond = Math.round(steps / (duration / 1000));
                
                const finalResult = cpuSolver.step();
                const finalVoltage = finalResult.stateVariables?.get('C1') || 0;
                
                cpuResults = {
                    duration: duration,
                    stepsPerSecond: stepsPerSecond,
                    finalVoltage: finalVoltage,
                    totalSteps: steps
                };
                
                logStatus('cpuResults', `✅ ${testName} 完成!`, 'success');
                logStatus('cpuResults', `🚀 CPU性能: ${stepsPerSecond.toLocaleString()} 步/秒`, 'success');
                logStatus('cpuResults', `🔋 最終電容電壓: ${finalVoltage.toFixed(6)} V`, 'success');
                
                showMetrics('cpuMetrics', cpuResults, 'CPU');
                updateComparison();
                
            } catch (error) {
                logStatus('cpuResults', `❌ ${testName} 失敗: ${error.message}`, 'error');
                console.error('CPU Test Error:', error);
            } finally {
                cpuBtn.disabled = false;
                cpuBtn.textContent = '🔄 執行 CPU 測試';
                cpuProgressDiv.style.display = 'none';
            }
        }
        
        // GPU測試 - 高性能版本
        async function runGPUTestWithSteps(steps, testName) {
            if (!gpuAvailable) {
                logStatus('gpuResults', '❌ GPU 不可用，無法執行測試', 'error');
                return;
            }
            
            const startTime = performance.now();
            const gpuBtn = document.getElementById('gpuTestBtn');
            const gpuProgressDiv = document.getElementById('gpuProgress');
            
            try {
                gpuBtn.disabled = true;
                gpuBtn.textContent = `⏳ ${testName}執行中...`;
                gpuProgressDiv.style.display = 'block';
                document.getElementById('gpuResults').innerHTML = '';
                
                logStatus('gpuResults', `開始 ${testName} (${steps.toLocaleString()} 步)...`, 'info');
                
                // 先取得WebGPU設備
                logStatus('gpuResults', '正在初始化WebGPU設備...', 'info');
                const adapter = await navigator.gpu.requestAdapter();
                const device = await adapter.requestDevice();
                
                let gpuSolver;
                try {
                    gpuSolver = new AkingSPICE.GPUExplicitStateSolver({
                        debug: false,  // 完全關閉調試模式
                        timeStep: TIME_STEP,
                        solverMaxIterations: 20,   // 進一步降低迭代次數
                        solverTolerance: 1e-4,     // 進一步放寬容忍度
                        webGPUDevice: device,
                        webGPUAdapter: adapter
                    });
                    logStatus('gpuResults', '✅ GPU 求解器創建成功 (高性能模式)', 'success');
                } catch (createError) {
                    logStatus('gpuResults', `❌ GPU 求解器創建失敗: ${createError.message}`, 'error');
                    throw createError;
                }
                
                const circuit = createTestCircuit();
                await gpuSolver.initialize(circuit, TIME_STEP, {
                    webGPUDevice: device,
                    webGPUAdapter: adapter
                });
                
                logStatus('gpuResults', '✅ GPU 求解器初始化完成', 'success');
                logStatus('gpuResults', `開始高速 GPU 模擬 (${steps.toLocaleString()} 步)...`, 'info');
                
                // 使用更大的批次以減少進度更新開銷
                const batchSize = Math.min(5000, Math.max(1000, Math.floor(steps / 20)));
                const totalBatches = Math.ceil(steps / batchSize);
                let completedSteps = 0;
                
                // 批量執行以減少同步開銷
                for (let batch = 0; batch < totalBatches; batch++) {
                    const batchStart = batch * batchSize;
                    const batchEnd = Math.min(batchStart + batchSize, steps);
                    
                    // 連續執行一批步驟，減少中間同步
                    const batchStartTime = performance.now();
                    for (let step = batchStart; step < batchEnd; step++) {
                        await gpuSolver.step();
                        completedSteps++;
                    }
                    const batchEndTime = performance.now();
                    
                    updateProgress('gpuProgressBar', completedSteps, steps);
                    
                    // 只在關鍵節點顯示進度以減少日誌開銷
                    if (batch % Math.max(1, Math.floor(totalBatches / 5)) === 0) {
                        const batchStepsPerSec = Math.round((batchEnd - batchStart) / ((batchEndTime - batchStartTime) / 1000));
                        logStatus('gpuResults', `批次 ${batch + 1}/${totalBatches}: ${batchStepsPerSec.toLocaleString()} 步/秒`, 'info');
                    }
                    
                    // 減少不必要的異步等待
                    if (batch % 4 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }
                
                const endTime = performance.now();
                const duration = endTime - startTime;
                const stepsPerSecond = Math.round(steps / (duration / 1000));
                
                const finalResult = await gpuSolver.step();
                const finalVoltage = finalResult.stateVariables?.get('C1') || 0;
                
                gpuResults = {
                    duration: duration,
                    stepsPerSecond: stepsPerSecond,
                    finalVoltage: finalVoltage,
                    totalSteps: steps
                };
                
                logStatus('gpuResults', `✅ ${testName} 完成!`, 'success');
                logStatus('gpuResults', `🚀 GPU性能: ${stepsPerSecond.toLocaleString()} 步/秒`, 'success');
                logStatus('gpuResults', `🔋 最終電容電壓: ${finalVoltage.toFixed(6)} V`, 'success');
                
                showMetrics('gpuMetrics', gpuResults, 'GPU');
                updateComparison();
                
            } catch (error) {
                logStatus('gpuResults', `❌ ${testName} 失敗: ${error.message}`, 'error');
                console.error('GPU Test Error:', error);
            } finally {
                gpuBtn.disabled = false;
                gpuBtn.textContent = '🚀 執行 GPU 測試';
                gpuProgressDiv.style.display = 'none';
            }
        }
        
        // 更新比較結果
        function updateComparison() {
            if (!cpuResults || !gpuResults) return;
            
            const comparisonSection = document.getElementById('comparisonSection');
            const comparisonMetrics = document.getElementById('comparisonMetrics');
            
            const speedRatio = gpuResults.stepsPerSecond / cpuResults.stepsPerSecond;
            const timeRatio = cpuResults.duration / gpuResults.duration;
            const voltageError = Math.abs((gpuResults.finalVoltage - cpuResults.finalVoltage) / cpuResults.finalVoltage * 100);
            const winner = speedRatio > 1 ? 'GPU' : 'CPU';
            const advantage = speedRatio > 1 ? speedRatio.toFixed(2) : (1/speedRatio).toFixed(2);
            
            comparisonMetrics.innerHTML = `
                <div class="metric">
                    <div class="metric-value">${cpuResults.stepsPerSecond.toLocaleString()}</div>
                    <div class="metric-label">CPU 步/秒</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${gpuResults.stepsPerSecond.toLocaleString()}</div>
                    <div class="metric-label">GPU 步/秒</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${winner} ${advantage}x</div>
                    <div class="metric-label">性能優勢</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${voltageError.toFixed(4)}%</div>
                    <div class="metric-label">精度誤差</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${cpuResults.duration.toFixed(1)} ms</div>
                    <div class="metric-label">CPU 耗時</div>
                </div>
                <div class="metric">
                    <div class="metric-value">${gpuResults.duration.toFixed(1)} ms</div>
                    <div class="metric-label">GPU 耗時</div>
                </div>
            `;
            
            comparisonSection.style.display = 'block';
        }
        
        // 診斷 AkingSPICE 庫結構
        function diagnoseAkingSPICE() {
            console.log('=== AkingSPICE 診斷報告 ===');
            console.log('typeof AkingSPICE:', typeof AkingSPICE);
            console.log('AkingSPICE 可用屬性:', Object.keys(AkingSPICE));
            
            if (AkingSPICE.GPUExplicitStateSolver) {
                console.log('GPUExplicitStateSolver 存在');
                console.log('GPUExplicitStateSolver prototype:', Object.getOwnPropertyNames(AkingSPICE.GPUExplicitStateSolver.prototype));
            } else {
                console.log('❌ GPUExplicitStateSolver 不存在');
            }
            
            // 檢查是否有其他相關的 GPU 類
            const gpuRelated = Object.keys(AkingSPICE).filter(key => key.toLowerCase().includes('gpu'));
            console.log('GPU 相關屬性:', gpuRelated);
            
            console.log('=== 診斷報告結束 ===');
        }
        
        // 檢查GPU支援
        async function checkGPUSupport() {
            try {
                logStatus('gpuResults', '檢查 GPU 支援狀態...', 'info');
                
                // 運行診斷
                diagnoseAkingSPICE();
                
                // 首先檢查瀏覽器WebGPU支援
                if (!navigator.gpu) {
                    throw new Error('瀏覽器不支援 WebGPU API');
                }
                
                logStatus('gpuResults', '✅ 瀏覽器支援 WebGPU API', 'success');
                
                // 嘗試請求 WebGPU 適配器
                logStatus('gpuResults', '正在請求 WebGPU 適配器...', 'info');
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    throw new Error('無法取得 WebGPU 適配器 - 可能硬體不支援');
                }
                
                logStatus('gpuResults', '✅ WebGPU 適配器取得成功', 'success');
                logStatus('gpuResults', `GPU 資訊: ${adapter.info?.vendor || 'Unknown'} ${adapter.info?.device || ''}`, 'info');
                
                // 嘗試請求 WebGPU 設備
                logStatus('gpuResults', '正在請求 WebGPU 設備...', 'info');
                const device = await adapter.requestDevice();
                if (!device) {
                    throw new Error('無法取得 WebGPU 設備');
                }
                
                logStatus('gpuResults', '✅ WebGPU 設備取得成功', 'success');
                
                // 檢查 AkingSPICE GPU 求解器
                if (!AkingSPICE.GPUExplicitStateSolver) {
                    throw new Error('GPUExplicitStateSolver 類不可用');
                }
                
                logStatus('gpuResults', '✅ GPU 求解器類可用', 'success');
                
                // 診斷：檢查 AkingSPICE 庫的內部結構
                logStatus('gpuResults', '🔍 診斷：檢查 AkingSPICE 內部結構...', 'info');
                console.log('AkingSPICE.GPUExplicitStateSolver:', AkingSPICE.GPUExplicitStateSolver);
                console.log('AkingSPICE keys:', Object.keys(AkingSPICE));
                
                // 嘗試創建GPU求解器實例，並傳遞WebGPU設備
                logStatus('gpuResults', '正在創建 GPU 求解器實例...', 'info');
                let testSolver;
                try {
                    testSolver = new AkingSPICE.GPUExplicitStateSolver({
                        debug: true,  // 啟用調試模式
                        timeStep: TIME_STEP,
                        webGPUDevice: device,  // 明確傳遞WebGPU設備
                        webGPUAdapter: adapter  // 明確傳遞WebGPU適配器
                    });
                    logStatus('gpuResults', '✅ GPU 求解器實例創建成功', 'success');
                } catch (createError) {
                    logStatus('gpuResults', `❌ GPU 求解器創建失敗: ${createError.message}`, 'error');
                    console.error('Solver creation error:', createError);
                    throw createError;
                }
                
                logStatus('gpuResults', '正在初始化 GPU 求解器...', 'info');
                
                // 診斷：在初始化前檢查一些關鍵屬性
                console.log('testSolver 屬性:', Object.getOwnPropertyNames(testSolver));
                if (testSolver.webgpuSolver) {
                    console.log('webgpuSolver 存在:', testSolver.webgpuSolver);
                } else {
                    console.log('webgpuSolver 不存在');
                }
                
                // 嘗試初始化（這會觸發WebGPU檢查）
                const testCircuit = createTestCircuit();
                try {
                    // 在 initialize 時再次傳遞 WebGPU 設備選項
                    await testSolver.initialize(testCircuit, TIME_STEP, {
                        webGPUDevice: device,
                        webGPUAdapter: adapter
                    });
                } catch (initError) {
                    logStatus('gpuResults', `❌ 初始化詳細錯誤: ${initError.message}`, 'error');
                    console.error('詳細錯誤堆疊:', initError.stack);
                    throw initError;
                }
                
                gpuAvailable = true;
                document.getElementById('gpuStatus').innerHTML = '✅ GPU 加速可用 - WebGPU 初始化成功';
                document.getElementById('gpuTestBtn').disabled = false;
                document.getElementById('gpuSmallBtn').disabled = false;
                document.getElementById('gpuMicroBtn').disabled = false;
                logStatus('gpuResults', '🎉 GPU 支援檢查完成 - 可以開始測試！', 'success');
                logStatus('gpuResults', '🚀 WebGPU 設備初始化成功', 'success');
                
            } catch (error) {
                // 如果傳遞WebGPU設備失敗，嘗試讓求解器自己初始化
                if (error.message.includes('create') || error.message.includes('undefined')) {
                    try {
                        logStatus('gpuResults', '🔄 嘗試備用初始化方法...', 'warning');
                        
                        const fallbackSolver = new AkingSPICE.GPUExplicitStateSolver({
                            debug: true,
                            timeStep: TIME_STEP
                        });
                        
                        const testCircuit = createTestCircuit();
                        await fallbackSolver.initialize(testCircuit, TIME_STEP);
                        
                        gpuAvailable = true;
                        document.getElementById('gpuStatus').innerHTML = '✅ GPU 加速可用 - 備用方法初始化成功';
                        document.getElementById('gpuTestBtn').disabled = false;
                        document.getElementById('gpuSmallBtn').disabled = false;
                        document.getElementById('gpuMicroBtn').disabled = false;
                        logStatus('gpuResults', '🎉 備用初始化成功 - 可以開始測試！', 'success');
                        return;
                        
                    } catch (fallbackError) {
                        logStatus('gpuResults', `❌ 備用初始化也失敗: ${fallbackError.message}`, 'error');
                    }
                }
                
                gpuAvailable = false;
                document.getElementById('gpuStatus').innerHTML = `❌ GPU 不可用: ${error.message}`;
                document.getElementById('gpuTestBtn').disabled = true;
                document.getElementById('gpuSmallBtn').disabled = true;
                document.getElementById('gpuMicroBtn').disabled = true;
                logStatus('gpuResults', `❌ GPU 檢查失敗: ${error.message}`, 'error');
                
                // 詳細錯誤信息和建議
                if (error.message.includes('create') || error.message.includes('undefined')) {
                    logStatus('gpuResults', '💡 WebGPU API 相容性問題:', 'warning');
                    logStatus('gpuResults', '  • 可能是AkingSPICE版本與WebGPU API不相容', 'warning');
                    logStatus('gpuResults', '  • 嘗試更新AkingSPICE庫到最新版本', 'warning');
                    logStatus('gpuResults', '  • 或使用CPU模式進行測試', 'warning');
                } else if (error.message.includes('適配器') || error.message.includes('adapter')) {
                    logStatus('gpuResults', '💡 WebGPU 適配器問題可能原因:', 'warning');
                    logStatus('gpuResults', '  • 顯卡驅動程式過舊 (請更新到最新版)', 'warning');
                    logStatus('gpuResults', '  • 顯卡不支援 WebGPU (需 D3D12 或 Vulkan)', 'warning');
                    logStatus('gpuResults', '  • Windows 版本過舊 (建議 Windows 10 20H1+)', 'warning');
                } else if (error.message.includes('設備') || error.message.includes('device')) {
                    logStatus('gpuResults', '💡 WebGPU 設備問題可能原因:', 'warning');
                    logStatus('gpuResults', '  • GPU 記憶體不足', 'warning');
                    logStatus('gpuResults', '  • 其他應用程式佔用 GPU', 'warning');
                } else if (error.message.includes('WebGPU') || error.message.includes('不支援')) {
                    logStatus('gpuResults', '💡 Chrome WebGPU 啟用檢查:', 'warning');
                    logStatus('gpuResults', '  • 前往 chrome://flags/', 'warning');
                    logStatus('gpuResults', '  • 搜尋 "webgpu" 並啟用', 'warning');
                    logStatus('gpuResults', '  • 重新啟動瀏覽器', 'warning');
                } else {
                    logStatus('gpuResults', '💡 一般故障排除:', 'warning');
                    logStatus('gpuResults', '  • 檢查 chrome://gpu/ 頁面', 'warning');
                    logStatus('gpuResults', '  • 確認 WebGPU 狀態為 "可用"', 'warning');
                    logStatus('gpuResults', '  • 嘗試重新載入頁面', 'warning');
                }
            }
        }
        
        // 性能分析函數
        async function analyzeGPUPerformance() {
            logStatus('gpuResults', '🔬 開始 GPU 性能分析...', 'info');
            
            const testConfigs = [
                { maxIter: 10, tol: 1e-3, name: '超高速模式' },
                { maxIter: 20, tol: 1e-4, name: '高速模式' },
                { maxIter: 50, tol: 1e-6, name: '平衡模式' },
                { maxIter: 100, tol: 1e-8, name: '精確模式' }
            ];
            
            for (const config of testConfigs) {
                const startTime = performance.now();
                
                try {
                    const adapter = await navigator.gpu.requestAdapter();
                    const device = await adapter.requestDevice();
                    
                    const solver = new AkingSPICE.GPUExplicitStateSolver({
                        debug: false,
                        timeStep: TIME_STEP,
                        solverMaxIterations: config.maxIter,
                        solverTolerance: config.tol,
                        webGPUDevice: device,
                        webGPUAdapter: adapter
                    });
                    
                    const circuit = createTestCircuit();
                    await solver.initialize(circuit, TIME_STEP, {
                        webGPUDevice: device,
                        webGPUAdapter: adapter
                    });
                    
                    // 執行 10 步測試
                    for (let i = 0; i < 10; i++) {
                        await solver.step();
                    }
                    
                    const endTime = performance.now();
                    const timePerStep = (endTime - startTime) / 10;
                    const stepsPerSec = 1000 / timePerStep;
                    
                    logStatus('gpuResults', `${config.name}: ${stepsPerSec.toFixed(0)} 步/秒 (${config.maxIter}次迭代, ${config.tol}容忍度)`, 'info');
                    
                } catch (error) {
                    logStatus('gpuResults', `${config.name} 失敗: ${error.message}`, 'error');
                }
            }
        }
        
        // 測試函數
        async function runCPUTest() { await runCPUTestWithSteps(TEST_STEPS, 'CPU大規模測試'); }
        async function runSmallCPUTest() { await runCPUTestWithSteps(SMALL_TEST_STEPS, 'CPU快速測試'); }
        async function runGPUTest() { await runGPUTestWithSteps(TEST_STEPS, 'GPU大規模測試'); }
        async function runSmallGPUTest() { await runGPUTestWithSteps(SMALL_TEST_STEPS, 'GPU快速測試'); }
        async function runMicroGPUTest() { await runGPUTestWithSteps(1000, 'GPU極速測試'); }
        
        // 同時執行兩項測試
        async function runBothTests() {
            const runBothBtn = document.getElementById('runBothBtn');
            runBothBtn.disabled = true;
            runBothBtn.textContent = '⏳ 同時執行中...';
            
            try {
                if (gpuAvailable) {
                    await Promise.all([runCPUTest(), runGPUTest()]);
                } else {
                    logStatus('cpuResults', '⚠️ GPU不可用，僅執行CPU測試', 'warning');
                    await runCPUTest();
                }
            } finally {
                runBothBtn.disabled = false;
                runBothBtn.textContent = '🔥 同時執行 CPU & GPU 測試';
            }
        }
        
        // 重置測試
        function resetTests() {
            cpuResults = null;
            gpuResults = null;
            document.getElementById('cpuResults').innerHTML = '等待測試...';
            document.getElementById('gpuResults').innerHTML = '等待GPU檢查...';
            document.getElementById('cpuMetrics').style.display = 'none';
            document.getElementById('gpuMetrics').style.display = 'none';
            document.getElementById('comparisonSection').style.display = 'none';
            
            // 重新檢查GPU
            checkGPUSupport();
        }
        
        // 檢測瀏覽器WebGPU基本支援
        function detectWebGPUSupport() {
            const status = document.getElementById('gpuStatus');
            
            if (!navigator.gpu) {
                status.innerHTML = '❌ 瀏覽器不支援 WebGPU';
                logStatus('gpuResults', '❌ navigator.gpu 不存在', 'error');
                logStatus('gpuResults', '💡 請使用支援 WebGPU 的瀏覽器', 'warning');
                return false;
            }
            
            status.innerHTML = '🔍 瀏覽器支援 WebGPU，正在檢查 GPU 設備...';
            logStatus('gpuResults', '✅ navigator.gpu 可用', 'success');
            return true;
        }
        
        // 頁面載入完成後初始化
        document.addEventListener('DOMContentLoaded', () => {
            console.log('🚀 AkingSPICE CPU vs GPU 測試頁面載入完成');
            
            // 立即檢查WebGPU基本支援
            const hasWebGPU = detectWebGPUSupport();
            
            setTimeout(() => {
                if (typeof AkingSPICE !== 'undefined') {
                    console.log('✅ AkingSPICE 庫載入成功');
                    logStatus('cpuResults', '🎉 AkingSPICE 庫載入完成！', 'success');
                    
                    // 檢查CPU組件
                    const cpuComponents = ['ExplicitStateSolver', 'VoltageSource', 'Resistor', 'Capacitor'];
                    const cpuMissing = cpuComponents.filter(comp => !AkingSPICE[comp]);
                    if (cpuMissing.length === 0) {
                        logStatus('cpuResults', '✅ CPU 求解器組件完整，可以開始測試！', 'success');
                    } else {
                        logStatus('cpuResults', `❌ 缺少CPU組件: ${cpuMissing.join(', ')}`, 'error');
                    }
                    
                    // 檢查GPU支援（只有在有WebGPU時才進行）
                    if (hasWebGPU) {
                        checkGPUSupport();
                    } else {
                        logStatus('gpuResults', '⚠️ 跳過GPU測試 - WebGPU不可用', 'warning');
                    }
                } else {
                    logStatus('cpuResults', '❌ AkingSPICE 庫載入失敗', 'error');
                    logStatus('gpuResults', '❌ AkingSPICE 庫載入失敗', 'error');
                }
            }, 1000);
        });
    </script>
</body>
</html>