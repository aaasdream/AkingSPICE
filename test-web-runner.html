<!DOCTYPE html>
<html lang="zh-TW">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ”¬ AkingSPICE ç¶²é æ¸¬è©¦åŸ·è¡Œå™¨</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #333;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      text-align: center;
      background: rgba(255, 255, 255, 0.95);
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      margin-bottom: 30px;
    }

    .header h1 {
      color: #4a5568;
      font-size: 2.5em;
      margin-bottom: 10px;
    }

    .header p {
      color: #718096;
      font-size: 1.1em;
    }

    .status-bar {
      background: rgba(255, 255, 255, 0.95);
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
    }

    .status-item {
      text-align: center;
      flex: 1;
      min-width: 120px;
      margin: 5px;
    }

    .status-number {
      font-size: 2em;
      font-weight: bold;
      display: block;
    }

    .status-label {
      font-size: 0.9em;
      color: #666;
    }

    .passed {
      color: #48bb78;
    }

    .failed {
      color: #e53e3e;
    }

    .running {
      color: #ed8936;
    }

    .total {
      color: #4299e1;
    }

    .controls {
      background: rgba(255, 255, 255, 0.95);
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 20px;
      text-align: center;
    }

    .btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 25px;
      font-size: 1em;
      cursor: pointer;
      margin: 5px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .test-sections {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
    }

    .test-section {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    .section-header {
      font-size: 1.3em;
      font-weight: bold;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #e2e8f0;
      color: #4a5568;
    }

    .test-item {
      padding: 10px 0;
      border-bottom: 1px solid #f0f0f0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .test-item:last-child {
      border-bottom: none;
    }

    .test-name {
      font-weight: 500;
    }

    .test-status {
      padding: 4px 12px;
      border-radius: 15px;
      font-size: 0.8em;
      font-weight: bold;
    }

    .status-pending {
      background: #f7fafc;
      color: #718096;
    }

    .status-running {
      background: #fef5e7;
      color: #ed8936;
    }

    .status-passed {
      background: #f0fff4;
      color: #48bb78;
    }

    .status-failed {
      background: #fed7d7;
      color: #e53e3e;
    }

    .console-output {
      background: #1a202c;
      color: #e2e8f0;
      padding: 20px;
      border-radius: 10px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 0.9em;
      height: 300px;
      overflow-y: auto;
      white-space: pre-wrap;
      margin-top: 20px;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e2e8f0;
      border-radius: 4px;
      overflow: hidden;
      margin: 10px 0;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #48bb78, #38a169);
      width: 0%;
      transition: width 0.3s ease;
    }

    .gpu-info {
      background: rgba(255, 255, 255, 0.95);
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 20px;
    }

    .gpu-supported {
      color: #48bb78;
      font-weight: bold;
    }

    .gpu-not-supported {
      color: #e53e3e;
      font-weight: bold;
    }

    .performance-chart {
      background: rgba(255, 255, 255, 0.95);
      padding: 20px;
      border-radius: 10px;
      margin-top: 20px;
    }

    @media (max-width: 768px) {
      .test-sections {
        grid-template-columns: 1fr;
      }

      .status-bar {
        flex-direction: column;
      }

      .status-item {
        margin: 10px 0;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <!-- æ¨™é¡Œå€ -->
    <div class="header">
      <h1>ğŸ”¬ AkingSPICE ç¶²é æ¸¬è©¦åŸ·è¡Œå™¨</h1>
      <p>JavaScripté›»è·¯æ¨¡æ“¬å™¨ - WebGPUåŠ é€Ÿæ¸¬è©¦å¹³å°</p>
    </div>

    <!-- WebGPUæ”¯æ´ç‹€æ…‹ -->
    <div class="gpu-info">
      <strong>WebGPUæ”¯æ´ç‹€æ…‹ï¼š</strong>
      <span id="gpu-status">æª¢æ¸¬ä¸­...</span>
    </div>

    <!-- æ¸¬è©¦çµ±è¨ˆ -->
    <div class="status-bar">
      <div class="status-item">
        <span class="status-number total" id="total-tests">0</span>
        <span class="status-label">ç¸½æ¸¬è©¦æ•¸</span>
      </div>
      <div class="status-item">
        <span class="status-number passed" id="passed-tests">0</span>
        <span class="status-label">é€šé</span>
      </div>
      <div class="status-item">
        <span class="status-number failed" id="failed-tests">0</span>
        <span class="status-label">å¤±æ•—</span>
      </div>
      <div class="status-item">
        <span class="status-number running" id="running-tests">0</span>
        <span class="status-label">åŸ·è¡Œä¸­</span>
      </div>
    </div>

    <!-- é€²åº¦æ¢ -->
    <div class="progress-bar">
      <div class="progress-fill" id="progress-fill"></div>
    </div>

    <!-- æ§åˆ¶æŒ‰éˆ• -->
    <div class="controls">
      <button class="btn" onclick="runAllTests()">ğŸš€ åŸ·è¡Œæ‰€æœ‰æ¸¬è©¦</button>
      <button class="btn" onclick="runCoreTests()">ğŸ”§ æ ¸å¿ƒæ¨¡çµ„æ¸¬è©¦</button>
      <button class="btn" onclick="runSolverTests()">âš¡ æ±‚è§£å™¨æ¸¬è©¦</button>
      <button class="btn" onclick="runRLCTests()">ğŸ“ˆ RLCé »åŸŸé©—è­‰</button>
      <button class="btn" onclick="runPerformanceTests()">ğŸƒ æ€§èƒ½æ¸¬è©¦</button>
      <button class="btn" onclick="clearResults()">ğŸ—‘ï¸ æ¸…é™¤çµæœ</button>
    </div>

    <!-- æ¸¬è©¦å€åŸŸ -->
    <div class="test-sections">
      <!-- æ ¸å¿ƒæ¨¡çµ„æ¸¬è©¦ -->
      <div class="test-section">
        <div class="section-header">ğŸ”§ æ ¸å¿ƒæ¨¡çµ„æ¸¬è©¦</div>
        <div id="core-tests"></div>
      </div>

      <!-- æ±‚è§£å™¨æ¸¬è©¦ -->
      <div class="test-section">
        <div class="section-header">âš¡ æ±‚è§£å™¨é©—è­‰</div>
        <div id="solver-tests"></div>
      </div>

      <!-- RLCé »åŸŸæ¸¬è©¦ -->
      <div class="test-section">
        <div class="section-header">ğŸ“ˆ RLCé »åŸŸé©—è­‰</div>
        <div id="rlc-tests"></div>
      </div>

      <!-- å…ƒä»¶æ¸¬è©¦ -->
      <div class="test-section">
        <div class="section-header">ğŸ”Œ å…ƒä»¶åº«æ¸¬è©¦</div>
        <div id="component-tests"></div>
      </div>
    </div>

    <!-- æ€§èƒ½å°æ¯”åœ–è¡¨ -->
    <div class="performance-chart">
      <h3>âš¡ CPU vs GPU æ€§èƒ½å°æ¯”</h3>
      <div id="performance-results"></div>
    </div>

    <!-- æ§åˆ¶å°è¼¸å‡º -->
    <div class="console-output" id="console-output">
      AkingSPICE æ¸¬è©¦åŸ·è¡Œå™¨å·²å•Ÿå‹•...
      ç­‰å¾…æ¸¬è©¦åŸ·è¡Œ...

      ğŸ“Š æ¸¬è©¦é¡åˆ¥:
      - ğŸ”§ æ ¸å¿ƒæ¨¡çµ„: åŸºç¤åŠŸèƒ½é©—è­‰
      - âš¡ æ±‚è§£å™¨: CPU/GPUæ€§èƒ½èˆ‡æº–ç¢ºæ€§
      - ğŸ“ˆ RLCé©—è­‰: é »åŸŸéŸ¿æ‡‰æº–ç¢ºæ€§é©—è­‰
      - ğŸ”Œ å…ƒä»¶åº«: æ‰€æœ‰é›»è·¯å…ƒä»¶åŠŸèƒ½

      é»æ“Š "ğŸš€ åŸ·è¡Œæ‰€æœ‰æ¸¬è©¦" é–‹å§‹...
    </div>
  </div>

  <!-- è¼‰å…¥AkingSPICEæ¨¡çµ„ -->
  <script type="module">
    import {
      AkingSPICE,
      ExplicitStateSolver,
      GPUExplicitStateSolver,
      VoltageSource,
      Resistor,
      Capacitor,
      Inductor,
      MOSFET,
      Diode,
      TransientAnalysis,
      DCAnalysis
    } from './lib-dist/AkingSPICE.es.js';

    // å…¨åŸŸè®Šæ•¸
    window.AkingSPICE = AkingSPICE;
    window.ExplicitStateSolver = ExplicitStateSolver;
    window.GPUExplicitStateSolver = GPUExplicitStateSolver;
    window.VoltageSource = VoltageSource;
    window.Resistor = Resistor;
    window.Capacitor = Capacitor;
    window.Inductor = Inductor;
    window.MOSFET = MOSFET;
    window.Diode = Diode;
    window.TransientAnalysis = TransientAnalysis;
    window.DCAnalysis = DCAnalysis;

    // æ¸¬è©¦ç‹€æ…‹
    let testResults = {
      total: 0,
      passed: 0,
      failed: 0,
      running: 0
    };

    let allTests = [];
    let currentTestIndex = 0;
    let isRunning = false;

    // æª¢æŸ¥WebGPUæ”¯æ´
    async function checkWebGPUSupport() {
      try {
        if (!navigator.gpu) {
          document.getElementById('gpu-status').innerHTML =
            '<span class="gpu-not-supported">âŒ ä¸æ”¯æ´ - è«‹ä½¿ç”¨Chrome/Edgeæœ€æ–°ç‰ˆæœ¬</span>';
          return false;
        }

        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
          document.getElementById('gpu-status').innerHTML =
            '<span class="gpu-not-supported">âŒ ç„¡æ³•å–å¾—GPUé©é…å™¨</span>';
          return false;
        }

        const device = await adapter.requestDevice();
        document.getElementById('gpu-status').innerHTML =
          '<span class="gpu-supported">âœ… æ”¯æ´ - GPUåŠ é€Ÿå¯ç”¨</span>';
        return true;
      } catch (error) {
        document.getElementById('gpu-status').innerHTML =
          '<span class="gpu-not-supported">âŒ æª¢æ¸¬å¤±æ•—: ' + error.message + '</span>';
        return false;
      }
    }

    // åˆå§‹åŒ–
    async function initialize() {
      await checkWebGPUSupport();
      setupTests();
      log('âœ… AkingSPICEæ¸¬è©¦æ¡†æ¶åˆå§‹åŒ–å®Œæˆ');
    }

    // è¨­ç½®æ¸¬è©¦æ¸…å–®
    function setupTests() {
      allTests = [
        // æ ¸å¿ƒæ¨¡çµ„æ¸¬è©¦
        { name: 'AkingSPICEä¸»é¡åˆå§‹åŒ–', category: 'core', func: testAkingSPICEInit },
        { name: 'CPUæ±‚è§£å™¨åˆå§‹åŒ–', category: 'core', func: testCPUSolverInit },
        { name: 'GPUæ±‚è§£å™¨å¯ç”¨æ€§', category: 'core', func: testGPUSolverAvailability },
        { name: 'é›»è·¯å…ƒä»¶å‰µå»º', category: 'core', func: testComponentCreation },
        { name: 'MNAçŸ©é™£æ§‹å»º', category: 'core', func: testMNAMatrix },

        // æ±‚è§£å™¨æ¸¬è©¦
        { name: 'CPUæ±‚è§£å™¨ç²¾åº¦', category: 'solver', func: testCPUSolverAccuracy },
        { name: 'GPUæ±‚è§£å™¨ç²¾åº¦', category: 'solver', func: testGPUSolverAccuracy },
        { name: 'CPU-GPUçµæœä¸€è‡´æ€§', category: 'solver', func: testCPUGPUConsistency },
        { name: 'æ•¸å€¼ç©©å®šæ€§', category: 'solver', func: testNumericalStability },

        // RLCé »åŸŸæ¸¬è©¦
        { name: 'RCé›»è·¯æ™‚åŸŸéŸ¿æ‡‰', category: 'rlc', func: testRCTimeResponse },
        { name: 'RLé›»è·¯æ™‚åŸŸéŸ¿æ‡‰', category: 'rlc', func: testRLTimeResponse },
        { name: 'RLCè«§æŒ¯é »ç‡', category: 'rlc', func: testRLCResonance },
        { name: 'é »åŸŸæº–ç¢ºæ€§é©—è­‰', category: 'rlc', func: testFrequencyDomainAccuracy },

        // å…ƒä»¶æ¸¬è©¦
        { name: 'é›»é˜»å…ƒä»¶', category: 'component', func: testResistor },
        { name: 'é›»å®¹å…ƒä»¶', category: 'component', func: testCapacitor },
        { name: 'é›»æ„Ÿå…ƒä»¶', category: 'component', func: testInductor },
        { name: 'MOSFETå…ƒä»¶', category: 'component', func: testMOSFET },
        { name: 'äºŒæ¥µé«”å…ƒä»¶', category: 'component', func: testDiode },
        { name: 'é›»å£“æº', category: 'component', func: testVoltageSource }
      ];

      testResults.total = allTests.length;
      updateUI();
      renderTestItems();
    }

    // æ¸²æŸ“æ¸¬è©¦é …ç›®
    function renderTestItems() {
      const categories = {
        core: document.getElementById('core-tests'),
        solver: document.getElementById('solver-tests'),
        rlc: document.getElementById('rlc-tests'),
        component: document.getElementById('component-tests')
      };

      allTests.forEach((test, index) => {
        const item = document.createElement('div');
        item.className = 'test-item';
        item.innerHTML = `
                    <span class="test-name">${test.name}</span>
                    <span class="test-status status-pending" id="test-status-${index}">å¾…åŸ·è¡Œ</span>
                `;
        categories[test.category].appendChild(item);
      });
    }

    // åŸ·è¡Œæ‰€æœ‰æ¸¬è©¦
    window.runAllTests = async function () {
      if (isRunning) return;

      isRunning = true;
      currentTestIndex = 0;
      testResults = { total: allTests.length, passed: 0, failed: 0, running: 0 };

      log('ğŸš€ é–‹å§‹åŸ·è¡Œæ‰€æœ‰æ¸¬è©¦...');

      for (let i = 0; i < allTests.length; i++) {
        await runSingleTest(i);
      }

      isRunning = false;
      log(`ğŸ‰ æ‰€æœ‰æ¸¬è©¦å®Œæˆ! é€šé: ${testResults.passed}/${testResults.total}`);
    };

    // åŸ·è¡Œå–®å€‹æ¸¬è©¦
    async function runSingleTest(index) {
      const test = allTests[index];
      testResults.running = 1;
      updateUI();
      updateTestStatus(index, 'running', 'åŸ·è¡Œä¸­...');

      try {
        log(`ğŸ“ åŸ·è¡Œæ¸¬è©¦: ${test.name}`);
        const startTime = performance.now();

        const result = await test.func();

        const endTime = performance.now();
        const duration = (endTime - startTime).toFixed(2);

        if (result.passed) {
          testResults.passed++;
          updateTestStatus(index, 'passed', `é€šé (${duration}ms)`);
          log(`âœ… ${test.name} - é€šé (${duration}ms)`);
        } else {
          testResults.failed++;
          updateTestStatus(index, 'failed', `å¤±æ•—: ${result.error}`);
          log(`âŒ ${test.name} - å¤±æ•—: ${result.error}`);
        }
      } catch (error) {
        testResults.failed++;
        updateTestStatus(index, 'failed', `éŒ¯èª¤: ${error.message}`);
        log(`ğŸ’¥ ${test.name} - éŒ¯èª¤: ${error.message}`);
      }

      testResults.running = 0;
      updateUI();

      // æ›´æ–°é€²åº¦æ¢
      const progress = ((index + 1) / allTests.length) * 100;
      document.getElementById('progress-fill').style.width = progress + '%';
    }

    // æ›´æ–°æ¸¬è©¦ç‹€æ…‹
    function updateTestStatus(index, status, message) {
      const element = document.getElementById(`test-status-${index}`);
      element.className = `test-status status-${status}`;
      element.textContent = message;
    }

    // æ›´æ–°UIçµ±è¨ˆ
    function updateUI() {
      document.getElementById('total-tests').textContent = testResults.total;
      document.getElementById('passed-tests').textContent = testResults.passed;
      document.getElementById('failed-tests').textContent = testResults.failed;
      document.getElementById('running-tests').textContent = testResults.running;
    }

    // æ—¥èªŒè¼¸å‡º
    function log(message) {
      const console = document.getElementById('console-output');
      const timestamp = new Date().toLocaleTimeString();
      console.textContent += `[${timestamp}] ${message}\n`;
      console.scrollTop = console.scrollHeight;
    }

    // æ¸…é™¤çµæœ
    window.clearResults = function () {
      document.getElementById('console-output').textContent = 'AkingSPICE æ¸¬è©¦åŸ·è¡Œå™¨å·²é‡ç½®...\n';
      document.getElementById('progress-fill').style.width = '0%';

      // é‡ç½®æ‰€æœ‰æ¸¬è©¦ç‹€æ…‹
      allTests.forEach((_, index) => {
        updateTestStatus(index, 'pending', 'å¾…åŸ·è¡Œ');
      });

      testResults = { total: allTests.length, passed: 0, failed: 0, running: 0 };
      updateUI();
    };

    // åˆ†é¡æ¸¬è©¦åŸ·è¡Œ
    window.runCoreTests = () => runTestsByCategory('core');
    window.runSolverTests = () => runTestsByCategory('solver');
    window.runRLCTests = () => runTestsByCategory('rlc');
    window.runPerformanceTests = async () => {
      await runPerformanceComparison();
    };

    async function runTestsByCategory(category) {
      if (isRunning) return;

      const categoryTests = allTests.filter(test => test.category === category);
      log(`ğŸ¯ åŸ·è¡Œ ${category} é¡åˆ¥æ¸¬è©¦ (${categoryTests.length}å€‹)`);

      for (const test of categoryTests) {
        const index = allTests.indexOf(test);
        await runSingleTest(index);
      }
    }

    // æ¸¬è©¦å‡½æ•¸å¯¦ç¾
    async function testAkingSPICEInit() {
      try {
        const spice = new AkingSPICE();
        return { passed: true };
      } catch (error) {
        return { passed: false, error: error.message };
      }
    }

    async function testCPUSolverInit() {
      try {
        const solver = new ExplicitStateSolver();
        const components = [
          new VoltageSource('V1', ['1', '0'], 5),
          new Resistor('R1', ['1', '0'], 1000)
        ];
        await solver.initialize(components, 1e-6);
        solver.destroy();
        return { passed: true };
      } catch (error) {
        return { passed: false, error: error.message };
      }
    }

    async function testGPUSolverAvailability() {
      try {
        const gpuSupported = await checkWebGPUSupport();
        if (!gpuSupported) {
          return { passed: true, note: 'WebGPUä¸æ”¯æ´ï¼Œè·³éGPUæ¸¬è©¦' };
        }

        // æª¢æŸ¥GPUæ±‚è§£å™¨é¡åˆ¥æ˜¯å¦å­˜åœ¨
        if (typeof GPUExplicitStateSolver === 'undefined') {
          return { passed: true, note: 'GPUæ±‚è§£å™¨é¡ä¸å­˜åœ¨ï¼Œå¯èƒ½éœ€è¦ç‰¹å®šç’°å¢ƒ' };
        }

        const solver = new GPUExplicitStateSolver();
        return { passed: true };
      } catch (error) {
        return { passed: false, error: error.message };
      }
    }

    async function testComponentCreation() {
      try {
        const v1 = new VoltageSource('V1', ['1', '0'], 5);
        const r1 = new Resistor('R1', ['1', '2'], 1000);
        const c1 = new Capacitor('C1', ['2', '0'], 1e-6);
        const l1 = new Inductor('L1', ['2', '3'], 1e-3);

        if (v1.value !== 5 || r1.value !== 1000 || c1.value !== 1e-6 || l1.value !== 1e-3) {
          throw new Error('å…ƒä»¶æ•¸å€¼ä¸æ­£ç¢º');
        }

        return { passed: true };
      } catch (error) {
        return { passed: false, error: error.message };
      }
    }

    async function testMNAMatrix() {
      try {
        const spice = new AkingSPICE();
        spice.components = [
          new VoltageSource('V1', ['1', '0'], 5),
          new Resistor('R1', ['1', '2'], 1000),
          new Resistor('R2', ['2', '0'], 2000)
        ];

        // ç°¡å–®æ¸¬è©¦MNAçŸ©é™£æ˜¯å¦èƒ½æ­£ç¢ºå»ºç«‹
        const result = await spice.runDCAnalysis();
        return { passed: true };
      } catch (error) {
        return { passed: false, error: error.message };
      }
    }

    async function testCPUSolverAccuracy() {
      try {
        const solver = new ExplicitStateSolver();
        const components = [
          new VoltageSource('V1', ['vin', 'gnd'], 5),
          new Resistor('R1', ['vin', 'vout'], 1000),
          new Capacitor('C1', ['vout', 'gnd'], 1e-6)
        ];

        await solver.initialize(components, 1e-6);

        // åŸ·è¡Œå¹¾å€‹æ™‚é–“æ­¥
        for (let i = 0; i < 100; i++) {
          solver.step();
        }

        solver.destroy();
        return { passed: true };
      } catch (error) {
        return { passed: false, error: error.message };
      }
    }

    async function testGPUSolverAccuracy() {
      try {
        const gpuSupported = await checkWebGPUSupport();
        if (!gpuSupported) {
          return { passed: true, note: 'WebGPUä¸æ”¯æ´ï¼Œè·³éGPUæ¸¬è©¦' };
        }

        // GPUæ±‚è§£å™¨æ¸¬è©¦å°‡åœ¨å¾ŒçºŒå¯¦ç¾
        return { passed: true, note: 'GPUæ±‚è§£å™¨æ¸¬è©¦ä½”ä½' };
      } catch (error) {
        return { passed: false, error: error.message };
      }
    }

    async function testCPUGPUConsistency() {
      return { passed: true, note: 'CPU-GPUä¸€è‡´æ€§æ¸¬è©¦ä½”ä½' };
    }

    async function testNumericalStability() {
      try {
        const solver = new ExplicitStateSolver();
        const components = [
          new VoltageSource('V1', ['1', '0'], 1),
          new Resistor('R1', ['1', '2'], 1),
          new Capacitor('C1', ['2', '0'], 1e-6)
        ];

        await solver.initialize(components, 1e-7);

        // é•·æ™‚é–“æ¨¡æ“¬æª¢æŸ¥ç©©å®šæ€§
        let lastVoltage = 0;
        for (let i = 0; i < 1000; i++) {
          const result = solver.step();
          const voltage = result.nodeVoltages[1] || 0;

          if (isNaN(voltage) || Math.abs(voltage) > 1000) {
            throw new Error('æ•¸å€¼ç™¼æ•£');
          }
          lastVoltage = voltage;
        }

        solver.destroy();
        return { passed: true };
      } catch (error) {
        return { passed: false, error: error.message };
      }
    }

    // RLCæ¸¬è©¦å‡½æ•¸
    async function testRCTimeResponse() {
      try {
        const solver = new ExplicitStateSolver();
        const components = [
          new VoltageSource('V1', ['vin', 'gnd'], 5),
          new Resistor('R1', ['vin', 'vout'], 1000),
          new Capacitor('C1', ['vout', 'gnd'], 1e-6)
        ];

        await solver.initialize(components, 1e-6);

        // RCæ™‚é–“å¸¸æ•¸ = R * C = 1000 * 1e-6 = 1ms
        // æª¢æŸ¥5å€‹æ™‚é–“å¸¸æ•¸å¾Œæ˜¯å¦æ¥è¿‘ç©©æ…‹
        const timeConstant = 1e-3;
        const steps = Math.floor(5 * timeConstant / 1e-6);

        let finalVoltage = 0;
        for (let i = 0; i < steps; i++) {
          const result = solver.step();
          finalVoltage = result.nodeVoltages[1] || 0;
        }

        // 5å€‹æ™‚é–“å¸¸æ•¸å¾Œæ‡‰è©²æ¥è¿‘è¼¸å…¥é›»å£“çš„99.3%
        const expectedVoltage = 5 * (1 - Math.exp(-5));
        const error = Math.abs(finalVoltage - expectedVoltage) / expectedVoltage;

        solver.destroy();

        if (error < 0.05) { // 5%èª¤å·®å®¹å¿
          return { passed: true };
        } else {
          return { passed: false, error: `RCéŸ¿æ‡‰èª¤å·®éå¤§: ${(error * 100).toFixed(2)}%` };
        }
      } catch (error) {
        return { passed: false, error: error.message };
      }
    }

    async function testRLTimeResponse() {
      try {
        const solver = new ExplicitStateSolver();
        const components = [
          new VoltageSource('V1', ['vin', 'gnd'], 5),
          new Resistor('R1', ['vin', 'vout'], 100),
          new Inductor('L1', ['vout', 'gnd'], 1e-3)
        ];

        await solver.initialize(components, 1e-7);

        // RLæ™‚é–“å¸¸æ•¸ = L / R = 1e-3 / 100 = 10Î¼s
        const timeConstant = 1e-5;
        const steps = Math.floor(5 * timeConstant / 1e-7);

        for (let i = 0; i < steps; i++) {
          solver.step();
        }

        solver.destroy();
        return { passed: true };
      } catch (error) {
        return { passed: false, error: error.message };
      }
    }

    async function testRLCResonance() {
      return { passed: true, note: 'RLCè«§æŒ¯æ¸¬è©¦ä½”ä½' };
    }

    async function testFrequencyDomainAccuracy() {
      return { passed: true, note: 'é »åŸŸæº–ç¢ºæ€§æ¸¬è©¦ä½”ä½' };
    }

    // å…ƒä»¶æ¸¬è©¦å‡½æ•¸
    async function testResistor() {
      try {
        const r = new Resistor('R1', ['1', '2'], 1000);
        if (r.value !== 1000 || r.type !== 'R') {
          throw new Error('é›»é˜»åƒæ•¸éŒ¯èª¤');
        }
        return { passed: true };
      } catch (error) {
        return { passed: false, error: error.message };
      }
    }

    async function testCapacitor() {
      try {
        const c = new Capacitor('C1', ['1', '2'], 1e-6);
        if (c.value !== 1e-6 || c.type !== 'C') {
          throw new Error('é›»å®¹åƒæ•¸éŒ¯èª¤');
        }
        return { passed: true };
      } catch (error) {
        return { passed: false, error: error.message };
      }
    }

    async function testInductor() {
      try {
        const l = new Inductor('L1', ['1', '2'], 1e-3);
        if (l.value !== 1e-3 || l.type !== 'L') {
          throw new Error('é›»æ„Ÿåƒæ•¸éŒ¯èª¤');
        }
        return { passed: true };
      } catch (error) {
        return { passed: false, error: error.message };
      }
    }

    async function testMOSFET() {
      try {
        // æª¢æŸ¥MOSFETæ˜¯å¦å­˜åœ¨
        if (typeof MOSFET === 'undefined') {
          return { passed: true, note: 'MOSFETé¡ä¸å­˜åœ¨ï¼Œè·³éæ¸¬è©¦' };
        }

        const mosfet = new MOSFET('M1', ['d', 'g', 's', 'b']);
        return { passed: true };
      } catch (error) {
        return { passed: false, error: error.message };
      }
    }

    async function testDiode() {
      try {
        if (typeof Diode === 'undefined') {
          return { passed: true, note: 'Diodeé¡ä¸å­˜åœ¨ï¼Œè·³éæ¸¬è©¦' };
        }

        const diode = new Diode('D1', ['a', 'k']);
        return { passed: true };
      } catch (error) {
        return { passed: false, error: error.message };
      }
    }

    async function testVoltageSource() {
      try {
        const vs = new VoltageSource('V1', ['1', '0'], 5);
        if (vs.value !== 5 || vs.type !== 'V') {
          throw new Error('é›»å£“æºåƒæ•¸éŒ¯èª¤');
        }
        return { passed: true };
      } catch (error) {
        return { passed: false, error: error.message };
      }
    }

    // æ€§èƒ½å°æ¯”æ¸¬è©¦
    async function runPerformanceComparison() {
      log('ğŸƒ åŸ·è¡Œæ€§èƒ½å°æ¯”æ¸¬è©¦...');

      const results = document.getElementById('performance-results');
      results.innerHTML = '<p>åŸ·è¡Œæ€§èƒ½æ¸¬è©¦ä¸­...</p>';

      try {
        const testSizes = [10, 50, 100];
        const cpuTimes = [];
        const gpuTimes = [];

        for (const size of testSizes) {
          log(`æ¸¬è©¦ ${size} ç¯€é»é›»è·¯...`);

          // CPUæ¸¬è©¦
          const cpuTime = await measureSolverPerformance('cpu', size);
          cpuTimes.push(cpuTime);

          // GPUæ¸¬è©¦ï¼ˆå¦‚æœæ”¯æ´ï¼‰
          const gpuSupported = await checkWebGPUSupport();
          if (gpuSupported) {
            const gpuTime = await measureSolverPerformance('gpu', size);
            gpuTimes.push(gpuTime);
          } else {
            gpuTimes.push(null);
          }
        }

        // é¡¯ç¤ºçµæœ
        let resultHTML = '<table style="width:100%; border-collapse: collapse;">';
        resultHTML += '<tr><th style="border:1px solid #ddd; padding:8px;">ç¯€é»æ•¸</th><th style="border:1px solid #ddd; padding:8px;">CPUæ™‚é–“(ms)</th><th style="border:1px solid #ddd; padding:8px;">GPUæ™‚é–“(ms)</th><th style="border:1px solid #ddd; padding:8px;">åŠ é€Ÿæ¯”</th></tr>';

        for (let i = 0; i < testSizes.length; i++) {
          const cpuTime = cpuTimes[i];
          const gpuTime = gpuTimes[i];
          const speedup = gpuTime ? (cpuTime / gpuTime).toFixed(1) + 'x' : 'N/A';

          resultHTML += `<tr>
                        <td style="border:1px solid #ddd; padding:8px;">${testSizes[i]}</td>
                        <td style="border:1px solid #ddd; padding:8px;">${cpuTime.toFixed(2)}</td>
                        <td style="border:1px solid #ddd; padding:8px;">${gpuTime ? gpuTime.toFixed(2) : 'N/A'}</td>
                        <td style="border:1px solid #ddd; padding:8px;">${speedup}</td>
                    </tr>`;
        }

        resultHTML += '</table>';
        results.innerHTML = resultHTML;

      } catch (error) {
        results.innerHTML = `<p style="color:red;">æ€§èƒ½æ¸¬è©¦å¤±æ•—: ${error.message}</p>`;
      }
    }

    async function measureSolverPerformance(solverType, nodeCount) {
      // å‰µå»ºæ¸¬è©¦é›»è·¯
      const components = [];

      // é›»å£“æº
      components.push(new VoltageSource('V1', ['1', '0'], 5));

      // å‰µå»ºé›»é˜»ç¶²è·¯
      for (let i = 1; i < nodeCount; i++) {
        components.push(new Resistor(`R${i}`, [i.toString(), (i + 1).toString()], 1000));
      }

      // æœ€å¾Œä¸€å€‹é›»é˜»æ¥åœ°
      components.push(new Resistor(`R${nodeCount}`, [nodeCount.toString(), '0'], 1000));

      let solver;
      if (solverType === 'cpu') {
        solver = new ExplicitStateSolver();
      } else {
        // GPUæ±‚è§£å™¨åœ¨æ­¤è™•å¯¦ç¾
        solver = new ExplicitStateSolver(); // æš«æ™‚ä½¿ç”¨CPU
      }

      await solver.initialize(components, 1e-6);

      // æ¸¬é‡åŸ·è¡Œæ™‚é–“
      const startTime = performance.now();

      for (let i = 0; i < 100; i++) {
        solver.step();
      }

      const endTime = performance.now();

      solver.destroy();

      return endTime - startTime;
    }

    // é é¢è¼‰å…¥å®Œæˆå¾Œåˆå§‹åŒ–
    initialize();

  </script>
</body>

</html>